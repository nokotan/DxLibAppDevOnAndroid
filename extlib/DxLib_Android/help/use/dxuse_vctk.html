<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja-JP">
	<HEAD>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <TITLE>ＤＸライブラリ置き場　使い方説明</TITLE>
	<link rel="shortcut icon" href="../DxLib.ico">
	<link rel="stylesheet" href="../style.css" type="text/css">
	</HEAD>
	<BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0033CC" VLINK="#800040">
	<div class="NormalFont">
	<TABLE ALIGN="LEFT" WIDTH=800  CELLSPACING=0 CELLPADDING=0 >
		<TR>
		<TD ALIGN="LEFT">
		<FONT SIZE="6" COLOR="#000000"><B>
			ＶｉｓｕａｌＣ＋＋　Ｔｏｏｌｋｉｔ　２００３<BR>　によるＤＸライブラリの使い方
		</B></FONT>
		</TD></TR>
		<TR><TD>
		<HR>
		<FONT SIZE="3" COLOR="#000000"><B>
		<BR>

		　VisualC++ Toolkit 2003 を使用してＤＸライブラリを使ったソフトを制作するには<BR>
		以下のような手順を踏みます。<BR><BR><BR>

		<A HREF="#R1">1.ＤＸライブラリを使ったソフトの開発に必要なものを揃える<BR><BR></A>
		<A HREF="#R2">2.プログラムをコンパイルするための下準備をする<BR><BR></A>
		<A HREF="#R3">3.作成するソフト用のフォルダを作成する<BR><BR></A>
		<A HREF="#R4">4.プログラムを組む<BR><BR></A>
		<A HREF="#R5">5.コンパイルを行うバッチファイルの作成、実行<BR><BR><BR></A>

		<A HREF="#R6">番外.Make ファイル<BR><BR><BR><BR></A>


		<A NAME="R1">
		<FONT COLOR="#008800">
		1.でＤＸライブラリを使ったソフトの開発に必要なものを揃える<BR><BR>
		</FONT>
		</A>

		　<FONT COLOR="#990033">VisualC++ Toolkit 2003</FONT> とＤＸライブラリを使用して、実際にＰＣ上で動作する Windows<BR>
		アプリケーションを制作する環境を揃える為には以下のものが必要です。<BR><BR><BR>

		<FONT COLOR="#990033">
		　　・VisualC++ Toolkit 2003<BR>
		　　・Microsoft Platform SDK<BR>
		　　・ＤＸライブラリ Windows版 VisualStudio( C++ )用<BR>
		</FONT><BR><BR>

		　　まず一つ目の <FONT COLOR="#990033">VisualC++ Toolkit 2003</FONT> はプログラムをコンパイルして実行可能なソフトを<BR>
		　作成する為に無くてはならない物です。<BR><BR>

		　　二つ目の <FONT COLOR="#990033">Microsoft Platform SDK</FONT> は WindowsOS 専用の機能を用いたアプリケーション<BR>
		　を作成するために必要なもので、こちらも WindowsOS 上で動作するアプリケーションを作成<BR>
		　するためには無くてはならないものです。<BR>
		　(因みに <FONT COLOR="#990033">SDK</FONT> は <FONT COLOR="#990033">Software Development Kit</FONT> の略称です)<BR><BR>

		　　三つ目の <FONT COLOR="#990033">ＤＸライブラリ Windows版 VisualStudio( C++ )用</FONT> は、ＤＸライブラリを使用して<BR>
		　DirectX を使ったソフトを作成するために必要なものです。<A HREF="../dxdload.html">こちら</A>からダウンロードしておいて下さい。<BR><BR><BR>


		　ＤＸライブラリ以外の２つは、<FONT COLOR="#990033">Ｍｉｃｒｏｓｏｆｔ</FONT> のウェブサイトから無料でダウンロードすることが出来ます。<BR>
		　容量が<FONT COLOR="#990033">数百ＭＢ</FONT>あるので高速な回線とそれなりの時間が必要ですが、順番にダウンロードしていきましょう。<BR><BR>

		　まず <FONT COLOR="#990033">VisualC++ Toolkit 2003</FONT> は<A HREF="http://www.microsoft.com/downloads/details.aspx?FamilyId=272BE09D-40BB-49FD-9CB0-4BFA122FA91B&displaylang=en">こちら</A>からダウンロード出来ます。<BR>
		　<FONT COLOR="#990033">『Download』</FONT>を押してインストーラーをダウンロードして、VisualC++ Toolkit 2003 を<BR>
		インストールして下さい。(インストール時の設定は特に変更する必要はありません)<BR><BR>

		　次に <FONT COLOR="#990033">Microsoft Platform SDK</FONT> ですが、こちらはまず<A HREF="http://www.microsoft.com/downloads/details.aspx?FamilyID=a55b6b43-e24f-4ea3-a93e-40c0ec4f68e5&displaylang=en&Hash=VB346XB">このページ</A>の下の方にある
		<FONT COLOR="#990033">『PSDK-x86.exe』</FONT>を<BR>
		ダウンロードして実行してください。色々訊かれると思いますが、特に設定を変更する必要はありません。<BR>
		　インストールが開始するとインストーラが<FONT COLOR="#990033">必要なファイルを逐次ネット上からダウンロード</FONT>しますので、<BR>
		<FONT COLOR="#990033">インストールが終了するまではネットワーク環境を維持し続ける</FONT>必要があります。<BR>
		　インストール完了までには通信速度にもよりますが、かなり時間も掛かりますので従量制の<BR>
		インターネットサービスをご利用されている方は通信料金に注意して下さい。(汗)<BR><BR>

		　これが全て終われば、DirectX のアプリケーションを作成するために必要なものは揃ったことになります。<BR><BR><BR><BR>


		<A NAME="R2">
		<FONT COLOR="#008800">
		2.プログラムをコンパイルするための下準備をする<BR><BR>
		</FONT>
		</A>

		　必要なものが揃ったところで早速プログラムを組んで見たいところですが、まだちょっとやることがあります。<BR>
		　それは、<FONT COLOR="#990033">作成したプログラムを楽にコンパイルする</FONT>ための準備です。<BR><BR>

		　というのも。<BR>
		　まず、<FONT COLOR="#990033">VisualC++ Toolkit 2003 (のコンパイラ)</FONT>は<FONT COLOR="#990033">『コマンドプロンプト』</FONT>上で動作する<FONT COLOR="#990033"><BR>
		『コンソールアプリケーション』</FONT>なのですが、普通の Windowsアプリケーションと違い、ソフトを<BR>
		起動してから各種の<FONT COLOR="#990033">『設定』</FONT>や<FONT COLOR="#990033">コンパイル</FONT>などの作業を行うタイプのソフトではなく、ソフトを<BR>
		起動するときにコンパイルすべきファイルやコンパイルに必要なファイルの在りか等の<BR>
		諸々の情報を渡す必要があるのです。<BR>
<PRE><div class="NormalFont">例：プログラムファイル test.c を警告レベル３、『実行速度優先』でコンパイルする

cl /W3 /O2 test.c
</div></PRE>
		　上記の例では <FONT COLOR="#990033">cl</FONT> はコンパイラのアプリケーション名、<FONT COLOR="#990033">/W3</FONT> はコンパイラが出力する<BR>
		『警告』をどの程度詳細に行うかという度合いを『３』とするオプション、<FONT COLOR="#990033">/O2</FONT> は<BR>
		プログラムをなるべく高速に動作するようにコンパイルするように指示するための<BR>
		オプション、と、こんな具合に起動する時に必要な情報は全部渡してやる必要があるわけです。<BR><BR>

		　これがプログラムファイルが１つくらいでしたら<FONT COLOR="#990033">『コマンドプロンプト』</FONT>を起動して、その<BR>
		都度コマンドを直接入力しても良いかもしれませんが、後々ソースファイルを幾つも扱う<BR>
		ようになったら一回のコンパイルで入力しなければならないコマンドが長くなって大変です。<BR><BR>

		　なので、ここではその作業を少しでも楽にするための作業をしようというわけです。<BR>
		　ここではコンパイルするに当たって必要な<FONT COLOR="#990033">『環境変数』</FONT>の設定をする<FONT COLOR="#990033">『バッチファイル』</FONT>を作成します。<BR>
		　<FONT COLOR="#990033">『バッチファイル』</FONT>とは<FONT COLOR="#990033">『コマンドプロンプト』</FONT>上で効果がある<FONT COLOR="#990033">コマンド</FONT>の羅列が書かれた<BR>
		<FONT COLOR="#990033">テキスト形式のファイル</FONT>で、	後から好きな時にその<FONT COLOR="#990033">『バッチファイル』</FONT>に書かれている<BR>
		コマンドを実行することが出来るという便利な代物です。<BR><BR>

		　つまり毎回入力する必要がある<FONT COLOR="#990033">『決まり文句』</FONT>的なコマンドを<FONT COLOR="#990033">『バッチファイル』</FONT>にして<BR>
		おくことで、コンパイルする際に必要な手間を減らそうという訳です。<BR><BR>

		　コンパイルするに当たって必要な<FONT COLOR="#990033">『環境変数』</FONT>の設定、この<FONT COLOR="#990033">『環境変数』</FONT>とは、<BR>
		<FONT COLOR="#990033">『環境変数』</FONT>よりは知られているもので例えるなら<FONT COLOR="#990033">『レジストリ』</FONT>みたいなものです。<BR><BR>

		　<FONT COLOR="#990033">VisualC++ Toolkit 2003</FONT> では、この<FONT COLOR="#990033">環境変数</FONT>から<FONT COLOR="#990033">『VisualC++ Toolkit 2003 は何処に<BR>
		インストールされているか』</FONT>や<FONT COLOR="#990033">『コンパイルに必要なファイルはどのフォルダにあるか』</FONT>等の<BR>
		所謂<FONT COLOR="#990033">『位置情報』</FONT>を得ていますので、利用する側はコンパイラを起動する前にそれらの<BR>
		<FONT COLOR="#990033">『環境変数』</FONT>に必要な<FONT COLOR="#990033">位置情報</FONT>を設定しておく必要があるのです。<BR><BR>

		　で、この<FONT COLOR="#990033">『位置情報』</FONT>は早々変わる事のないものばかりなので、<FONT COLOR="#990033">『環境変数』</FONT>に<BR>
		<FONT COLOR="#990033">位置情報</FONT>を設定する<FONT COLOR="#990033">コマンド</FONT>を<FONT COLOR="#990033">『バッチファイル』</FONT>に予め書いておこう、というわけです。<BR><BR>

		　前置きが長くなりましたが、早速 <FONT COLOR="#990033">VisualC++ Toolkit 2003</FONT> が必要とする<FONT COLOR="#990033">『位置情報』</FONT>の<BR>
		<FONT COLOR="#990033">『環境変数』</FONT>の設定を行う<FONT COLOR="#990033">『バッチファイル』</FONT>を作成してみましょう。<BR>
		(ちなみに<FONT COLOR="#990033">『コマンドプロンプト』</FONT>や<FONT COLOR="#990033">『バッチファイル』</FONT>をキーワードに調べると、もっと詳しい<BR>
		情報を得ることが出来ます)<BR><BR>

		　まずメモ帳を開いて以下のような内容を打ち込んで下さい。<BR><BR>
<HR>
<PRE><div class="NormalFont">SET PFSDK=C:\Program Files\Microsoft Platform SDK
SET VCTK=C:\Program Files\Microsoft Visual C++ Toolkit 2003
SET DXLIB=C:\DxLib_VC\プロジェクトに追加すべきファイル_VC用

SET PATH=%VCTK%\bin;%PFSDK%\Bin;%PFSDK%\Bin\Win64;%PATH%
SET INCLUDE=%VCTK%\include;%PFSDK%\Include;%DXLIB%
SET LIB=%VCTK%\lib;%PFSDK%\Lib;%DXLIB%
</div></PRE>
<HR><BR>
		　ここで、上半分の<BR><BR>
<HR>
<PRE><div class="NormalFont">C:\Program Files\Microsoft Platform SDK
C:\Program Files\Microsoft Visual C++ Toolkit 2003
C:\DxLib_VC\プロジェクトに追加すべきファイル_VC用
</div></PRE>
<HR><BR>
		　については、それぞれ上から<FONT COLOR="#990033">『Microsoft Platform SDK』をインストールしたフォルダの位置</FONT>、<BR>
		<FONT COLOR="#990033">『Visual C++ Toolkit 2003』をインストールしたフォルダの位置</FONT>、ＤＸライブラリのアーカイブの中にある<BR>
		<FONT COLOR="#990033">『プロジェクトに追加すべきファイル_VC用』フォルダの位置</FONT>、となりますので、上記通りではない場合は修正して下さい。<BR>
		(恐らく必ず修正することになるのは<FONT COLOR="#990033">ＤＸライブラリのフォルダ</FONT>だと思います)<BR><BR>

		　というわけで、なんとなく分かると思いますが、<FONT COLOR="#990033">『SET』</FONT>というコマンドが<FONT COLOR="#990033">『環境変数』</FONT>に情報を<BR>
		格納するコマンドで、<FONT COLOR="#990033">『SET』</FONT>の右側にある<FONT COLOR="#990033">『PATH』</FONT>や<FONT COLOR="#990033">『VCTK』</FONT>等が<FONT COLOR="#990033">『環境変数』</FONT>の名前です。<BR>
		　実際に <FONT COLOR="#990033">VisualC++ Toolkit 2003</FONT> が必要とする<FONT COLOR="#990033">『環境変数』</FONT>は<FONT COLOR="#990033">『INCLUDE』</FONT>と<FONT COLOR="#990033">『LIB』</FONT>の二つで、<BR>
		それぞれプログラムのコンパイルに必要なファイルが何処にあるか、という情報を格納するように<BR>
		なっています。<BR><BR>

		　尚、<FONT COLOR="#990033">『PATH』</FONT>は<FONT COLOR="#990033">ＯＳ</FONT>が使用している<FONT COLOR="#990033">環境変数</FONT>で、<FONT COLOR="#990033">ＯＳ</FONT>は<FONT COLOR="#990033">『コマンドプロンプト』</FONT>上でコマンドを<BR>
		実行した際に<FONT COLOR="#990033">『カレントディレクトリ(カレントフォルダ)』</FONT>に<FONT COLOR="#990033">指定のファイルが無かった場合</FONT>、<BR>
		この<FONT COLOR="#990033">『PATH』</FONT>という<FONT COLOR="#990033">環境変数</FONT>に<FONT COLOR="#990033">格納されているフォルダ位置</FONT>から<FONT COLOR="#990033">コマンドで指定されたファイルを探す</FONT><BR>
		という動作をします。<BR><BR>

		　ここでは <FONT COLOR="#990033">VisualC++ Toolkit 2003</FONT> のソフトウエアが格納されているフォルダと <FONT COLOR="#990033">Microsoft Platform SDK</FONT><BR>
		のソフトウエアが格納されているフォルダを追加することで、どのフォルダが<FONT COLOR="#990033">『カレントディレクトリ<BR>
		(カレントフォルダ)』</FONT>になっていても <FONT COLOR="#990033">VisualC++ Toolkit 2003</FONT> や <FONT COLOR="#990033">Microsoft Platform SDK</FONT> の<BR>
		ソフトウエアを実行できるようにしていると言う訳です。<BR><BR>

		　因みにその上にある<FONT COLOR="#990033">『VCTK』</FONT>や<FONT COLOR="#990033">『PFSDK』</FONT>も<FONT COLOR="#990033">環境変数</FONT>なのですが、ここではこの<FONT COLOR="#990033">バッチファイル</FONT>内で<BR>
		何回も同じフォルダパスを書くのを楽にするためだけに使っています。(つまり誰でも<FONT COLOR="#990033">『環境変数』</FONT>を<BR>
		使うことが出来るのです)<BR>
		　<FONT COLOR="#990033">環境変数</FONT>に格納した<FONT COLOR="#990033">文字列</FONT>は、<FONT COLOR="#990033">バッチファイル</FONT>内で『<FONT COLOR="#990033">%環境変数名%</FONT>』とすることでそこに<FONT COLOR="#990033">環境変数<BR>
		の内容が在ることと同じ</FONT>になるので、上記の<FONT COLOR="#990033">バッチファイル</FONT>は次の様に書いても同じということになります。<BR>

<BR><HR>
<PRE><div class="NormalFont">SET PATH=C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin;C:\Program Files\Microsoft Platform SDK\Bin;C:\Program Files\Microsoft Platform SDK\Bin\Win64;%PATH%
SET INCLUDE=C:\Program Files\Microsoft Visual C++ Toolkit 2003\include;C:\Program Files\Microsoft Platform SDK\Include;C:\DxLib_VC\プロジェクトに追加すべきファイル_VC用
SET LIB=C:\Program Files\Microsoft Visual C++ Toolkit 2003\lib;C:\Program Files\Microsoft Platform SDK\Lib;C:\DxLib_VC\プロジェクトに追加すべきファイル_VC用
</div></PRE>
<HR><BR>
		　というわけで３行で済みますが、とても一行が長くなってしまいます。(しかもフォルダ位置が<BR>
		変わったら何箇所も修正しなくてはいけません)というわけで、<FONT COLOR="#990033">環境変数</FONT>を利用して利便性を<BR>
		高めているわけです。<BR><BR>

		　ともあれ、これで<FONT COLOR="#990033">『下準備』</FONT>の為の<FONT COLOR="#990033">バッチファイル</FONT>は完成ですので、適当なフォルダに<BR>
		『<FONT COLOR="#990033">"setvctk.bat"</FONT>』というファイル名(<FONT COLOR="#990033">必ずダブルコーテーション(")でファイル名を囲って<BR>
		ください</FONT>)で何処か分かりやすい所に保存しておいてください。<BR>
		(間違って上記の３行版の方を保存しないように注意して下さい(汗))<BR><BR>

		　因みに<FONT COLOR="#990033">拡張子</FONT>(<FONT COLOR="#990033">ファイル名の『.』以降の３・４文字の部分</FONT>)が『<FONT COLOR="#990033">bat</FONT>』ではないと <FONT COLOR="#990033">WindowsOS</FONT> に<BR>
		<FONT COLOR="#990033">『バッチファイル』</FONT>だと認識してもらえないので、<FONT COLOR="#990033">『バッチファイル』</FONT>の<FONT COLOR="#990033">拡張子</FONT>は必ず<FONT COLOR="#990033">『bat』</FONT>になります。<BR><BR>

		　<FONT COLOR="#006600">尚、<FONT COLOR="#990033">『setvctk.bat』</FONT>というファイル名で保存したはずなのに<FONT COLOR="#990033">エクスプローラ</FONT>(<FONT COLOR="#440044">普段何気なく使って<BR>
		いるフォルダの中身を見たりファイルを開いたりする作業を行う際に使用しているソフトの名称です</FONT>)<BR>
		上では<FONT COLOR="#990033">『setvctk』</FONT>と表示されて<FONT COLOR="#990033">拡張子</FONT>の部分である<FONT COLOR="#990033">『.bat』</FONT>が<FONT COLOR="#990033">表示されていない</FONT>、という方は、<BR>
		<FONT COLOR="#990033">エクスプローラ</FONT>の<FONT COLOR="#990033">メニュー</FONT>から<FONT COLOR="#990033">『ツール』→『フォルダオプション』</FONT>で<FONT COLOR="#990033">『フォルダオプション』ダイアログ</FONT><BR>
		を開き、その中の<FONT COLOR="#990033">『表示』</FONT>タグの中の沢山の<FONT COLOR="#990033">チェックボックスのリスト</FONT>の中から<FONT COLOR="#990033">『登録されている<BR>
		拡張子は表示しない』</FONT>の<FONT COLOR="#990033">チェックを外し</FONT>て<FONT COLOR="#990033">『すべてのフォルダに適用』</FONT>ボタンを押した上で<FONT COLOR="#990033">『ＯＫ』</FONT>を<BR>
		押して下さい、そうすれば<FONT COLOR="#990033">エクスプローラ</FONT>上でも<FONT COLOR="#990033">『setvctk.bat』</FONT>とファイル名の全体が表示される<BR>
		ようになると思います。</FONT><BR><BR><BR><BR>


		<A NAME="R3">
		<FONT COLOR="#008800">
		3.作成するソフト用のフォルダを作成する<BR><BR>
		</FONT>
		</A>

		　作成するソフトのプログラムなどのファイルは別に何処にあってもいいのですが、最終的に<BR>
		幾つかのファイルが生成されますので、やはり専用のフォルダを一つ作っておいた方がいい<BR>
		だろう、的な、ただそれだけのことです。(^^;<BR><BR>

		　というわけで、別に一つのソフトに一つの専用フォルダが無ければコンパイルが出来ない<BR>
		とかそういうことは全く在りませんが、これから説明する上でも専用のフォルダがあった方が<BR>
		何かと都合が良いので、とりあえず新しく一つフォルダを作っておいて下さい。<BR><BR>

		　そして、作成したフォルダの中に先程作成した<FONT COLOR="#990033">『setvctk.bat』</FONT>をコピーしておいて下さい。<BR><BR><BR><BR>


		<A NAME="R4">
		<FONT COLOR="#008800">
		4.プログラムを組む<BR><BR>
		</FONT>
		</A>

		　では、いよいよＤＸライブラリを使ったプログラムを組んでみましょう。<BR>
		　まずメモ帳を開いて、次のプログラムを入力してみて下さい。<BR><BR>
	<HR>
<PRE><div class="NormalFont">#include "DxLib.h"

// プログラムは WinMain から始まります
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
						LPSTR lpCmdLine, int nCmdShow )
{
	if( DxLib_Init() == -1 )		// ＤＸライブラリ初期化処理
		return -1 ;			// エラーが起きたら直ちに終了

	DrawPixel( 320 , 240 , GetColor( 255,255,255 ) ) ;	// 点を打つ

	WaitKey() ;				// キー入力待ち

	DxLib_End() ;				// ＤＸライブラリの後始末

	return 0 ;				// ソフトの終了 
}
</div></PRE>
	<HR><BR><BR>
		　どの部分が何をしているのか簡単に説明します。<BR><BR>

		　まず最初の１行は<FONT COLOR="#990033">ＤＸライブラリ</FONT>を使用するために必要なファイルをインクルードしています。<BR><BR>

		　次の<FONT COLOR="#880022">『int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,<BR>
		LPSTR lpCmdLine, int nCmdShow )』</FONT>はウインドウズのプログラムのスタート地点となる<BR>
		関数の宣言です。それぞれの単語が何を意味しているかは特に考える必要はありません。<BR>
		ウインドウ環境のスタート関数はすべてこの形の宣言をとります。<BR><BR>

		　中括弧内の最初の文<FONT COLOR="#880022">『if( !DxLib_Init() ) return -1;』</FONT>は<FONT COLOR="#990033">ＤＸライブラリ</FONT>を初期化して<BR>
		使える状態にするために必要な関数<FONT COLOR="#880022">『DxLib_Init』</FONT>を呼んでいます。<BR>
		　この関数は<FONT COLOR="#990033">ＤＸライブラリ</FONT>を使うプログラムを組む際には一部の例外を除いて必ず<BR>
		最初に呼び出す必要があります。因みに『if(...』と書かれているのは初期化に<BR>
		失敗したらその時点でソフトを終了させるという処理を行うための物です。<BR><BR>

		　<FONT COLOR="#880022">『DrawPixel』</FONT>はそのまま点を描画するための関数です。<BR><BR>

		　その次の<FONT COLOR="#880022">『WaitKey』</FONT>はキーが押されるまで処理を止める関数です。<BR><BR>

		　最後の<FONT COLOR="#880022">『DxLib_End() ;』</FONT>は注釈にも書いてある通り<FONT COLOR="#990033">ＤＸライブラリ</FONT>の後始末を行う<BR>
		関数を呼んでいる文です。<FONT COLOR="#990033">ＤＸライブラリ</FONT>を使用しているプログラムは最後に必ず<BR>
		この関数を呼ばなくてはなりません。<BR>
		　これを呼ばないでソフトを終了するとメモリリーク等の不具合が起こる原因となりますので注意してください。<BR><BR><BR>


		　とまあ、プログラム自体はこんな感じです。<BR>
		　とりあえずこちらを打ち込んだら、『<FONT COLOR="#990033">"pixel.cpp"</FONT>』というファイル名で先程作った専用フォルダに<BR>
		保存して下さい。(<FONT COLOR="#990033">ダブルコーテーション(")で必ずファイル名を囲ってください、そうしないとメモ帳の<BR>
		場合『pixel.cpp.txt』 というファイル名で保存されてしまいます(汗)</FONT>)<BR>
		　これでプログラムの打ち込みは完了です。<BR><BR><BR><BR>


		<A NAME="R5">
		<FONT COLOR="#008800">
		5.コンパイルを行うバッチファイルの作成、実行<BR><BR>
		</FONT>
		</A>

		　プログラムが完成したらコンパイルをします。<BR>
		　コンパイルも<FONT COLOR="#990033">『コマンドプロンプト』</FONT>上で動作するソフトウエアを使用して行うので、コンパイルが<BR>
		失敗した際に何度も同じコマンドを書かなくても良いようにコンパイルの作業も<FONT COLOR="#990033">『バッチファイル』</FONT>に<BR>
		してしまいましょう。<BR><BR>

		　というわけで、とりあえず再度メモ帳を開き、次のように入力して『<FONT COLOR="#990033">"compile.bat"</FONT>』というファイル名で<BR>
		<A HREF="#R3">工程３</A>で作成した専用フォルダに保存してください。(<FONT COLOR="#990033">ダブルコーテーション(")で必ずファイル名を囲ってください</FONT>)<BR><BR>
<HR>
<PRE><div class="NormalFont">call setvctk.bat
cl /c /W3 /O2 pixel.cpp
link /SUBSYSTEM:WINDOWS /OUT:pixel.exe pixel.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib 
pause
</div></PRE>
<HR><BR>
		　この<FONT COLOR="#990033">バッチファイル</FONT>で行っていることを説明します。<BR><BR>

		　まず最初の行では<A HREF="#R2">工程２</A>で作成した<FONT COLOR="#990033">『コンパイルに必要な位置情報を環境変数に設定する<BR>
		バッチファイル』</FONT>を実行しています。<FONT COLOR="#990033">『バッチファイル』</FONT>上で他の<FONT COLOR="#990033">『バッチファイル』</FONT>を実行する時は、<BR>
		大抵その前に<FONT COLOR="#990033">『call』</FONT>を書きます。これを書かないと<FONT COLOR="#990033">『他のバッチファイル』</FONT>(つまりここでは<BR>
		<FONT COLOR="#990033">『setvctk.bat』</FONT>)の実行が終わると残りの<FONT COLOR="#990033">『cl ～～』『link ～～』『pause』</FONT>の３行を実行せずに<BR>
		終了してしまうからです。<BR><BR>

		　２行目ではプログラムファイル<FONT COLOR="#990033">『pixel.cpp』</FONT>をコンパイルしています。<BR><BR>

		　<FONT COLOR="#990033">『cl』</FONT>が<FONT COLOR="#990033">コンパイラ</FONT>のファイル名、<FONT COLOR="#990033">『/c』</FONT>が<FONT COLOR="#990033">『オブジェクトファイル』</FONT>だけを生成してくれ、という<FONT COLOR="#990033">オプション</FONT>、<BR>
		(<FONT COLOR="#990033">『オブジェクトファイル』</FONT>とは、<FONT COLOR="#990033">拡張子</FONT>が<FONT COLOR="#990033">『exe』</FONT>の実行可能ファイルにする一つ前の状態、<BR>
		みたいなもので、<FONT COLOR="#990033">拡張子</FONT>が<FONT COLOR="#990033">『obj』</FONT>のファイルです)<BR>
		　<FONT COLOR="#990033">『/W3』</FONT>が<FONT COLOR="#990033">警告レベル</FONT>を<FONT COLOR="#990033">３</FONT>(大した事ない警告は出力しないでくれ、レベル)にする<FONT COLOR="#990033">オプション</FONT>。<BR>
		　<FONT COLOR="#990033">『/O2』</FONT>がコンパイルして出来る<FONT COLOR="#990033">ネイティブコード</FONT>(ＰＣが直接理解できるプログラム、<FONT COLOR="#990033">『マシン語』</FONT>や<BR>
		<FONT COLOR="#990033">『機械語』</FONT>等とも言います)を<FONT COLOR="#990033">出来るだけ高速に動作</FONT>するものにしてくれ、という<FONT COLOR="#990033">オプション</FONT>。<BR>
		　そして最後の<FONT COLOR="#990033">『pixel.cpp』</FONT>がコンパイルしたいプログラムのファイル名です。<BR><BR>

		　ここでは<FONT COLOR="#990033">『/c』</FONT>のオプションを指定して、<FONT COLOR="#990033">『オブジェクトファイル』</FONT>だけを生成する指定に<BR>
		なっているので、このコマンドが成功すると、<FONT COLOR="#990033">pixel.cpp</FONT> の<FONT COLOR="#990033">拡張子</FONT>が<FONT COLOR="#990033">『obj』</FONT>になった<FONT COLOR="#990033">『pixel.obj』</FONT><BR>
		という<FONT COLOR="#990033">『オブジェクトファイル』</FONT>が <FONT COLOR="#990033">pixel.cpp</FONT> があるフォルダに作成されます。<BR><BR>

		　３行目では２行目で作成した<FONT COLOR="#990033">『オブジェクトファイル』</FONT>とアプリケーションを形成する為に<BR>
		必要なその他の<FONT COLOR="#990033">ライブラリ</FONT>を合体させて、実際にＰＣで動作させることが出来る<BR>
		<FONT COLOR="#990033">拡張子が『exe』</FONT>の<FONT COLOR="#990033">実行可能ファイル</FONT>の生成を行っています。<BR><BR>


		　<FONT COLOR="#990033">『link』</FONT>が、２行目で作成した<FONT COLOR="#990033">『オブジェクトファイル』</FONT>と <FONT COLOR="#990033">Windowsアプリケーション</FONT>の動作に<BR>
		<FONT COLOR="#990033">必須</FONT>の<FONT COLOR="#990033">ライブラリファイル</FONT>や <FONT COLOR="#990033">DirectX</FONT>の機能を使うために必要な<FONT COLOR="#990033">ライブラリファイル</FONT>等を<BR>
		<FONT COLOR="#990033">融合</FONT>させる機能を持つ<FONT COLOR="#990033">アプリケーション</FONT>のファイル名です。(<FONT COLOR="#990033">cl</FONT> が<FONT COLOR="#990033">『コンパイラ』</FONT>で<FONT COLOR="#990033">link</FONT> は<FONT COLOR="#990033">『リンカ』</FONT>)<BR><BR>

		　<FONT COLOR="#990033">『/SUBYSYTEM:WINDOWS』</FONT>は<FONT COLOR="#990033">『Windows上で動くアプリケーションを作りますよ～』</FONT>という<FONT COLOR="#990033">オプション</FONT>。<BR>
		　<FONT COLOR="#990033">『OUT:pixel.exe』</FONT>は<FONT COLOR="#990033">『作成する実行可能ファイルの名前は「pixel.exe」にして下さい』</FONT>という<FONT COLOR="#990033">オプション</FONT>。<BR>
		　そしてその後ろにある沢山のファイル名は、全部実行可能ファイルを作成するために合体させるファイルです。<BR>
		<FONT COLOR="#990033">pixel.obj</FONT> は２行目で作成した<FONT COLOR="#990033">『オブジェクトファイル』</FONT>で、その後ろの<FONT COLOR="#990033">『kernel32.lib user32.lib gdi32.lib<BR>
		shell32.lib ole32.lib advapi32.lib』</FONT>は、<FONT COLOR="#990033">Windows上</FONT>で動作するアプリケーションで必要な機能を<BR>
		提供する<FONT COLOR="#990033">『ライブラリファイル』</FONT>です。<BR>
		(<FONT COLOR="#990033">『LIB』</FONT>という名前の<FONT COLOR="#990033">『環境変数』</FONT>に<FONT COLOR="#990033">設定</FONT>したフォルダ(<FONT COLOR="#990033">『Microsoft Platform SDK』の中</FONT>)にあります)<BR>
		　リンクするこれ等のファイルは、作成する <FONT COLOR="#990033">アプリケーションの内容</FONT>によって<FONT COLOR="#990033">若干数が変わったり<BR>
		ファイルが変わったり</FONT>しますが、<FONT COLOR="#990033">ＤＸライブラリ</FONT>を使う時は必ず上記の６つとなります。<BR>
		　そして、この行のコマンドが無事実行されれば実行可能ファイルが生成されます。<BR><BR>

		　４行目の<FONT COLOR="#990033">『pause』</FONT>はキー入力が行われるまで待つという<FONT COLOR="#990033">コマンド</FONT>です。<BR>
		　<FONT COLOR="#990033">『バッチファイル』</FONT>は、そこに書かれた<FONT COLOR="#990033">コマンド</FONT>がすべて終了するといきなり実行結果を示す<BR>
		ウインドウが閉じてしまうので、ここでキー入力が行われるまで処理をストップしてじっくり<BR>
		実行結果を見れるようにしているわけです。<BR><BR><BR>

		　説明が長くなってしまいましたが、早速このバッチファイルを実行してみましょう。<BR>
		　バッチファイルの実行は普通のソフトのように<FONT COLOR="#990033">ダブルクリック</FONT>で行います。<BR>
		　というわけで、<FONT COLOR="#990033">『compile.bat』</FONT>をダブルクリックで起動してみてください。<BR><BR>

		　・・・どうでしょう？上手くいけば真っ黒のウインドウに次のような出力がされると思います。<BR><BR>
<HR>
<PRE><div class="NormalFont">C:\test>call setvctk.bat
C:\test>SET PFSDK=C:\Program Files\Microsoft Platform SDK
C:\test>SET VCTK=C:\Program Files\Microsoft Visual C++ Toolkit 2003
C:\test>SET DXLIB=C:\DxLib_VC\プロジェクトに追加すべきファイル_VC用

C:\test>SET PATH=C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin;C:\Program Files\Microsoft Platform SDK\Bin;C:\Program Files\Microsoft Platform SDK\Bin\Win64;C:\WINDOWS\system32;C:\WINDOWS;
C:\test>SET INCLUDE=C:\Program Files\Microsoft Visual C++ Toolkit 2003\include;C:\Program Files\Microsoft Platform SDK\Include;C:\DxLib_VC\プロジェクトに追加すべきファイル_VC用
C:\test>SET LIB=C:\Program Files\Microsoft Visual C++ Toolkit 2003\lib;C:\Program Files\Microsoft Platform SDK\Lib;C:\DxLib_VC\プロジェクトに追加すべきファイル_VC用

C:\test>cl /c /W3 /O2 pixel.cpp
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 13.10.3077 for 80x86
Copyright (C) Microsoft Corporation 1984-2002. All rights reserved.

pixel.cpp

C:\test>link /SUBSYSTEM:WINDOWS /OUT:pixel.exe pixel.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib
Microsoft (R) Incremental Linker Version 7.10.3077
Copyright (C) Microsoft Corporation.  All rights reserved.

LINK : warning LNK4089: all references to 'ADVAPI32.dll' discarded by /OPT:REF

C:\test>pause
続行するには何かキーを押してください . . .
</div></PRE>
<HR><BR><BR>

		　上記の表示には、<FONT COLOR="#990033">『setvctk.bat』</FONT>による<FONT COLOR="#990033">『環境変数』</FONT>の設定、<FONT COLOR="#990033">cl</FONT> コマンドによる <FONT COLOR="#990033">pixel.cpp</FONT> の<BR>
		コンパイル、<FONT COLOR="#990033">link</FONT> による<FONT COLOR="#990033">コンパイル</FONT>された<FONT COLOR="#990033">オブジェクトファイル</FONT>とアプリケーション生成に<BR>
		必要な<FONT COLOR="#990033">ライブラリファイル</FONT>との<FONT COLOR="#990033">リンク</FONT>等、アプリケーション構築の全ての過程の結果が<BR>
		出力されています。<BR><BR>

		　プログラムに異常があったり、リンクに必要な情報が足りなかったりと何らかのエラーが<BR>
		発生した場合もここにその旨が出力されます。(<FONT COLOR="#990033">『○○のファイルの何行目にエラーがある』</FONT>等。英語ですが(汗))<BR>
		　そしてこの表示が消えないのは<FONT COLOR="#990033">『pause』</FONT>コマンドの効果、と言うわけです。(何かキーを押すとウインドウは閉じます)<BR><BR>

		　さて、コンパイルが完了したわけですが、もし上記と同じような表示がされていれば<BR>
		コンパイルは成功です。<BR><BR>

		　コンパイルが成功していれば<A HREF="#R3">工程３</A>で作成したフォルダの中に<FONT COLOR="#990033">『pixel.obj』</FONT>と<FONT COLOR="#990033">『pixel.exe』</FONT><BR>
		が作成されているはずです。(<FONT COLOR="#990033">『pixel.obj』</FONT>は<FONT COLOR="#990033">『pixel.exe』</FONT>を作るために生成されたものですので、<BR>
		削除してしまっても問題ありません)<BR>
		　そして、<FONT COLOR="#990033">『pixel.exe』</FONT>を実行すると、プログラムの通り画面の中心に点が一個描画されると思います。<BR>
		　尚、もし<FONT COLOR="#990033">『pixel.exe』</FONT>が出来ていない場合は、何かしらのエラーが発生し、コンパイルが<BR>
		正常に処理が終了しなかったということになりますので、その時は黒いウインドウに出力<BR>
		されたエラー報告に従って原因を修正していくことになります。<BR>
		(<FONT COLOR="#000066">この解説に誤りがある可能性もありますので、上手く行かなかった方は<A HREF="http://hpmboard2.nifty.com/cgi-bin/thread.cgi?user_id=BQE00322&msg_per_page=100&def=100">掲示板</A>までご連絡下さい。m(_ _)m</FONT>)<BR><BR>

		　というわけで、プログラムを組み、実行する所まで出来ました。<BR>
		　出来上がった<FONT COLOR="#990033">『pixel.exe』</FONT>は当然他のＰＣでも実行できる立派な<FONT COLOR="#990033">アプリケーション</FONT>です。<BR>
		　尚、新しくアプリケーションを作成する場合は<A HREF="#R3">工程３</A>から始める事になります。<BR>
		(<A HREF="#R2">工程２</A>までは２度行う必要はないので)<BR><BR>

		　さて、ここではまだＤＸライブラリの機能は初期化と後始末と、点を１個描画するくらいのもの<BR>
		しか使っていません。<BR>
		　このほかの関数は<A HREF="../dxfunc.html">ＤＸライブラリ関数リファレンスのページ</A>で解説されていますので、是非<BR>
		そこに解説されている関数達を駆使して、頭に思い描く<FONT COLOR="#990033">ソフトウエア</FONT>を具現化してみて下さい。<BR><BR><BR><BR><BR><BR><BR>














		<A NAME="R6">
		<FONT COLOR="#008800">
		番外.Makeファイル<BR><BR>
		</FONT>
		</A>

		　プログラムに慣れてくると、自然とプログラムを<FONT COLOR="#990033">複数のファイルに分けて</FONT>組むようになります。<BR>
		　複数のプログラムを<A HREF="#R5">工程５</A>の方法でコンパイルする場合は、次のようなバッチファイルを<BR>
		作成するわけですが・・・<BR><BR>

<PRE><div class="NormalFont">例：pixel.cpp と box.cpp と main.cpp と global.h の４つのプログラムファイルで
　　ひとつのアプリケーション『graph.exe』を生成するバッチファイル

<HR>
call setvctk.bat
cl /c /W3 /O2 pixel.cpp
cl /c /W3 /O2 box.cpp
cl /c /W3 /O2 main.cpp
link /SUBSYSTEM:WINDOWS /OUT:graph.exe box.obj main.obj pixel.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib 
pause
<HR>
(因みに cl する順序、link で書く obj ファイルの順番は何でも大丈夫です)

　尚、プログラム自体は以下のようになっているとします。

<HR>
// global.h

#ifndef __GLOBAL__
#define __GLOBAL__

#include "DxLib.h"

extern void DPixel( void ) ;	// 点を描画する関数
extern void DBox( void ) ;		// 四角形を描画する関数

#endif
<HR>

<HR>
// main.cpp

#include "global.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
						LPSTR lpCmdLine, int nCmdShow )
{
	if( DxLib_Init() == -1 )
		return -1 ;

	DPixel() ;	// pixel.cpp の関数を呼ぶ
	DBox() ;	// box.cpp の関数を呼ぶ

	WaitKey() ;

	DxLib_End() ;

	return 0 ;
}
<HR>

<HR>
// pixel.cpp

#include "global.h"

// 点を打つ関数
void DPixel( void )
{
	DrawPixel( 320, 240, 0xffff ) ;
}
<HR>

<HR>
// box.cpp

#include "global.h"

// 四角形を描画する関数
void DBox( void )
{
	DrawBox( 50, 50, 100, 100, 0xffff, FALSE ) ;
}
<HR>

</div></PRE>
		　まず、<FONT COLOR="#990033">『link』</FONT>で<FONT COLOR="#990033">必要なファイル</FONT>は拡張子が<FONT COLOR="#990033">『obj』</FONT>の<FONT COLOR="#990033">『オブジェクトファイル』</FONT>です。<BR>
		　そして<FONT COLOR="#990033">オブジェクトファイル</FONT>は一回 <FONT COLOR="#990033">cl</FONT> でコンパイルして作成すれば<FONT COLOR="#990033">何回も作る必要</FONT>は<FONT COLOR="#990033">ありません</FONT>。<BR><BR>

		　そんな状況の中で、<FONT COLOR="#990033">pixel.cpp</FONT> と <FONT COLOR="#990033">box.cpp</FONT> は正常にコンパイルが終了し、<FONT COLOR="#990033">main.cpp</FONT> で<BR>
		<FONT COLOR="#990033">コンパイルエラー</FONT>が発生したとします。(いえ、上記のプログラムにエラーはありませんが)<BR><BR>

		　当然 <FONT COLOR="#990033">main.cpp</FONT> で起きたエラーの原因を潰す訳ですが・・・というわけで、潰せたとします。<BR><BR>

		　<FONT COLOR="#990033">main.cpp</FONT> の修正が完了したのでもう一度このバッチファイルを起動します。<BR><BR>

		　すると既に正常にコンパイルが完了している <FONT COLOR="#990033">pixel.cpp</FONT> と <FONT COLOR="#990033">box.cpp</FONT> のコンパイルが再度行われます。<BR><BR>

		　一つのプログラムのコンパイルは一瞬では終わりません。場合によっては数秒かかるでしょう。<BR><BR>

		　・・・・。<BR><BR>

		　あ、修正できたと思った <FONT COLOR="#990033">main.cpp</FONT> でまた<FONT COLOR="#990033">コンパイルエラー</FONT>が起きました。また修正しなくてはなりません。<BR><BR>

		　修正が完了しました。というわけで再度このバッチファイルを実行。<BR><BR>

		　またコンパイルが完了している <FONT COLOR="#990033">pixel.cpp</FONT> と <FONT COLOR="#990033">box.cpp</FONT> のコンパイルが始まります。<BR><BR>

		　・・・・。<BR><BR>

		　そんな状況を目の当たりにして、きっと「ああ、pixel.cpp と box.cpp のコンパイルは<BR>
		もう終わっているのに、無駄だ」と感じると思います。<BR><BR>

		　ですが、だからと言って修正したファイルだけをコンパイルするように一々バッチファイルを<BR>
		書き換えてはこの作業をバッチファイルにした意味がありません。<BR><BR><BR>


		　というわけで、そんな状況を打破するために存在するのが<FONT COLOR="#990033">『Makeファイル』</FONT>と<FONT COLOR="#990033">『Makeファイル』</FONT><BR>
		を実行する為のソフトウエア<FONT COLOR="#990033">『nmake』</FONT>なのです。<BR><BR>

		　<FONT COLOR="#990033">Makeファイル</FONT>とは、バッチファイルのように<FONT COLOR="#990033">実行したいコマンドを書き込んだテキスト形式</FONT>の<BR>
		ファイルで、後から好きな時に<FONT COLOR="#990033">『nmake』</FONT>というソフトウエアで実行することが出来ます。(因みに拡張子は<FONT COLOR="#990033">『mak』</FONT>)<BR>
		　一見バッチファイルのようですが、バッチファイルには出来なかった<FONT COLOR="#990033">『必要の無いコンパイルはしない』</FONT><BR>
		を実現することが出来ます。<BR><BR>

		　と、盛り上げた所でなんですが、<FONT COLOR="#990033">『Makeファイル』</FONT>はバッチファイルの様に<FONT COLOR="#990033">ダブルクリック</FONT>で<BR>
		実行することは出来ませんので、使い時はやはりバッチファイルの力も借ります。<BR><BR>

		　ともあれ、早速<FONT COLOR="#990033">『Makeファイル』</FONT>見てみましょう。<BR>
		　ここでは上記のバッチファイルの<BR><BR>
<HR>
<PRE><div class="NormalFont">cl /c /W3 /O2 pixel.cpp
cl /c /W3 /O2 box.cpp
cl /c /W3 /O2 main.cpp
link /SUBSYSTEM:WINDOWS /OUT:graph.exe box.obj main.obj pixel.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib 
</div></PRE>
<HR><BR>
		　この部分を<FONT COLOR="#990033">『Makeファイル』</FONT>化したいと思います。<BR><BR>

		　で、以下が<FONT COLOR="#990033">『Makeファイル』</FONT>で同様の処理を行うようにしたものです。<BR><BR>
<HR>
<PRE><div class="NormalFont">graph.exe: pixel.obj box.obj main.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib
	link /SUBSYSTEM:WINDOWS /OUT:graph.exe box.obj main.obj pixel.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib

pixel.obj: pixel.cpp
	cl /c /W3 /O2 pixel.cpp

box.obj: box.cpp
	cl /c /W3 /O2 box.cpp

main.obj: main.cpp
	cl /c /W3 /O2 main.cpp

pixel.cpp: global.h

box.cpp: global.h

main.cpp: global.h

global.h: DxLib.h
</div></PRE>
<HR><BR>

		　とりあえずこれを『<FONT COLOR="#990033">"graph.mak"</FONT>』というファイル名で保存しておいてください。(<FONT COLOR="#990033">尚、必ずダブル<BR>
		コーテーション(")で囲ってください</FONT>)<BR><BR>

		　さて、これを<FONT COLOR="#990033">『nmake』</FONT>で実行すると、先程のように <FONT COLOR="#990033">pixel.cpp</FONT> と <FONT COLOR="#990033">box.cpp</FONT> がコンパイルに<BR>
		成功して、<FONT COLOR="#990033">main.cpp</FONT> だけがコンパイルに失敗して、再度コンパイルする羽目になったとしても、<BR>
		<FONT COLOR="#990033">『バッチファイル』</FONT>の時のようにまた <FONT COLOR="#990033">pixel.cpp</FONT> と <FONT COLOR="#990033">box.cpp</FONT> までコンパイルしてしまう<BR>
		と言うことは無く、<FONT COLOR="#990033">main.cpp</FONT> だけをコンパイルしてくれます。<BR><BR>

		　その仕組みですが、まず <FONT COLOR="#990033">Makeファイル</FONT>の中身は、基本的には次のような<FONT COLOR="#990033">書式</FONT>の<FONT COLOR="#990033">ブロック</FONT>が<BR>
		<FONT COLOR="#990033">何個もある</FONT>ような形態になっています。<BR><BR>
<PRE><div class="NormalFont"><FONT COLOR="#006600">目標(のファイル)</FONT>: <FONT COLOR="#006600">目標に依存するファイル１ [目標に依存するファイル２] ... [目標に依存するファイルｎ]</FONT>
	<FONT COLOR="#006600">[目標の達成に必要なコマンド]</FONT>
</div></PRE>
		　<FONT COLOR="#990033">[]</FONT>で囲われているところは別に無くても問題が無い部分です。<BR>
		　なんとなく、意味が分かると思います。<BR><BR>

		　とりあえず上記の <FONT COLOR="#990033">Makeファイル</FONT>を一番上から見ていきましょう<BR><BR>
<HR>
<PRE><div class="NormalFont">graph.exe: pixel.obj box.obj main.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib
	link /SUBSYSTEM:WINDOWS /OUT:graph.exe box.obj main.obj pixel.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib
</div></PRE>	
<HR><BR>
		　いきなりすごいファイル数ですが。(汗)<BR>
		　この<FONT COLOR="#990033">ブロック</FONT>では<FONT COLOR="#990033">『目標』</FONT>が<FONT COLOR="#990033">『graph.exe』</FONT>、<FONT COLOR="#990033">『目標の依存するファイル』</FONT>が<FONT COLOR="#990033">『pixel.obj』『box.obj』<BR>
		『main.obj』</FONT>その他<FONT COLOR="#990033">『～～.lib』</FONT>、<FONT COLOR="#990033">『目標の達成に必要なコマンド』</FONT>は下行の<FONT COLOR="#990033">『link ～～』</FONT>となっています。<BR><BR>

		　<FONT COLOR="#990033">『graph.exe』</FONT>を作成(達成)する為には<FONT COLOR="#990033">『link～～』</FONT>のコマンドを実行しなければいけません。<BR>
		　そして<FONT COLOR="#990033">『link～～』</FONT>を実行するためには<FONT COLOR="#990033">『pixel.obj』『box.obj』『main.obj』『～～.lib』</FONT>の存在は不可欠。<BR>
		つまり<FONT COLOR="#990033">『pixel.obj』『box.obj』『main.obj』『～～.lib』</FONT>に<FONT COLOR="#990033">『graph.exe』</FONT>は<FONT COLOR="#990033">『依存』</FONT>しているわけです。<BR><BR>

		　なんとなく、意味が分かると思います。<BR><BR>

<HR>
<PRE><div class="NormalFont">pixel.obj: pixel.cpp
	cl /c /W3 /O2 pixel.cpp

box.obj: box.cpp
	cl /c /W3 /O2 box.cpp

main.obj: main.cpp
	cl /c /W3 /O2 main.cpp
</div></PRE>
<HR><BR>
		　このブロックでは<FONT COLOR="#990033">『目標』</FONT>が<FONT COLOR="#990033">『pixel.obj』</FONT>、<FONT COLOR="#990033">『目標に依存するファイル』</FONT>が<FONT COLOR="#990033">『pixel.cpp』</FONT>、<BR>
		<FONT COLOR="#990033">『目標の達成に必要なコマンド』</FONT>は下の行の<FONT COLOR="#990033">『cl /c /W3 /O2 pixel.cpp』</FONT>になっています。<BR>
		　この後の２ブロックも同じような感じです。<BR><BR>

<HR>
<PRE><div class="NormalFont">pixel.cpp: global.h

box.cpp: global.h

main.cpp: global.h

global.h: DxLib.h
</div></PRE>
<HR><BR>
		　<FONT COLOR="#990033">『pixel.cpp』</FONT>は<FONT COLOR="#990033">『global.h』</FONT>を<FONT COLOR="#990033">『#include』</FONT>しているので、<FONT COLOR="#990033">『global.h』</FONT>に<FONT COLOR="#990033">『依存』</FONT>しています。<BR>
		　後も同様にそれぞれ<FONT COLOR="#990033">『#include』</FONT>している関係として<FONT COLOR="#990033">『依存』</FONT>していると言えます。<BR><BR>

		　言えます、が、これらの<FONT COLOR="#990033">『目標』</FONT>を<FONT COLOR="#990033">達成(作成)</FONT>するのは<FONT COLOR="#990033">プログラマ</FONT>です。<BR>
		　作成に何か<FONT COLOR="#990033">コマンド</FONT>が必要なわけではありません。必要なのはプログラマの能力です。<BR>
		　コマンドが必要ないのでここでは<FONT COLOR="#990033">依存関係</FONT>が書かれているだけで、当然の如く<BR>
		<FONT COLOR="#990033">『目標の達成に必要なコマンド』</FONT>は何も書かれていません。<BR><BR>

		　ではこれに一体何の意味があるのか、と言いますと、その答えは<BR><BR>
		
		　　　<FONT COLOR="#990033">『nmake』が『目標の達成に必要なコマンド』を実行する条件</FONT><BR><BR>
		
		　の中にあります。<BR><BR><BR>

		　まず<FONT COLOR="#990033">『nmake』</FONT>は起動すると、最初に <FONT COLOR="#990033">Makeファイル</FONT>の<FONT COLOR="#990033">一番上のブロック</FONT>を見ます。<BR>
		　そして、先程示した <FONT COLOR="#990033">Makeファイル</FONT>の<FONT COLOR="#990033">書式</FONT><BR><BR>

<PRE><div class="NormalFont"><FONT COLOR="#006600">目標(のファイル)</FONT>: <FONT COLOR="#006600">目標に依存するファイル１ [目標に依存するファイル２] ... [目標に依存するファイルｎ]</FONT>
	<FONT COLOR="#006600">[目標の達成に必要なコマンド]</FONT>
</div></PRE>
		　の、<FONT COLOR="#990033">『目標の達成に必要なコマンド』</FONT>を、次の<FONT COLOR="#990033">条件のどれかが当てはまる場合だけ</FONT>実行します。<BR><BR><BR>


		　　　１．　<FONT COLOR="#990033">『目標』(のファイル)</FONT>が存在しない場合<BR><BR>

		　　　２．　<FONT COLOR="#990033">『目標』</FONT>より<FONT COLOR="#990033">『更新日時』</FONT>が新しい<FONT COLOR="#990033">『目標に依存するファイル』</FONT>が存在する場合<BR><BR>

		　　　３．　<FONT COLOR="#990033">『目標に依存するファイル』</FONT>以外の、<FONT COLOR="#990033">『目標』</FONT>に少しでも<FONT COLOR="#990033">依存関係</FONT>があるファイルの中に<BR>
		　　　　　<FONT COLOR="#990033">『目標』</FONT>より<FONT COLOR="#990033">『更新日時』</FONT>が新しいファイルがあった場合<BR><BR>

<FONT COLOR="#000066">
		　　　　　　　その詳細は、<FONT COLOR="#990033">『目標に依存するファイル』(①)</FONT>が<FONT COLOR="#990033">『目標』</FONT>として存在するブロックが存在し、<BR>
		　　　　　　且つそのブロック内の<FONT COLOR="#990033">『目標に依存するファイル』</FONT>の何れか一つでも<FONT COLOR="#990033">『目標<FONT COLOR="#006600">(そのブロックでの<BR>
		　　　　　　『目標』ではなく、①が『目標に依存するファイル』として存在するブロックの『目標』)</FONT>』</FONT>より<BR>
		　　　　　　<FONT COLOR="#990033">『更新日時』</FONT>が新しい場合。<BR><BR>

		　　　　　　　又はそのブロックに存在する<FONT COLOR="#990033">『目標に依存するファイル』</FONT>が<FONT COLOR="#990033">『目標』</FONT>として存在する<BR>
		　　　　　　ブロックが存在し、且つそのブロック内の<FONT COLOR="#990033">『目標に依存するファイル』</FONT>の何れか一つでも<FONT COLOR="#990033">『目標<BR>
		　　　　　　<FONT COLOR="#006600">(そのブロックの『目標』ではなく、①が『目標に依存するファイル』として存在するブロックの<BR>
		　　　　　　『目標』</FONT>)』</FONT>より<FONT COLOR="#990033">『更新日時』</FONT>が新しい場合。<BR><BR>

		　　　　　　(更にそのブロックで<FONT COLOR="#990033">『目標に依存するファイル』</FONT>が<FONT COLOR="#990033">『目標』</FONT>として存在するブロックが存在する<BR>
		　　　　　　場合は、そのブロックの<FONT COLOR="#990033">『目標に依存するファイル』</FONT>とも<FONT COLOR="#990033">『更新日時』</FONT>の比較を行う、この調子で<BR>
		　　　　　　<FONT COLOR="#990033">『目標に依存するファイル』</FONT>が<FONT COLOR="#990033">『目標』</FONT>として存在するブロックが一つもなくなって始めてこの判断<BR>
		　　　　　　は終了する)<BR><BR><BR>
</FONT>

		　<FONT COLOR="#990033">１</FONT>と<FONT COLOR="#990033">２</FONT>の<FONT COLOR="#990033">条件</FONT>は最初に判定出来ますが、<FONT COLOR="#990033">３</FONT>の<FONT COLOR="#990033">条件</FONT>を判定するには<FONT COLOR="#990033">一番上のブロック</FONT>で<BR>
		<FONT COLOR="#990033">『目標に依存するファイル』</FONT>として書かれているファイルが<FONT COLOR="#990033">『目標』</FONT>として存在するブロックが<BR>
		在るかどうかを調べる必要があります。<BR><BR>

		　そして<FONT COLOR="#990033">一番上のブロック</FONT>で<FONT COLOR="#990033">『目標に依存するファイル』</FONT>だったファイルが<FONT COLOR="#990033">『目標』</FONT>として<BR>
		存在するブロックが在った場合は、そこでも上記の条件でそのブロックにおける<BR>
		<FONT COLOR="#990033">『目標の達成に必要なコマンド』</FONT>を実行するかどうかを判断し、<FONT COLOR="#990033">条件</FONT>が当てはまる場合は実行します。<BR>
		(更にそのブロックの<FONT COLOR="#990033">『目標に依存するファイル』</FONT>が<FONT COLOR="#990033">『目標』</FONT>として存在するブロックが在った<BR>
		場合は、そのブロックについても同様の処理が行われます)<BR><BR>

		　という条件を前提に<FONT COLOR="#990033">『目標達成に必要なコマンド』</FONT>が存在しないブロックの存在意義を<BR>
		考えてみると、<FONT COLOR="#990033">『目標の達成に必要なコマンド』</FONT>がないブロックでも、そのブロックで<FONT COLOR="#990033">『目標』</FONT><BR>
		としているファイルが何処か別のブロックで<FONT COLOR="#990033">『目標に依存するファイル』</FONT>として使われていれば、<BR>
		そのブロックがコンパイルするかどうかの判定に影響を与えているということが分かります。<BR><BR>

		　例えば、<FONT COLOR="#990033">『DxLib.h』</FONT>が一文字でも更新されると、すべてのプログラムファイルが再度コンパイルされ、<BR>
		<FONT COLOR="#990033">『graph.exe』</FONT>も作成され直されます。<BR>
		　逆に、<FONT COLOR="#990033">『global.h: DxLib.h』</FONT>と書かれたブロックが無いと <FONT COLOR="#990033">『DxLib.h』</FONT>が書き換えられても<FONT COLOR="#990033">『nmake』</FONT>は<BR>
		<FONT COLOR="#990033">『再コンパイルが必要』</FONT>という判断をどのブロックにも下しません。<BR>
		(なので、<FONT COLOR="#990033">『#include』</FONT>を増やしたら<FONT COLOR="#990033">Makeファイル</FONT>も忘れずに更新する必要があります)<BR><BR><BR>

		
		　さて、長くなってしまいましたが、この <FONT COLOR="#990033">Makeファイル</FONT>を使った方法に<FONT COLOR="#990033">バッチファイル</FONT>を書き換えて見ましょう。<BR>
		　<FONT COLOR="#990033">バッチファイル</FONT>の中身は <FONT COLOR="#990033">Makeファイル</FONT>を使う前は<BR><BR>
<HR>
<PRE><div class="NormalFont">call setvctk.bat
cl /c /W3 /O2 pixel.cpp
cl /c /W3 /O2 box.cpp
cl /c /W3 /O2 main.cpp
link /SUBSYSTEM:WINDOWS /OUT:graph.exe box.obj main.obj pixel.obj kernel32.lib user32.lib gdi32.lib shell32.lib ole32.lib advapi32.lib 
pause
</div></PRE>
<HR><BR>
		　でしたが、これを <FONT COLOR="#990033">Makeファイル</FONT>を使ったものに書き直すと<BR>
		　
<HR>
<PRE><div class="NormalFont">call setvctk.bat
nmake -f graph.mak
pause
</div></PRE>
<HR><BR>
		　となります。(<FONT COLOR="#990033">『nmake -f graph.mak』</FONT>が <FONT COLOR="#990033">Makeファイル『graph.mak』</FONT>を実行しているところです)<BR>
		　実行してみると、一番最初は変更前と変わらずすべてのプログラムファイルをコンパイル<BR>
		すると思いますが、後から３つあるプログラムファイルの内の一つを書き直したからと言って、<BR>
		変更前のバッチファイルの様に３つのプログラム全部を再度コンパイルしてしまう、なんてことは<BR>
		なくなります。<BR><BR>

		　まあ、３つ程度でしたらその都度コンパイルしてもいいかもしれませんが、後々数十個の<BR>
		プログラムファイル扱うようになったりすると、一部のプログラムを書き換えただけで全部の<BR>
		プログラムが再度コンパイルされる位だったら、ちょっと苦労してでも <FONT COLOR="#990033">Makeファイル</FONT>を<BR>
		書いた方が良い、と言う風になります。(^^; <BR><BR>

		　さて、ここでは <FONT COLOR="#990033">Makeファイル</FONT>の書き方の本当に基礎的なことしか書いていません。<BR>
		　ここに書かれていない機能を利用すれば、もっと少ないテキスト量でも同様の効果が<BR>
		得られる <FONT COLOR="#990033">Makeファイル</FONT>を作ることが出来ますので、興味がありましたら是非調べてみてください。<BR><BR><BR>

		<HR>
		<A HREF="../dxuse.html">戻る</A>

		</B></FONT>
		</TD></TR>
	</TABLE>
	</div>
	</BODY>
</HTML>
