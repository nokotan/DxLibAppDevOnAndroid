<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja-JP">
    <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <link rel="shortcut icon" href="../DxLib.ico">
    <link rel="stylesheet" href="../style.css" type="text/css">
    <title>ＤＸライブラリ置き場　３Ｄ関係関数リファレンスページ</title>
    </head>
    <body bgcolor="#ffffff" text="#000000" link="#0033CC" vlink="#800040">
    <div class="NormalFont">
    <table align="center" width="600" cellspacing="0" cellpadding="0" >

        <tr><td><font size="3" color="#005500"><b>算術演算関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N1">宣言</a></b></td><td><font color="#000088"><b>VECTOR VGet( float x, float y, float z ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ベクトルを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float x ： 取得するベクトルのＸ成分<br> 
            float y ： 取得するベクトルのＹ成分<br>
            float z ： 取得するベクトルのＺ成分
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>引数 x,y,z を代入したVECTOR 構造体</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 x, y, z を VECTOR 構造体のメンバ変数 x, y, z に代入して返すだけの関数です。<br>
<pre><div class="NormalFont">戻り値.x = x ;
戻り値.y = y ;
戻り値.z = z ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect に値を代入します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値( x=100.0f y=200.0f z=400.0f )を代入
    Vect = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 400.0f ) ;

    // Vect の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N2">宣言</a></b></td><td><font color="#000088"><b>VECTOR VAdd( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つのベクトルを加算する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： 加算されるベクトル<br> 
            VECTOR In2 ： 加算するベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>In1 と In2 の値を加算した VECTOR 構造体</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 の x, y, z 成分を加算した結果を戻り値として返す関数です。<br>
<pre><div class="NormalFont">戻り値.x = In1.x + In2.x ;
戻り値.y = In1.y + In2.y ;
戻り値.z = In1.z + In2.z ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect1 と Vect2 を加算して、結果を Vect1 に代入します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect1 と Vect2 に値を代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;
    Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

    // Vect1 と Vect2 を加算して結果を Vect1 に代入
    Vect1 = VAdd( Vect1, Vect2 ) ;

    // Vect1 の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N3">宣言</a></b></td><td><font color="#000088"><b>VECTOR VSub( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つのベクトルを減算する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： 減算されるベクトル<br> 
            VECTOR In2 ： 減算するベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>In1 から In2 の値を減算した VECTOR 構造体</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 から In2 の x, y, z 成分を減算した結果を戻り値として返す関数です。<br>
<pre><div class="NormalFont">戻り値.x = In1.x - In2.x ;
戻り値.y = In1.y - In2.y ;
戻り値.z = In1.z - In2.z ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect1 から Vect2 を減算して、結果を Vect1 に代入します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect1 と Vect2 に値を代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;
    Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

    // Vect1 から Vect2 を減算して結果を Vect1 に代入
    Vect1 = VSub( Vect1, Vect2 ) ;

    // Vect1 の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N4">宣言</a></b></td><td><font color="#000088"><b>float VDot( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つのベクトルの内積を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： 内積するベクトル１<br> 
            VECTOR In2 ： 内積するベクトル２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>In1 と In2 の内積値</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 の内積を返す関数です。<br>
<pre><div class="NormalFont">戻り値 = In1.x * In2.x + In1.y * In2.y + In1.z * In2.z ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect1 と Vect2 の内積を画面に表示します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect1 と Vect2 に値を代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;
    Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

    // Vect1 と Vect2 の内積を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Dot  %f", VDot( Vect1, Vect2 ) ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N5">宣言</a></b></td><td><font color="#000088"><b>VECTOR VCross( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つのベクトルの外積を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： 外積するベクトル１<br> 
            VECTOR In2 ： 外積するベクトル２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>In1 と In2 の外積値</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 の外積を返す関数です。<br>
<pre><div class="NormalFont">戻り値.x = In1.y * In2.z - In1.z * In2.y ;
戻り値.y = In1.z * In2.x - In1.x * In2.z ;
戻り値.z = In1.x * In2.y - In1.y * In2.x ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect1 と Vect2 の外積を画面に表示します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect1 と Vect2 に値を代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;
    Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

    // Vect1 と Vect2 の外戚を Vect1 に代入
    Vect1 = VCross( Vect1, Vect2 ) ;

    // Vect1 の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N6">宣言</a></b></td><td><font color="#000088"><b>VECTOR VScale( VECTOR In, float Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ベクトルのスケーリングをする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In ： スケーリングをするベクトル<br> 
            float Scale ： スケーリング値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スケーリングした結果の VECTOR 構造体</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In のベクトルを Scale 倍して返す関数です。<br>
<pre><div class="NormalFont">戻り値.x = In.y * Scale ;
戻り値.y = In.z * Scale ;
戻り値.z = In.x * Scale ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect の内容を 8.0f 倍して、その結果を画面に表示します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // Vect を 8.0f 倍して、その結果を Vect に代入
    Vect = VScale( Vect, 8.0f ) ;

    // Vect の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N9">宣言</a></b></td><td><font color="#000088"><b>float VSize( VECTOR In ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ベクトルのサイズを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In ： サイズを取得したいベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ベクトルのサイズ</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In のベクトルのサイズを取得する関数です。<br>
<pre><div class="NormalFont">戻り値 = sqrt( In1.x * In1.x + In1.y * In1.y + In1.z * In1.z ) ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect のサイズを画面に表示します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // Vect のサイズを画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Size  %f", VSize( Vect ) ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N10">宣言</a></b></td><td><font color="#000088"><b>float VSquareSize( VECTOR In ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ベクトルのサイズの２乗を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In ： サイズの二乗を取得したいベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ベクトルのサイズの二乗</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In のベクトルのサイズの二乗を取得する関数です。<br><br>
                    　ベクトルのサイズを算出するには処理負荷の高い平方根計算を行わなければならないので、
                    二つのサイズの比較等、
                    サイズの二乗でも処理に支障が発生しない場合はこちらの関数を使用したほうが処理負荷が低くて済みます。<br>
<pre><div class="NormalFont">戻り値 = In1.x * In1.x + In1.y * In1.y + In1.z * In1.z ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect のサイズの二乗を画面に表示します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // Vect のサイズの二乗を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Size  %f", VSquareSize( Vect ) ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N11">宣言</a></b></td><td><font color="#000088"><b>VECTOR VNorm( VECTOR In ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>正規化ベクトルを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In ： 正規化したいベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>正規化したベクトル</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In を正規化したベクトルを取得する関数です。<br>
                    　正規化とはベクトルの方向は変えずにサイズを１にすることで、
                    ベクトルの方向成分だけを取得したい場合などに行います。<br>
<pre><div class="NormalFont">float size ;
size =  VSize( In ) ;
戻り値.x = In1.x / size ;
戻り値.y = In1.y / size ;
戻り値.z = In1.z / size ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect を正規化した値を画面に表示します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // Vect の値を正規化して、その結果を Vect に代入する
    Vect = VNorm( Vect ) ;

    // Vect の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N12">宣言</a></b></td><td><font color="#000088"><b>VECTOR VTransform( VECTOR InV, MATRIX InM ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>行列を使ったベクトルの変換<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR InV ： 変換処理を行いたいベクトル<br>
            MATRIX InM ： 変換処理に使用するベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>変換後のベクトル</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InV のベクトルを引数 InM の行列を使用して変換処理を行います。<br>
                    　計算的には InV を１ｘ４行列として扱い( 4つめの要素は 1.0f とします ) InM の行列の左から乗算した結果を返します。<br>
<pre><div class="NormalFont">戻り値.x = InV.x * InM.m[0][0] + InV.y * InM.m[1][0] + InV.z * InM.m[2][0] + InM.m[3][0] ;
戻り値.y = InV.x * InM.m[0][1] + InV.y * InM.m[1][1] + InV.z * InM.m[2][1] + InM.m[3][1] ;
戻り値.z = InV.x * InM.m[0][2] + InV.y * InM.m[1][2] + InV.z * InM.m[2][2] + InM.m[3][2] ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect をスケーリング行列を使用して 0.5f 倍します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;
    MATRIX Matrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // 0.5倍スケーリングを行う行列を作成
    Matrix = <b><a href="dxfunc_3d_math.html#R11N15">MGetScale</a></b>( VGet( 0.5f, 0.5f, 0.5f ) ) ;

    // 0.5倍スケーリングを行う行列を使用してベクトルのサイズを0.5倍した結果を Vect に代入する
    Vect = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect, Matrix ) ;

    // Vect の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>
        

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N13">宣言</a></b></td><td><font color="#000088"><b>VECTOR VTransformSR( VECTOR InV, MATRIX InM ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>行列を使ったベクトルの変換( スケーリング＋回転成分のみ )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR InV ： 変換処理を行いたいベクトル<br>
            MATRIX InM ： 変換処理に使用するベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>変換後のベクトル</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InV のベクトルを引数 InM の行列を使用して変換処理を行います。<br>
                    　計算的には InV を１ｘ４行列として扱い( 4つめの要素は 0.0f とします ) InM の行列の左から乗算した結果を返します。<br>
                    　<b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> と違い InV を行列として見立てた際の第４要素が 0.0f なので
                    <b><a href="dxfunc_3d_math.html#R11N16">MGetTranslate</a></b> 等の第４要素の 1.0f と乗算することで平行移動を実現している効果が反映されません。<br>
<pre><div class="NormalFont">戻り値.x = InV.x * InM.m[0][0] + InV.y * InM.m[1][0] + InV.z * InM.m[2][0] ;
戻り値.y = InV.x * InM.m[0][1] + InV.y * InM.m[1][1] + InV.z * InM.m[2][1] ;
戻り値.z = InV.x * InM.m[0][2] + InV.y * InM.m[1][2] + InV.z * InM.m[2][2] ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect をスケーリング行列を使用して 0.5f 倍します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;
    MATRIX Matrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // 0.5倍スケーリングを行う行列を作成
    Matrix = <b><a href="dxfunc_3d_math.html#R11N15">MGetScale</a></b>( VGet( 0.5f, 0.5f, 0.5f ) ) ;

    // 0.5倍スケーリングを行う行列を使用してベクトルのサイズを0.5倍した結果を Vect に代入する
    Vect = VTransformSR( Vect, Matrix ) ;

    // Vect の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>
        

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N14">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetIdent( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>単位行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>単位行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　単位行列を戻り値として返してくる関数です。<br>
<pre><div class="NormalFont">戻り値行列
m[0][0]=1.0f m[0][1]=0.0f m[0][2]=0.0f m[0][3]=0.0f
m[1][0]=0.0f m[1][1]=1.0f m[1][2]=0.0f m[1][3]=0.0f
m[2][0]=0.0f m[2][1]=0.0f m[2][2]=1.0f m[2][3]=0.0f
m[3][0]=0.0f m[3][1]=0.0f m[3][2]=0.0f m[3][3]=1.0f
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　単位行列を取得して画面に表示します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 単位行列を Matrix に代入
    Matrix = MGetIdent() ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0,  0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        
        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N15">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetScale( VECTOR Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>拡大行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Scale ： 拡大値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>拡大行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 Scale で指定された拡大値で拡大する行列を戻り値として返してくる関数です。<br>
                    　拡大行列は <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 Scale で指定した分だけ拡大します。<br>
<pre><div class="NormalFont">戻り値行列
m[0][0]=Scale.x m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=Scale.z m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=Scale.z m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　拡大行列を取得してベクトルの拡大変換を行います。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // 拡大行列を Matrix に代入
    Matrix = MGetScale( VGet( 2.0f, 5.0f, 8.0f ) ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "拡大行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>
        

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N16">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetTranslate( VECTOR Trans ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>平行移動行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Trans ： 平行移動値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>平行移動行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 Trans で指定された平行移動を行う行列を戻り値として返してくる関数です。<br>
                    　平行移動行列は <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 Trans で指定した分だけ移動し( 値が加算され )ます。<br>
<pre><div class="NormalFont">戻り値行列
m[0][0]=1.0f    m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=1.0f    m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=1.0f    m[2][3]=0.0f
m[3][0]=Trans.x m[3][1]=Trans.y m[3][2]=Trans.z m[3][3]=1.0f
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　平行移動行列を使用してベクトルの平行移動変換を行います。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // 平行移動行列を Matrix に代入
    Matrix = <b><a href="dxfunc_3d_math.html#R11N16">MGetTranslate</a></b>( VGet( 100.0f, 80.0f, 85.0f ) ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "平行移動行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N17">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotX( float XAxisRotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>Ｘ軸回転行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float XAxisRotate ： 回転値( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Ｘ軸回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 XAxisRotate で指定された回転値分だけＸ軸回転する回転行列を戻り値として返してくる関数です。<br>
                    　Ｘ軸回転行列は <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 XAxisRotate で指定した分だけＸ軸回転します。<br>
<pre><div class="NormalFont">戻り値行列
float Sin, Cos ;
Sin = sin( XAxisRotate ) ;
Cos = cos( XAxisRotate ) ;
m[0][0]=1.0f    m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]= Cos    m[1][2]=Sin     m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=-Sin    m[2][2]=Cos     m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　Ｘ軸回転行列を使用してベクトルのＸ軸回転を行います。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // Ｘ軸回転行列を Matrix に代入( 45度回転する行列 )
    Matrix = <b><a href="dxfunc_3d_math.html#R11N17">MGetRotX</a></b>( DX_PI_F / 4.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｘ軸回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>
        
        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N18">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotY( float YAxisRotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>Ｙ軸回転行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float YAxisRotate ： 回転値( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Ｙ軸回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 YAxisRotate で指定された回転値分だけＹ軸回転する回転行列を戻り値として返してくる関数です。<br>
                    　Ｙ軸回転行列は <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 YAxisRotate で指定した分だけＹ軸回転します。<br>
<pre><div class="NormalFont">戻り値行列
float Sin, Cos ;
Sin = sin( YAxisRotate ) ;
Cos = cos( YAxisRotate ) ;
m[0][0]=Cos     m[0][1]=0.0f    m[0][2]=-Sin    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=1.0f    m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=Sin     m[2][1]=0.0f    m[2][2]= Cos    m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　Ｙ軸回転行列を使用してベクトルのＹ軸回転を行います。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // Ｙ軸回転行列を Matrix に代入( 45度回転する行列 )
    Matrix = <b><a href="dxfunc_3d_math.html#R11N18">MGetRotY</a></b>( DX_PI_F / 4.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N19">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotZ( float ZAxisRotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>Ｚ軸回転行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float ZAxisRotate ： 回転値( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Ｚ軸回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 ZAxisRotate で指定された回転値分だけＺ軸回転する回転行列を戻り値として返してくる関数です。<br>
                    　Ｚ軸回転行列は <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 ZAxisRotate で指定した分だけＺ軸回転します。<br>
<pre><div class="NormalFont">戻り値行列
float Sin, Cos ;
Sin = sin( ZAxisRotate ) ;
Cos = cos( ZAxisRotate ) ;
m[0][0]= Cos    m[0][1]=Sin     m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=-Sin    m[1][1]=Cos     m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=1.0f    m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　Ｚ軸回転行列を使用してベクトルのＺ軸回転を行います。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // Ｚ軸回転行列を Matrix に代入( 45度回転する行列 )
    Matrix = <b><a href="dxfunc_3d_math.html#R11N19">MGetRotZ</a></b>( DX_PI_F / 4.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｚ軸回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        
        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N20">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotAxis( VECTOR RotateAxis, float Rotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定軸で指定角度回転する行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR RotateAxis ： 回転軸
            float Rotate ： 回転値( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 RotateAxis を回転軸として、引数 Rotate で指定された回転値分だけ回転する回転行列を戻り値として返してくる関数です。<br>
                    　<b><a href="dxfunc_3d_math.html#R11N18">MGetRotY</a></b> や <b><a href="dxfunc_3d_math.html#R11N17">MGetRotX</a></b> はそれぞれ回転軸を Ｙ軸、Ｘ軸としていますが、
                    時には基本軸以外を軸として回転したい場合があります、この関数はそんなときに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　MGetRotAxis 関数を使用して敢えてＹ軸回転行列を作成します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // MGetRotAxis を使用して敢えてＹ軸回転行列を Matrix に代入( 45度回転する行列 )
    Matrix = MGetRotAxis( VGet( 0.0f, 1.0f, 0.0f ), DX_PI_F / 4.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N21">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotVec2( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ある向きからある向きへ変換する回転行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： ある向きのベクトル
            VECTOR In2 ： ある向きを変換後のベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 の向きを引数 In2 の向きに変換するような回転行列を戻り値として返してくる関数です。<br>
                    　ただ、元の向きから９０度以上回転する場合は期待した回転行列が得られない可能性があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　Ｘ軸のプラスの方向をＹ軸のマイナスの方向に回転する行列を取得する。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｘ軸のプラスの方向をＹ軸のマイナスの方向に回転する行列を取得する
    Matrix = MGetRotVec2( <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 1.0f, 0.0f, 0.0f ), VGet( 0.0f, -1.0f, 0.0f ) ) ;

    // Ｘ軸に対してプラスの値を Vect1 に代入
    Vect1 = VGet( 80.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>
        
        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N22">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetAxis1( VECTOR XAxis, VECTOR YAxis, VECTOR ZAxis, VECTOR Pos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定の３軸上のベクトルを基本軸上のベクトルに変換する行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR XAxis ： 任意のＸ軸の基本軸上での方向<br>
            VECTOR YAxis ： 任意のＹ軸の基本軸上での方向<br>
            VECTOR ZAxis ： 任意のＺ軸の基本軸上での方向<br>
            VECTOR Pos ： 任意の３軸の基本軸上での原点
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>変換行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　任意の３軸上のＸＹＺ値を基本軸上のＸＹＺ値に変換する行列を作成します。<br>
<pre><div class="NormalFont">戻り値行列
m[0][0]=XAxis.x m[0][1]=XAxis.y m[0][2]=XAxis.z m[0][3]=0.0f
m[1][0]=YAxis.x m[1][1]=YAxis.y m[1][2]=YAxis.z m[1][3]=0.0f
m[2][0]=ZAxis.x m[2][1]=ZAxis.y m[2][2]=ZAxis.z m[2][3]=0.0f
m[3][0]=Pos.x   m[3][1]=Pos.y   m[3][2]=Pos.z   m[3][3]=1.0f
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　基本軸上のＹのプラス値をＸ軸<br>
            　　基本軸上のＺのプラス値をＹ軸<br>
            　　基本軸上のＸのマイナス値をＺ軸とし、<br>
            　　且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする<br>
            　　３軸上のベクトルを基本軸上のベクトルに変換する行列を取得する
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 基本軸上のＹのプラス値をＸ軸
    // 基本軸上のＺのプラス値をＹ軸
    // 基本軸上のＸのマイナス値をＺ軸とし、
    // 且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする
    // ３軸上のベクトルを基本軸上のベクトルに変換する行列の取得
    Matrix = MGetAxis1( 
                <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>(  0.0f, 1.0f, 0.0f ),
                VGet(  0.0f, 0.0f, 1.0f ),
                VGet( -1.0f, 0.0f, 0.0f ),
                VGet( 100.0f, 0.0f, 200.0f ) ) ;

    // 上記軸上のＸ軸とＹ軸に対してプラスのベクトル Vect1 に代入
    Vect1 = VGet( 80.0f, 50.0f, 0.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "変換行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N23">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetAxis2( VECTOR XAxis, VECTOR YAxis, VECTOR ZAxis, VECTOR Pos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>基本軸上のベクトルを指定の３軸上のベクトルに変換する行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR XAxis ： 任意のＸ軸の基本軸上での方向<br>
            VECTOR YAxis ： 任意のＹ軸の基本軸上での方向<br>
            VECTOR ZAxis ： 任意のＺ軸の基本軸上での方向<br>
            VECTOR Pos ： 任意の３軸の基本軸上での原点
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>変換行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　基本軸上のＸＹＺ値を任意の３軸上のＸＹＺ値に変換する行列を作成します。<br>
<pre><div class="NormalFont">戻り値行列
m[0][0]=XAxis.x m[0][1]=YAxis.x m[0][2]=ZAxis.x m[0][3]=0.0f
m[1][0]=XAxis.y m[1][1]=YAxis.y m[1][2]=ZAxis.y m[1][3]=0.0f
m[2][0]=XAxis.z m[2][1]=YAxis.z m[2][2]=ZAxis.z m[2][3]=0.0f
m[3][0]=-( Pos.x * XAxis.x + Pos.y * XAxis.y + Pos.z * XAxis.z )
m[3][1]=-( Pos.x * YAxis.x + Pos.y * YAxis.y + Pos.z * YAxis.z )
m[3][2]=-( Pos.x * ZAxis.x + Pos.y * ZAxis.y + Pos.z * ZAxis.z )
m[3][3]=1.0f
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　基本軸上のベクトルを<br>
            　　基本軸上のＹのプラス値をＸ軸<br>
            　　基本軸上のＺのプラス値をＹ軸<br>
            　　基本軸上のＸのマイナス値をＺ軸とし、<br>
            　　且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする<br>
            　　３軸上のベクトルに変換する行列を取得する
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 基本軸上のベクトルを
    // 基本軸上のＹのプラス値をＸ軸
    // 基本軸上のＺのプラス値をＹ軸
    // 基本軸上のＸのマイナス値をＺ軸とし、
    // 且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする
    // ３軸上のベクトルに変換する行列の取得
    Matrix = MGetAxis2( 
                <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>(  0.0f, 1.0f, 0.0f ),
                VGet(  0.0f, 0.0f, 1.0f ),
                VGet( -1.0f, 0.0f, 0.0f ),
                VGet( 100.0f, 0.0f, 200.0f ) ) ;

    // 任意の３軸上の原点に位置する基本軸上のベクトルを Vect に代入
    Vect1 = VGet( 100.0f, 0.0f, 200.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "変換行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N24">宣言</a></b></td><td><font color="#000088"><b>MATRIX MAdd( MATRIX In1, MATRIX In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つの行列の足し算を行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX In1 ： 足し算を行う行列１<br>
            MATRIX In2 ： 足し算を行う行列２<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>足し算を行った結果の行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 で渡した行列の足し算を行い、
                    結果の行列を戻り値として返す関数です。<br>
                    　行列の足し算は行列の要素を単純に足すだけのものです。<br>
<pre><div class="NormalFont">戻り値行列
m[0][0] = In1.m[0][0] + In2.m[0][0]
m[0][1] = In1.m[0][1] + In2.m[0][1]
m[0][2] = In1.m[0][2] + In2.m[0][2]
m[0][3] = In1.m[0][3] + In2.m[0][3]

m[1][0] = In1.m[1][0] + In2.m[1][0]
m[1][1] = In1.m[1][1] + In2.m[1][1]
m[1][2] = In1.m[1][2] + In2.m[1][2]
m[1][3] = In1.m[1][3] + In2.m[1][3]

m[2][0] = In1.m[2][0] + In2.m[2][0]
m[2][1] = In1.m[2][1] + In2.m[2][1]
m[2][2] = In1.m[2][2] + In2.m[2][2]
m[2][3] = In1.m[2][3] + In2.m[2][3]

m[3][0] = In1.m[3][0] + In2.m[3][0]
m[3][1] = In1.m[3][1] + In2.m[3][1]
m[3][2] = In1.m[3][2] + In2.m[3][2]
m[3][3] = In1.m[3][3] + In2.m[3][3]
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ベクトルを０．８倍する行列と０．２倍する行列を足して、その行列を使用して<br>
            　ベクトルを変換します、０．８倍と０．２倍を足すと１．０倍なので、ベクトルは<br>
            　変換前と同じ値になります。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix1, Matrix2 ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ０．８倍に拡大する行列と０．２倍に拡大する行列を Matrix1 と Matrix2 に代入
    Matrix1 = <b><a href="dxfunc_3d_math.html#R11N15">MGetScale</a></b>( <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 0.8f, 0.8f, 0.8f ) ) ;
    Matrix2 = MGetScale( VGet( 0.2f, 0.2f, 0.2f ) ) ;

    // 二つの行列を足したものを Matrix に代入
    Matrix = MAdd( Matrix1, Matrix2 ) ;

    // 適当な値を Vect1 に代入
    Vect1 = VGet( 100.0f, 0.0f, 200.0f ) ;

    // Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix1 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "０．８倍行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

    // Matrix2 の値を画面に表示
    DrawString( 0, 96, "０．２倍行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "加算後の行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N25">宣言</a></b></td><td><font color="#000088"><b>MATRIX MMult( MATRIX In1, MATRIX In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つの行列の乗算を行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX In1 ： 乗算する左側の行列<br>
            MATRIX In2 ： 乗算する右側の行列<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>乗算した結果の行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 を乗算した結果の行列を戻り値として返す関数です。<br>
                    　行列と行列の乗算は複数の行列の効果を合成することができます。
                    ( 合成された行列は In1 → In2 の順で効果が現れます( 例：拡大行列と平行移動行列を乗算した場合、
                    その行列を使用して変換( <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> )したベクトルは拡大行列→平行移動行列の順で変換( VTransform )した場合と同じ結果になります ) )<br>
<pre><div class="NormalFont">戻り値行列
m[0][0] = In1.m[0][0] * In2.m[0][0] + In1.m[0][1] * In2.m[1][0] +
          In1.m[0][2] * In2.m[2][0] + In1.m[0][3] * In2.m[3][0] ;
m[0][1] = In1.m[0][0] * In2.m[0][1] + In1.m[0][1] * In2.m[1][1] +
          In1.m[0][2] * In2.m[2][1] + In1.m[0][3] * In2.m[3][1] ;
m[0][2] = In1.m[0][0] * In2.m[0][2] + In1.m[0][1] * In2.m[1][2] +
          In1.m[0][2] * In2.m[2][2] + In1.m[0][3] * In2.m[3][2] ;
m[0][3] = In1.m[0][0] * In2.m[0][3] + In1.m[0][1] * In2.m[1][3] +
          In1.m[0][2] * In2.m[2][3] + In1.m[0][3] * In2.m[3][3] ;

m[1][0] = In1.m[1][0] * In2.m[0][0] + In1.m[1][1] * In2.m[1][0] +
          In1.m[1][2] * In2.m[2][0] + In1.m[1][3] * In2.m[3][0] ;
m[1][1] = In1.m[1][0] * In2.m[0][1] + In1.m[1][1] * In2.m[1][1] +
          In1.m[1][2] * In2.m[2][1] + In1.m[1][3] * In2.m[3][1] ;
m[1][2] = In1.m[1][0] * In2.m[0][2] + In1.m[1][1] * In2.m[1][2] +
          In1.m[1][2] * In2.m[2][2] + In1.m[1][3] * In2.m[3][2] ;
m[1][3] = In1.m[1][0] * In2.m[0][3] + In1.m[1][1] * In2.m[1][3] +
          In1.m[1][2] * In2.m[2][3] + In1.m[1][3] * In2.m[3][3] ;

m[2][0] = In1.m[2][0] * In2.m[0][0] + In1.m[2][1] * In2.m[1][0] +
          In1.m[2][2] * In2.m[2][0] + In1.m[2][3] * In2.m[3][0] ;
m[2][1] = In1.m[2][0] * In2.m[0][1] + In1.m[2][1] * In2.m[1][1] +
          In1.m[2][2] * In2.m[2][1] + In1.m[2][3] * In2.m[3][1] ;
m[2][2] = In1.m[2][0] * In2.m[0][2] + In1.m[2][1] * In2.m[1][2] +
          In1.m[2][2] * In2.m[2][2] + In1.m[2][3] * In2.m[3][2] ;
m[2][3] = In1.m[2][0] * In2.m[0][3] + In1.m[2][1] * In2.m[1][3] +
          In1.m[2][2] * In2.m[2][3] + In1.m[2][3] * In2.m[3][3] ;

m[3][0] = In1.m[3][0] * In2.m[0][0] + In1.m[3][1] * In2.m[1][0] +
          In1.m[3][2] * In2.m[2][0] + In1.m[3][3] * In2.m[3][0] ;
m[3][1] = In1.m[3][0] * In2.m[0][1] + In1.m[3][1] * In2.m[1][1] +
          In1.m[3][2] * In2.m[2][1] + In1.m[3][3] * In2.m[3][1] ;
m[3][2] = In1.m[3][0] * In2.m[0][2] + In1.m[3][1] * In2.m[1][2] +
          In1.m[3][2] * In2.m[2][2] + In1.m[3][3] * In2.m[3][2] ;
m[3][3] = In1.m[3][0] * In2.m[0][3] + In1.m[3][1] * In2.m[1][3] +
          In1.m[3][2] * In2.m[2][3] + In1.m[3][3] * In2.m[3][3] ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ベクトルをＹ軸回転９０度する行列とＹ軸回転－９０度する２倍に拡大する行列を乗算して<br>
            　ベクトルに対してＹ軸回転行列→２倍拡大行列の順で <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> を使用した場合と同じ効果がある行列を作成します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix1, Matrix2 ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｙ軸回転９０度する行列とＹ軸回転－９０度する行列を作成
    Matrix1 = <b><a href="dxfunc_3d_math.html#R11N18">MGetRotY</a></b>(  DX_PI_F / 2.0f ) ;
    Matrix2 = MGetRotY( -DX_PI_F / 2.0f ) ;

    // 二つの行列を０．５倍して加算したものを Matrix に代入
    Matrix = <b><a href="dxfunc_3d_math.html#R11N24">MAdd</a></b>( MScale( Matrix1, 0.5f ), MScale( Matrix2, 0.5f ) ) ;

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 200.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix1 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸９０度回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

    // Matrix2 の値を画面に表示
    DrawString( 0, 96, "Ｙ軸－９０度回転行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "乗算後の行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N26">宣言</a></b></td><td><font color="#000088"><b>MATRIX MScale( MATRIX InM, float Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>行列のスケーリングを行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX InM ： スケーリングする行列<br>
            float Scale ： スケーリング値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スケーリングした結果の行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InM で渡された行列の各要素に Scale を乗算した行列を戻り値として返す関数です。<br>
<pre><div class="NormalFont">戻り値行列
m[0][0] = InM.m[0][0] * Scale ;
m[0][1] = InM.m[0][1] * Scale ;
m[0][2] = InM.m[0][2] * Scale ;
m[0][3] = InM.m[0][3] * Scale ;

m[1][0] = InM.m[1][0] * Scale ;
m[1][1] = InM.m[1][1] * Scale ;
m[1][2] = InM.m[1][2] * Scale ;
m[1][3] = InM.m[1][3] * Scale ;

m[2][0] = InM.m[2][0] * Scale ;
m[2][1] = InM.m[2][1] * Scale ;
m[2][2] = InM.m[2][2] * Scale ;
m[2][3] = InM.m[2][3] * Scale ;

m[3][0] = InM.m[3][0] * Scale ;
m[3][1] = InM.m[3][1] * Scale ;
m[3][2] = InM.m[3][2] * Scale ;
m[3][3] = InM.m[3][3] * Scale ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ベクトルをＹ軸回転９０度する行列とＸ軸回転９０度する行列をそれぞれ０．５倍して<br>
            　加算したものを作ります。<br>
            　　この行列はＹ軸回転９０度する行列を使用して <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> したベクトルと<br>
            　Ｘ軸回転９０度する行列を使用して VTransform したベクトルをそれぞれ０．５倍して<br>
            　加算したものと同じ結果が出力される行列となります。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix1, Matrix2 ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｙ軸回転９０度する行列とＸ軸回転９０度する行列を作成
    Matrix1 = <b><a href="dxfunc_3d_math.html#R11N18">MGetRotY</a></b>( DX_PI_F / 2.0f ) ;
    Matrix2 = <b><a href="dxfunc_3d_math.html#R11N17">MGetRotX</a></b>( DX_PI_F / 2.0f ) ;

    // 二つの行列を０．５倍して加算したものを Matrix に代入
    Matrix = <b><a href="dxfunc_3d_math.html#R11N24">MAdd</a></b>( MScale( Matrix1, 0.5f ), MScale( Matrix2, 0.5f ) ) ;

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 200.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix1 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸９０度回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

    // Matrix2 の値を画面に表示
    DrawString( 0, 96, "Ｘ軸９０度回転行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "乗算後の行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N27">宣言</a></b></td><td><font color="#000088"><b>MATRIX MTranspose( MATRIX InM ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>転置行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX InM ： 転置する行列<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>転置した結果の行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InM で渡された行列を転置したものを戻り値として返す関数です。<br>
                    　転置行列とは行列要素の行と列を逆転したものです。<br>
                    　転置する行列が回転行列の場合は逆回転する行列となります。<br>
<pre><div class="NormalFont">戻り値行列
m[0][0] = InM.m[0][0] ;
m[0][1] = InM.m[1][0] ;
m[0][2] = InM.m[2][0] ;
m[0][3] = InM.m[3][0] ;

m[1][0] = InM.m[0][1] ;
m[1][1] = InM.m[1][1] ;
m[1][2] = InM.m[2][1] ;
m[1][3] = InM.m[3][1] ;

m[2][0] = InM.m[0][2] ;
m[2][1] = InM.m[1][2] ;
m[2][2] = InM.m[2][2] ;
m[2][3] = InM.m[3][2] ;

m[3][0] = InM.m[0][3] ;
m[3][1] = InM.m[1][3] ;
m[3][2] = InM.m[2][3] ;
m[3][3] = InM.m[3][3] ;
</div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ベクトルをＹ軸回転９０度する行列を転置した行列を使用してベクトルを回転します。<br>
            　　回転行列を転置した行列は逆回転( Ｙ軸回転－９０度 )する行列となります。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix2 ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｙ軸回転９０度する行列を Matrix2 に代入
    Matrix2 = <b><a href="dxfunc_3d_math.html#R11N18">MGetRotY</a></b>( DX_PI_F / 2.0f ) ;

    // Matrix2 を転置した行列を Matrix に代入
    Matrix = MTranspose( Matrix2 ) ;

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 200.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix2 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸９０度回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "転置行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N28">宣言</a></b></td><td><font color="#000088"><b>MATRIX MInverse( MATRIX InM ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>逆行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX InM ： 逆行列を求める行列<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>InM の逆行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InM で渡された行列の逆行列を戻り値として返す関数です。<br>
                    　行列は左から乗算する場合と右から乗算する場合で結果が変化するのですが、
                    逆行列は元の行列で左から乗算する場合と同じ結果が右から乗算した場合に出る行列です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　平行移動する行列とその逆行列を用意して、適当な値を持ったベクトルが<br>
            　平行移動行列→その逆行列　の順で <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b> すれば元の値に戻るかを試します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix2 ;
    VECTOR Vect1, Vect2, Vect3 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 平行移動する行列を Matrix2 に代入
    Matrix2 = <b><a href="dxfunc_3d_math.html#R11N16">MGetTranslate</a></b>( <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 200.0f, 100.0f, 80.0f ) ) ;

    // Matrix2 の逆行列を Matrix に代入
    Matrix = MInverse( Matrix2 ) ;

    // 適当な値を Vect1 に代入
    Vect1 = VGet( 200.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix2 を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="dxfunc_3d_math.html#R11N12">VTransform</a></b>( Vect1, Matrix2 ) ;

    // Vect2 を Matrix2 の逆行列である Matrix で変換したものを Vect3 に代入
    Vect3 = VTransform( Vect2, Matrix ) ;

    // Matrix2 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "平行移動行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "逆行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "平行移動後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // 変換後のベクトル値 Vect3 を画面に表示
    DrawString( 0, 384, "逆行列乗算後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 400, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect3.x, Vect3.y, Vect3.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>




        <tr><td><font size="3" color="#005500"><b>衝突検出系関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N1">宣言</a></b></td><td><font color="#000088"><b>float Segment_Segment_MinLength( VECTOR SegmentAPos1, VECTOR SegmentAPos2, VECTOR SegmentBPos1, VECTOR SegmentBPos2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つの線分の最近点間の距離を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR SegmentAPos1 ： 二線分の片方の始点<br>
            VECTOR SegmentAPos2 ： 二線分の片方の終点<br>
            VECTOR SegmentBPos1 ： 二線分のもう片方の始点<br>
            VECTOR SegmentBPos2 ： 二線分のもう片方の終点
            <br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>二線分の最近点間の距離</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された二つの線分が最も近づく点( 最近点 )同士の距離を得ます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　線分を二つ定義して、片方の線分の終点を左右動かし、二線分の最近点間の距離が 64 以下になった際に<br>
            　線分の色を赤色にします。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float xadd, length ;
    VECTOR LineA1, LineA2, LineB1, LineB2 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 二線分の座標をセット
    LineA1 = VGet( 0.0f, 0.0f, 0.0f ) ;
    LineA2 = VGet( 0.0f, 200.0f, 0.0f ) ;
    LineB1 = VGet( 320.0f, 480.0f, 0.0f ) ;
    LineB2 = VGet( 320.0f, 240.0f, 0.0f ) ;

    // 座標と加算数の初期化
    xadd = 8.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線分の片方の終点を移動
        LineA2.x += xadd ;
        if( LineA2.x &lt; 0.0f || LineA2.x &gt; 640.0f )
            xadd = -xadd ;

        // 二線分の最近点どうしの距離を求める
        length = Segment_Segment_MinLength( LineA1, LineA2, LineB1, LineB2 ) ;

        // 片方の線分の描画
        DrawLine( LineB1.x, LineB1.y, LineB2.x, LineB2.y, GetColor( 255,255,255 ) ) ;

        // もう一つの線分を距離が 64 以下だったら色を変えて描画
        if( length < 64.0f )
        {
            DrawLine( LineA1.x, LineA1.y, LineA2.x, LineA2.y, GetColor( 255,0,0 ) ) ;
        }
        else
        {
            DrawLine( LineA1.x, LineA1.y, LineA2.x, LineA2.y, GetColor( 0,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N2">宣言</a></b></td><td><font color="#000088"><b>float Segment_Triangle_MinLength( VECTOR SegmentPos1, VECTOR SegmentPos2, VECTOR TrianglePos1, VECTOR TrianglePos2, VECTOR TrianglePos3 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>線分と三角形の最近点間の距離を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR SegmentPos1 ： 線分の始点<br>
            VECTOR SegmentPos2 ： 線分の終点<br>
            VECTOR TrianglePos1 ： 三角形を形成する頂点１<br>
            VECTOR TrianglePos2 ： 三角形を形成する頂点２<br>
            VECTOR TrianglePos3 ： 三角形を形成する頂点３
            <br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>線分と三角形の最近点間の距離</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された線分と三角形が最も近づく点( 最近点 )同士の距離を得ます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　線分と三角形の座標を定義して、線分の終点を左右動かし、線分と三角形の最近点間の距離が 64 以下になった際に<br>
            　三角形の色を赤色にします。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float xadd, length ;
    VECTOR Line1, Line2, Tri1, Tri2, Tri3 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 線分の座標と三角形を形成する３頂点の座標をセット
    Line1 = VGet( 0.0f, 0.0f, 0.0f ) ;
    Line2 = VGet( 0.0f, 400.0f, 0.0f ) ;
    Tri1 = VGet( 320.0f, 200.0f, 0.0f ) ;
    Tri2 = VGet( 280.0f, 260.0f, 0.0f ) ;
    Tri3 = VGet( 360.0f, 260.0f, 0.0f ) ;

    // 座標と加算数の初期化
    xadd = 8.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線分の終点を移動
        Line2.x += xadd ;
        if( Line2.x &lt; 0.0f || Line2.x &gt; 640.0f )
            xadd = -xadd ;

        // 線分と三角形の最近点間の距離を求める
        length = Segment_Triangle_MinLength( Line1, Line2, Tri1, Tri2, Tri3 ) ;

        // 線分の描画
        DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 255,255,255 ) ) ;

        // 三角形との距離が 64 以下だったら色を変えて描画
        if( length < 64.0f )
        {
            DrawTriangle( Tri1.x, Tri1.y, Tri2.x, Tri2.y, Tri3.x, Tri3.y,  GetColor( 255,0,0 ), TRUE ) ;
        }
        else
        {
            DrawTriangle( Tri1.x, Tri1.y, Tri2.x, Tri2.y, Tri3.x, Tri3.y,  GetColor( 0,255,0 ), TRUE ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N3">宣言</a></b></td><td><font color="#000088"><b>float Segment_Point_MinLength( VECTOR SegmentPos1, VECTOR SegmentPos2, VECTOR PointPos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>線分と点の一番近い距離を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR SegmentPos1 ： 線分の始点<br>
            VECTOR SegmentPos2 ： 線分の終点<br>
            VECTOR PointPos ： 点の座標
            <br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>線分と点が最も近づく座標間の距離</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された線分と点が最も近づく座標間の距離を得ます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　線分と点の座標を定義して、点の座標を上下に動かし、線分と点の最近点間の距離が 64 以下になった際に<br>
            　線分の色を赤色にします。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float yadd, length ;
    VECTOR Line1, Line2, Point ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 線分の座標と点の座標をセット
    Line1 = VGet( 0.0f, 0.0f, 0.0f ) ;
    Line2 = VGet( 640.0f, 480.0f, 0.0f ) ;
    Point = VGet( 320.0f, 0.0f, 0.0f ) ;

    // 座標と加算数の初期化
    yadd = 4.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 点の座標を移動
        Point.y += yadd ;
        if( Point.y &lt; 0.0f || Point.y &gt; 480.0f )
            yadd = -yadd ;

        // 線分と点が最も近づく座標間の距離を求める
        length = Segment_Point_MinLength( Line1, Line2, Point ) ;

        // 点の描画
        DrawPixel( Point.x, Point.y, GetColor( 255,255,255 ) ) ;

        // 点との距離が 64 以下だったら色を変えて描画
        if( length < 64.0f )
        {
            DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 255,0,0 ) ) ;
        }
        else
        {
            DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 0,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N4">宣言</a></b></td><td><font color="#000088"><b>HITRESULT_LINE HitCheck_Line_Triangle( VECTOR LinePos1, VECTOR LinePos2, VECTOR TrianglePos1, VECTOR TrianglePos2, VECTOR TrianglePos3 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>三角形と線分の当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR LinePos1 ： 線分の始点<br>
            VECTOR LinePos2 ： 線分の終点<br>
            VECTOR TrianglePos1 ： 三角形を形成する頂点１<br>
            VECTOR TrianglePos2 ： 三角形を形成する頂点２<br>
            VECTOR TrianglePos3 ： 三角形を形成する頂点３
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>衝突情報構造体 HITRESULT_LINE</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された線分と三角形が接触しているかどうかを判定して、
                    その結果を衝突情報構造体 HITRESULT_LINE で返してきます。<br><br>

                    HITRESULT_LINE 構造体は非常に単純な構造体でメンバ変数は以下の二つだけです。<br>
                    <pre><div class="NormalFont">                    // 接触しているかどうか( 1:接触している  0:接触していない )
                    int        HitFlag ;

                    // 接触した座標( HitFlag が 1 の場合のみ有効 )
                    VECTOR    Position ;
                    </div></pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　線分と三角形の座標を定義して、線分の終点を上下に動かしながら線分と三角形の当たり判定を行い<br>
            　三角形と接触した場合は線分の始点と接触点とを結ぶ線を描画します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float yadd ;
    HITRESULT_LINE Result ;
    VECTOR Line1, Line2, Tri1, Tri2, Tri3 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 線分の座標と三角形の座標をセット
    Line1 = VGet( 0.0f, 240.0f, 0.0f ) ;
    Line2 = VGet( 640.0f, 240.0f, 0.0f ) ;
    Tri1 = VGet( 320.0f, 128.0f, 0.0f ) ;
    Tri2 = VGet( 320.0f, 240.0f, 200.0f ) ;
    Tri3 = VGet( 320.0f, 240.0f, -200.0f ) ;

    // 座標と加算数の初期化
    yadd = 4.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線の終点座標を移動
        Line2.y += yadd ;
        if( Line2.y &lt; 0.0f || Line2.y &gt; 480.0f )
            yadd = -yadd ;

        // 線分と点が最も近づく座標間の距離を求める
        Result = HitCheck_Line_Triangle( Line1, Line2, Tri1, Tri2, Tri3 ) ;

        // 三角形を真横から見たときにできる線を描画
        DrawLine( Tri1.x, Tri1.y, Tri2.x, Tri2.y, GetColor( 255,255,255 ) ) ;

        // 三角形と接触していたら始点と接触点を結ぶ線を
        // そうでない場合は始点と終点を結ぶ線を描画する
        if( Result.HitFlag == 1 )
        {
            DrawLine( Line1.x, Line1.y, Result.Position.x, Result.Position.y, GetColor( 255,0,0 ) ) ;
        }
        else
        {
            DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 0,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

<!--

        
        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N5">宣言</a></b></td><td><font color="#000088"><b>int HitCheck_Sphere_Sphere( VECTOR Sphere1CenterPos, float Sphere1R, VECTOR Sphere2CenterPos, float Sphere2R ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>球と球の当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Sphere1CenterPos ： 判定をする片方の球の中心座標<br>
            float Sphere1R ： 判定をする片方の球の半径<br>
            VECTOR Sphere2CenterPos ： 判定をするもう片方の球の中心座標<br>
            float Sphere2R ： 判定をするもう片方の球の半径<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：接触している　FALSE：接触していない</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された二つの球が接触しているかどうかを取得します。<br>
                    　接触している場合は TRUE が、接触していない場合は FALSE が返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　球を二つ定義して、片方の球を左右に動かしながら当たり判定を行い、接触していた場合は片方の球の色を変えて描画します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float xadd ;
    VECTOR SphereA, SphereB ;
    float SphereRA, SphereRB ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 円の座標と半径をセットする
    SphereA = VGet( 0.0f, 200.0f, 0.0f ) ;
    SphereRA = 64.0f ;
    SphereB = VGet( 320.0f, 250.0f, 0.0f ) ;
    SphereRB = 48.0f ;

    // 座標と加算数の初期化
    xadd = 4.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線の終点座標を移動
        SphereA.x += xadd ;
        if( SphereA.x &lt; 0.0f || SphereA.x &gt; 640.0f )
            xadd = -xadd ;

        // 片方の球を描画
        DrawCircle( SphereB.x, SphereB.y, SphereRB, GetColor( 255,255,255 ) ) ;

        // 二つの球が接触していたら描画色を変える
        if( HitCheck_Sphere_Sphere( SphereA, SphereRA, SphereB, SphereRB ) == TRUE )
        {
            DrawCircle( SphereA.x, SphereA.y, SphereRA, GetColor( 255,0,0 ) ) ;
        }
        else
        {
            DrawCircle( SphereA.x, SphereA.y, SphereRA, GetColor( 0,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N6">宣言</a></b></td><td><font color="#000088"><b>int HitCheck_Sphere_Triangle( VECTOR SphereCenterPos, float SphereR, VECTOR TrianglePos1, VECTOR TrianglePos2, VECTOR TrianglePos3 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>三角形と球の当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR SphereCenterPos ： 球の中心座標<br>
            float SphereR ： 球の半径<br>
            VECTOR TrianglePos1 ： 三角形を形成する頂点１<br>
            VECTOR TrianglePos2 ： 三角形を形成する頂点２<br>
            VECTOR TrianglePos3 ： 三角形を形成する頂点３
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：接触している　FALSE：接触していない</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された球と三角形が接触しているかどうかを取得します。<br>
                    　接触している場合は TRUE が、接触していない場合は FALSE が返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　球と三角形を定義して、球を左右に動かしながら当たり判定を行い、接触していた場合は球の色を変えて描画します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float xadd ;
    VECTOR Sphere, Tri1, Tri2, Tri3 ;
    float SphereR ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 円の座標と半径をセットする
    Sphere = VGet( 0.0f, 200.0f, 0.0f ) ;
    SphereR = 64.0f ;

    // 三角形の座標をセットする
    Tri1 = VGet( 320.0f, 180.0f, 0.0f ) ;
    Tri2 = VGet( 220.0f, 380.0f, 0.0f ) ;
    Tri3 = VGet( 420.0f, 380.0f, 0.0f ) ;

    // 座標と加算数の初期化
    xadd = 4.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線の終点座標を移動
        Sphere.x += xadd ;
        if( Sphere.x &lt; 0.0f || Sphere.x &gt; 640.0f )
            xadd = -xadd ;

        // 三角形を描画する
        DrawTriangle( Tri1.x, Tri1.y, Tri2.x, Tri2.y, Tri3.x, Tri3.y, GetColor( 255,255,255 ), TRUE ) ;

        // 球と三角形が接触していたら球の描画色を変える
        if( HitCheck_Sphere_Triangle( Sphere, SphereR, Tri1, Tri2, Tri3 ) == TRUE )
        {
            DrawCircle( Sphere.x, Sphere.y, SphereR, GetColor( 255,0,0 ), TRUE ) ;
        }
        else
        {
            DrawCircle( Sphere.x, Sphere.y, SphereR, GetColor( 0,255,0 ), TRUE ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>
    -->    
        













        
        <tr><td colspan="4">
            <hr>
            <font size="3"><b>
                <a href="../dxfunc.html">戻る</a>
            </b></font>
        </td></tr>
    </table>
    </div>
    </body>
</html>
