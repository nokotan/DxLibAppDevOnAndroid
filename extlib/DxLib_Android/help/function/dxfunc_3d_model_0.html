<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja-JP">
    <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <link rel="shortcut icon" href="../DxLib.ico">
    <link rel="stylesheet" href="../style.css" type="text/css">
    <title>ＤＸライブラリ置き場　３Ｄ関係関数リファレンスページ</title>
    </head>
    <body bgcolor="#ffffff" text="#000000" link="#0033CC" vlink="#800040">
    <div class="NormalFont">
    <table align="center" width="600" cellspacing="0" cellpadding="0" >
        <tr><td><font size="3" color="#005500"><b>モデルの読み込み・複製関係の関数</b><br><br></font></td></tr>

        <tr><td><table align="center" WIDTH=950 cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N1">宣言</a></b></td><td><font color="#000088"><b>int MV1LoadModel( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの読み込み<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            FileName ：　ロードする３Ｄモデルファイルのパス文字列のアドレス</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>－１　　　　：　エラー発生<br>
                    －１以外　：　モデルのハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄモデルファイルをメモリにロードします。<br>
                    ＤＸライブラリで３Ｄモデルを扱うときに必ず使用する関数です。<br>
                    　この関数が成功するとモデルハンドルというものが返ってきます。<br>
                    これはメモリに読み込んだ３Ｄモデルファイルの識別番号で int 型の数値です。<br>
                    　読み込んだモデルを扱う際にこの識別番号を使用することになりますので、
                    MV1LoadModel の戻り値は必ずなんらかの変数に格納しておく必要があります。<br><br>

                    例　　DxChara.x をロードして、戻り値であるモデルハンドルを<br>
                    　　int 型変数 MHandle に保存します<br><br>

<pre><div class="NormalFont">    int MHandle ;

    MHandle = MV1LoadModel( "DxChara.x" ) ;
</div></pre>
<br>
                    <font color="#660000"><b>読み込むことのできるモデルファイル形式は x, mqo, mv1, pmd( + vmd ), pmx( + vmd ) の４種類です。<br>
                    ( 但し、pmx は pmd 相当の機能だけを使用していた場合のみ正常に読み込める仮対応状態です )</b></font><br><br>

                    　尚、形状情報とアニメーション(アニメーション)情報はファイルの内容通りに読み込めますが、
                    マテリアル情報は各ファイル形式それぞれで異なる表現をしているものを無理矢理ＤＸライブラリのマテリアル表現で扱おうとするため、
                    大抵の場合モデリングソフト上とは異なった見た目になってしまいます。<br>
                    　なので、そのような場合はＤＸライブラリに合わせてモデルファイルのマテリアルを調整していただくか、
                    ＤＸライブラリの３Ｄツールでマテリアルを調整してからライブラリの専用形式である mv1 形式で保存して、そのファイルを使っていただくことになります。<br>

                    　また、モデルファイルで使用されているテクスチャはモデルファイルの中には含まれませんので、
                    モデルファイルで指定されているフォルダにテクスチャファイルを格納しておく必要があります。<br><br><br>


                    <font color="#660000"><b>MMD( MikuMikuDance )のモデルファイル( pmd or pmx )とモーションファイル( vmd )について。</b></font><br><br>

                    <b>＜対応度について＞</b><br><br>

                    　一応モーションの再生と取れに伴うＩＫ、物理演算に対応していますが、完全に本家 MikuMikuDance と同じというわけではありません。<br><br><br>

                    <b>＜読み込みについて＞</b><br><br>

                    　MikuMikuDance ではトゥーン用のテクスチャ( toon01.bmp 等 )はモデルファイル( pmd or pmx )が存在するテクスチャとは別のフォルダにあっても問題なく読み込むことが出来ますが、
                    ＤＸライブラリではトゥーン用のテクスチャもモデルファイル( pmd or pmx )と同じフォルダに格納しておく必要があります。( トゥーン用のデフォルトテクスチャは MikuMikuDance の Dataフォルダの中にあります ) <br><br>

                    　また、ＤＸライブラリでは MMD のモデルファイル形式( pmd or pmx )とモーションファイル形式( vmd )の読み込みに対応していますが、
                    モーションファイル( vmd )はモデルファイル( pmd or pmx )を読み込む際に一緒に読み込まれるようになっています。<br>
                    　ただ、MV1LoadModel にはモーションファイルのファイル名を渡す引数はありませんので、
                    次のようなルールでモデルファイル( pmd or pmx )用のモーションファイルを検索します。<br><br>

                    　１．モデルファイル名に３桁の番号がついたモーションファイルがあるか検索して、あったら読み込む<br>
                    　　　( 検索する番号は 000 から )<br><br>
                    　　　　　例えば、Miku.pmd ( 若しくは Miku.pmx ) というファイル名を FileName として渡した場合は、<br>
                    　　　　　最初に Miku000.vmd というモーションファイルが存在するか調べます。<br><br>

                    　２．検索する番号を000から順に１づつ増やしていき、存在しないファイル名になるまで読み込む<br><br>
                    　　　　　例えば、Miku000.vmd、Miku001.vmd、Miku002.vmd と数字の繋がった３つのモーションファイルが<br>
                    　　　　　あった場合は３つとも読み込まれます。<br>
                    　　　　　仮に Miku000.vmd, Miku001.vmd, Miku005.vmd のように、番号が途切れていたら、Miku000.vmd と<br>
                    　　　　　Miku001.vmd の二つだけ読み込まれ、Miku005.vmd は読み込まれません。<br><br>
                    
                    　尚、読み込み時にＩＫ計算を行いますので、xファイルやmv1ファイルに比べて読み込み時間が非常に長くなっています。<br><br><br>

                    <b>＜ループ再生するモーションについて＞</b><br><br>

                    　モーションの中には歩きや走りといったループさせて再生を行う用途のモーションがあると思います。<br><br>
                    　そのようなモーションの vmd ファイルは、＜読み込みについて＞の解説にあったファイル名の付け方にある３桁のモーションの番号の最後に半角の L をつけてください。<br><br>

                    例：Miku000.vmd ～ Miku002.vmd の３つのファイルがあり、Miku000.vmd と Miku002.vmd が<br>
                    　　ループ再生用途のモーションの場合<br><br>
                    
                    　Miku000.vmd　Miku001.vmd　Miku002.vmd<br><br>
                    
                    　　　　　　　　　↓<br><br>
                    
                    　Miku000L.vmd　Miku001.vmd　Miku002L.vmd<br><br><br>


                    　L を付けることで関数 <b><a href="dxfunc_3d_model_0.html#R1N4">MV1SetLoadModelUsePhysicsMode</a></b> の設定が「読み込み時に物理演算を行う」 DX_LOADMODEL_PHYSICS_LOADCALC
                    となっている場合( デフォルトの設定は DX_LOADMODEL_PHYSICS_LOADCALC です
                    )の物理演算がループ再生用途のモーション用にモーションの最初と最後のフレームが綺麗に繋がり自然なループ再生ができるように処理されます。<br>
                    　逆にループ用途のモーションではないのに L を付けてしまうとモーションの最後の部分が変になってしまうので注意してください。<br>
                    　また、L を付けても物理演算によって動く部分の動きが激しいときはやっぱりループ時に不自然な見え方になってしまいますので、
                    その際はリアルタイム物理演算の設定である DX_LOADMODEL_PHYSICS_REALTIME をお使いください。<br><br><br>


                    <b>＜モーションの再生について＞</b><br><br>

                    　モーションの再生は他の形式と同じように <b><a href="dxfunc_3d_model_1.html#R4N1">MV1AttachAnim</a></b> を使用します( AnimIndex は vmd についている番号を指定します )<br>
                    　フレーム構造の違う他のモデルのモーションを使用する場合は MV1AttachAnim の NameCheck を TRUE にしてください。<br><br>

                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで画面に表示します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>





        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N2">宣言</a></b></td><td><font color="#000088"><b>int MV1DuplicateModel( int SrcMHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のモデルと同じ基礎データを使用してモデルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int SrcMHandle ：　作成するモデルの基礎データを持つモデルのハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>－１　　　　：　エラー発生<br>
                    －１以外　：　モデルのハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　SrcMHandle が持つ基礎モデルデータを使用してモデルを作成します。<br>
                　用途としては、たとえばアクションゲームの雑魚敵など、
                同じ見た目で大量に登場するキャラクターが居る場合、
                その数だけ <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b> をしてしまうと同じ３Ｄモデルデータが幾つもメモリ上に存在することになり効率的ではありません( それに読み込み時間も掛かります )、
                なのでそんな場合にはキャラクターモデル一つに付き一回だけ MV1LoadModel で読み込んで、
                後は MV1LoadModel ではなく MV1DuplicateModel を使用してモデルハンドルを作成するようにすれば使用メモリ容量と読み込み時間を大幅に削減することができます。<br><br>

                　因みに画像ハンドルのように一つのモデルを使用して一体描画する度に位置や再生するアニメーションなどを切り替え、
                再度描画するといったことをすることでモデルハンドル一つで複数のキャラクターを表現することは可能ですが、
                ２Ｄの画像一枚と違い３Ｄモデルには色々な状態情報が含まれていますので、キャラクターの数だけモデルハンドルを作成したほうが速度的には有利です。<br><br>

                　なお、作成されるモデルハンドルには、SrcMHandle が示すモデルの座標値や回転値、
                アタッチしているアニメーションなど MV1LoadModel 以降に設定された情報は基本的に継承されません。
                ( 特別に継承される情報を変更する関数には、その関数の解説でその旨を記載しています )<br><br>
                <br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んだあと、同じデータを使用するモデルハンドルを３つ作成し、
            それぞれ座標をずらして描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle[ 4 ] ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle[ 0 ] = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 同じデータを使用するモデルハンドルを３つ作成する
    ModelHandle[ 1 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;
    ModelHandle[ 2 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;
    ModelHandle[ 3 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle[ 0 ], <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( -200.0f, -300.0f, 600.0f ) ) ;
    MV1SetPosition( ModelHandle[ 1 ], VGet(  150.0f, -300.0f, 600.0f ) ) ;
    MV1SetPosition( ModelHandle[ 2 ], VGet(  500.0f, -300.0f, 600.0f ) ) ;
    MV1SetPosition( ModelHandle[ 3 ], VGet(  850.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle[ 0 ] ) ;
    MV1DrawModel( ModelHandle[ 1 ] ) ;
    MV1DrawModel( ModelHandle[ 2 ] ) ;
    MV1DrawModel( ModelHandle[ 3 ] ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle[ 0 ] ) ;
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle[ 1 ] ) ;
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle[ 2 ] ) ;
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle[ 3 ] ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N3">宣言</a></b></td><td><font color="#000088"><b>int MV1DeleteModel( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　削除するモデルのハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle で渡されたモデルハンドルが示すモデルをメモリ上から削除します。<br>
                    　用途はメモリの節約と、モデルハンドルの節約です。( モデルハンドルは最大で 65536 個までしか作れません )<br>
                    　使用しなくなったモデルハンドルをこの関数で削除せずに次々と新たなモデルを読み込んだり <b><a href="dxfunc_3d_model_0.html#R1N2">MV1DuplicateModel</a></b>
                    で複製したりすると何れメモリが足りなくなるかモデルハンドルの限界数に達するかをしてしまいますので、
                    使用しなくなったモデルハンドルはこの関数で削除するようにしてください。<br><br>
                    　因みに <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b> を呼ぶと作成されていたモデルは自動的に削除されますので、
                    DxLib_End の前に作成していたモデル全てに対して MV1DeleteModel をする必要はありません。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　DxChara.x を <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b> で読み込んだ後、ひたすら MV1DuplicateModel でモデルを作成 → 描画 → MV1DeleteModel で削除を繰り返します。
            ( サンプルでは MV1DeleteModel を使うために無意味に作成と削除を繰り返していますが、移動して描画する度に削除と作成をしなければいけないわけではありません )<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, DupModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 何かボタンが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 読み込んだデータと同じデータを使用するモデルハンドルを作成する
        DupModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N2">MV1DuplicateModel</a></b>( ModelHandle ) ;

        // 画面に映るランダムな位置に３Ｄモデルを移動
        <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( DupModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( ( float )GetRand( 639 ), ( float )-GetRand( 300 ), GetRand( 300 ) + 300.0f ) ) ;

        // ３Ｄモデルの描画
        <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( DupModelHandle ) ;

        // ３Ｄモデルの削除
        <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( DupModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="900"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N4">宣言</a></b></td><td><font color="#000088"><b>int MV1SetLoadModelUsePhysicsMode( int PhysicsMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>読み込むモデルの物理演算モードを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int PhysicsMode ：　読み込むモデルに適用する物理演算モード<br>
            　　　　　DX_LOADMODEL_PHYSICS_LOADCALC　　ファイル読み込み時に物理演算を行う<br>
            　　　　　DX_LOADMODEL_PHYSICS_REALTIME　　　リアルタイム物理演算を行う<br>
            　　　　　DX_LOADMODEL_PHYSICS_DISABLE　　　　物理演算を使用しない<br>
            
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b> で読み込まれる３Ｄモデルに物理演算用の情報がある場合の処理を設定します。<br>
                    　物理演算用の情報がないモデルを読み込む場合はこの関数の設定は関係ありません。<br><br><br>


                    <b>DX_LOADMODEL_PHYSICS_LOADCALC</b>　　ファイル読み込み時に物理演算を行う（デフォルト）<br><br>

                    　　ファイル読み込み時にアニメーションを再生しながらの物理演算をシミュレーション(計算)して、<br>
                    　その結果をアニメーションに含めてしまいます。<br><br>

                    　　物理演算用情報を持ったモデル特有の処理をしなくても物理演算の恩恵を受けることができ、<br>
                    　処理負荷もアニメーションを再生しながら物理演算を行う DX_LOADMODEL_PHYSICS_REALTIME より<br>
                    　低くなりますが、シミュレーションは「その場に立ち止まった状態でアニメーションを再生した」ことを<br>
                    　前提として行われるため、見た目は DX_LOADMODEL_PHYSICS_REALTIME より不自然になります。<br><br><br>


                    <b>DX_LOADMODEL_PHYSICS_REALTIME</b>　　リアルタイム物理演算を行う<br><br>

                    　　DX_LOADMODEL_PHYSICS_LOADCALC と違いリアルタイムに物理演算を行います。<br>
                    　　リアルタイムに３Ｄモデルの挙動に即した物理演算が行われるため、<br>
                    　DX_LOADMODEL_PHYSICS_LOADCALC より自然な動きになります。<br><br>

                    　　ただ、代わりに <b><a href="dxfunc_3d_model_0.html#R3N4">MV1SetScale</a></b> によるスケーリングができないという点と、処理負荷が<br>
                    　DX_LOADMODEL_PHYSICS_LOADCALC より高いというデメリットがあります。<br><br>

                    　　リアルタイムの物理演算には通常の３Ｄモデルを扱う関数のほかに実際に物理演算を行う関数<br>
                    　MV1PhysicsCalculation と物理演算の状態をリセットする関数 MV1PhysicsResetState を使用します。<br><br>

                    　　尚、現時点では各モデル個別に物理演算を行うため、物理演算の情報を持つモデル同士の<br>
                    　衝突などには対応していません。<br><br><br>


                    <b>DX_LOADMODEL_PHYSICS_DISABLE</b>　　物理演算を使用しない<br><br>

                    　　物理演算用の情報が含まれる３Ｄモデルを読み込んだ際も物理演算用の情報が<br>
                    　ない３Ｄモデルとして扱います。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　リアルタイム物理演算モードで Test.pmd と Test000.vmd を <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b> で読み込んで<br>
            リアルタイム物理演算を行いながらアニメーション０をループ再生します。<br>
            　尚、Test.pmd と Test000.vmd はＤＸライブラリのパッケージには含まれていませんので、別途用意してください。<br>
            　PMDのキャラクターは大体同じ大きさですので、カメラの設定などはそのままで問題ないと思います。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AttachIndex ;
    float TotalTime, PlayTime ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 次に読み込むモデルの物理演算モードをリアルタイム物理演算にする
    MV1SetLoadModelUsePhysicsMode( DX_LOADMODEL_PHYSICS_REALTIME ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "Test.pmd" ) ;

    // 描画先を裏画面に変更
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // カメラに映る範囲( カメラからの距離の範囲 )を設定
    <b><a href="dxfunc_3d_camera.html#R12N1">SetCameraNearFar</a></b>( 10.0f, 1000.0f ) ;

    // カメラの位置と向きを設定
    <b><a href="dxfunc_3d_camera.html#R12N2">SetCameraPositionAndTarget_UpVecY</a></b>( VGet( 0.0f, 19.0f, -22.5f ), VGet( 0.0f, 10.0f, 0.0f ) ) ;

    // ３Ｄモデルの０番目のアニメーションをアタッチする
    AttachIndex = <b><a href="dxfunc_3d_model_1.html#R4N1">MV1AttachAnim</a></b>( ModelHandle, 0, -1, FALSE ) ;

    // アタッチしたアニメーションの総再生時間を取得する
    TotalTime = <b><a href="dxfunc_3d_model_1.html#R4N5">MV1GetAttachAnimTotalTime</a></b>( ModelHandle, AttachIndex ) ;

    // 物理演算の状態をリセット
    <b><a href="dxfunc_3d_model_0.html#R3N31">MV1PhysicsResetState</a></b>( ModelHandle ) ;

    // 再生時間の初期化
    PlayTime = 0.0f ;

    // 何かキーが押されるかウインドウが閉じられるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 再生時間を進める
        PlayTime += 0.5f ;

        // 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
        if( PlayTime >= TotalTime )
        {
            PlayTime = 0.0f ;

            // 再生時間をセットする
            <b><a href="dxfunc_3d_model_1.html#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, PlayTime ) ;

            // モーションがループしたときに位置が移動することがあるので物理演算の状態をリセット
            <b><a href="dxfunc_3d_model_0.html#R3N31">MV1PhysicsResetState</a></b>( ModelHandle ) ;
        }
        else
        {
            // 再生時間をセットする
            <b><a href="dxfunc_3d_model_1.html#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, PlayTime ) ;
        }

        // 物理演算を６０分の１秒経過したという設定で実行
        <b><a href="dxfunc_3d_model_0.html#R3N30">MV1PhysicsCalculation</a></b>( ModelHandle, 1000.0f / 60.0f ) ;

        // ３Ｄモデルの描画
        <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        ScreenFlip() ;
    }

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N5">宣言</a></b></td><td><font color="#000088"><b>int MV1SetLoadModelPhysicsWorldGravity( float Gravity ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>読み込むモデルの物理演算に適用する重力パラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float Gravity : Ｙ軸方向の重力の強さ( デフォルト値：-122.5f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b> で読み込まれる３Ｄモデルに物理演算用の情報があり、且つ物理演算を行う場合に適用する重力のＹ軸方向の強さを設定します。<br>
                    　デフォルト値は -122.5f で、値をより低くすれば( マイナス方向に値を大きくすれば )重力は強くなり、高くすれば( プラス方向に値を大きくすれば )重力は小さくなります。<br>
                    　例えば値をプラスにすると空に向かって重力が働くことになります。<br><br>

                    　この関数は MV1LoadModel を呼び出す前に使用します。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br><br><br><br>
        </td></tr>
            


        <tr><td><font size="3" color="#005500"><b>モデル描画関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N1">宣言</a></b></td><td><font color="#000088"><b>int MV1DrawModel( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　描画するモデルのハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを画面に描画します。<br>
                    　用途はモデルを画面に表示したい場合など・・・<br><br>
                    
                    　因みに、Ｚバッファを使用した現状の３Ｄレンダリングでは半透明の描画物は視点から最も離れているものから順に描画しないと正常な見た目になりませんので、
                    もし描画するモデルの中に半透明の部分が含まれている場合は視点からの距離を考慮した上で <b><a href="dxfunc_3d_model_0.html#R2N2">MV1DrawFrame</a></b> や <b><a href="dxfunc_3d_model_0.html#R2N3">MV1DrawMesh</a></b> で描画する必要があります。
                    ( ＤＸライブラリ自体にＺソートの機能はありません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b> のサンプルを参考にして下さい。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N2">宣言</a></b></td><td><font color="#000088"><b>int MV1DrawFrame( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの指定のフレームを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　描画するモデルのハンドル<br>
            int FrrameIndex ： 描画するフレームの番号</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデル中の FrameIndex 番目のフレームが持つメッシュ( ポリゴンの集合 )を画面に描画します。
                    ( ＤＸライブラリではモデル中の階層構造を「フレーム」と呼称します。また、フレームの構造は基本的にモデルファイルの通りになります )<br>
                    　フレームにメッシュが含まれていない場合は何も描画されません。<br><br>

                    　用途としては、モデルの一部分のみを描画したい場合や、モデル中に半透明の部分がありパーツ単位で前後関係を考慮して描画しなければならない場合などに使用します。<br><br>

                    　尚、モデル中に何個フレームがあるかは <b><a href="dxfunc_3d_model_2.html#R6N1">MV1GetFrameNum</a></b> 関数で、各フレームの名前等はそれぞれの座標などは『<a href="#G14"><b>フレーム関係</b></a>』の関数を使用することで取得することができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、２番目のフレームのみ画面に描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの２番目のフレームを描画
    <b><a href="dxfunc_3d_model_0.html#R2N2">MV1DrawFrame</a></b>( ModelHandle, 2 ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N3">宣言</a></b></td><td><font color="#000088"><b>int MV1DrawMesh( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの指定のメッシュを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　描画するモデルのハンドル<br>
            int MeshIndex ： 描画するメッシュの番号</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデル中の MeshIndex 番目のメッシュを描画します。
                    ( ＤＸライブラリではポリゴンの集合のことを「メッシュ」と呼称します )<br>
                    　モデルの一部分を描画したい場合は <b><a href="dxfunc_3d_model_0.html#R2N2">MV1DrawFrame</a></b> 関数を使用しますが、この関数は「フレーム」より細かい単位の「メッシュ」で描画を行います。<br>
                    　用途は MV1DrawFrame と同じで、フレームより細かい単位で描画したい場合や、フレーム中の一部分のみ半透明のものがあり、前後関係を考慮した上で個別に描画したい場合などに使用します。<br><br>

                    　構造的には、メッシュは必ずどこかのフレームに所属していて、フレームが持つメッシュを全て描画するのが MV1DrawFrame 関数、その内の一つだけを描画するのが MV1DrawMesh 関数となります。<br><br>
                    　フレームに含まれるメッシュの数ははフレームに含まれるポリゴンに使用されているマテリアル( 材質 )の数と比例します。つまり、マテリアル毎にメッシュが分かれているというわけです。<br>
                    　なので、例えば「布」「金属」「革」といった３つのマテリアルを使用したフレームが存在した場合は、そのフレームが持つメッシュの数は３つになります。<br><br>

                    　モデル中に何個メッシュがあるかは <b><a href="dxfunc_3d_model_3.html#R7N1">MV1GetMeshNum</a></b> 関数で、各フレームに含まれるメッシュの数は <b><a href="dxfunc_3d_model_2.html#R6N27">MV1GetFrameMeshNum</a></b> 関数で、
                    各フレームに含まれるメッシュの識別番号は <b><a href="dxfunc_3d_model_2.html#R6N28">MV1GetFrameMesh</a></b> で取得することができます。<br>
                    　また、各メッシュの情報を取得したり設定したりする関数は『<a href="#G15"><b>メッシュ関係</b></a>』に一覧があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、０番目のメッシュを画面に描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの０番目のメッシュを描画
    <b><a href="dxfunc_3d_model_0.html#R2N3">MV1DrawMesh</a></b>( ModelHandle, 0 ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N4">宣言</a></b></td><td><font color="#000088"><b>int MV1DrawTriangleList( int MHandle, int TriangleListIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの指定のトライアングルリストを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　描画するモデルのハンドル<br>
            int TriangleListIndex ： 描画するトライアングルリストの番号</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデル中の TriangleListIndex 番目のトライアングルリストを描画します。<br>
                    　「メッシュ」は一つ又は複数の「トライアングルリスト」から構成されています。<br>
                    　普通は一つのメッシュに含まれるトライアングルリスト( ３角形ポリゴンの塊 )は一つですが、
                    一度に処理できるポリゴンや頂点の数が限界を超えた場合や、種類の違うタイプの頂点が一つのメッシュに混在する場合などは複数のトライアングルリストが一つのメッシュ内に含まれることがあります。<br>
                    　普段３Ｄモデルを描画する際にメッシュ以上に細かい単位で描画することは無いのですが、
                    オリジナルのシェーダープログラムを使用してモデル描画を行う場合は頂点のタイプによって使用するシェーダープログラムを変更しなければならないので、
                    オリジナルのシェーダーを使用して、且つ複数種類の頂点が混合しているようなメッシュを描画する場合のみこの関数を使用します。
                    　つまり滅多に使用する機会はありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません
            <br><br><br><br><br>
        </td></tr>

        <tr><td><font size="3" color="#005500"><b>モデル描画設定関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N1">宣言</a></b></td><td><font color="#000088"><b>int MV1SetUseOrigShader( int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの描画にオリジナルシェーダープログラムを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int UseFlag ： オリジナルのシェーダーを使用するかどうかのフラグ<br>
            　　　　　　　　　　　( TRUE：使用する　　FALSE：使用しない )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b> や <b><a href="dxfunc_3d_model_0.html#R2N2">MV1DrawFrame</a></b> などのモデル描画関数を使用してモデルを描画する場合に関数
                    <b><a href="dxfunc_3d_shader.html#R17N30">SetUseVertexShader</a></b>, <b><a href="dxfunc_3d_shader.html#R17N31">SetUsePixelShader</a></b> で設定したシェーダーを使用するかどうかをこの関数で設定します。<br><br>

                    　TRUE を渡してこの関数を呼び出した場合は、SetUseVertexShader と SetUsePixelShader で設定したシェーダーで描画が行われます。<br>
                    　その際の頂点シェーダーに渡される頂点データの形式については <b><a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a></b> の解説を参照してください。<br><br>

                    　また、メッシュに含まれるトライアングルリストがどの頂点データ形式が頂点シェーダーに渡されるかは、以下のプログラムによって判断することができます。<br><br>
<hr>
<pre><div class="NormalFont">int MeshNo = 0 ;   // 任意のメッシュ
int TriangleListIndex  ;
int TriangleListDataType ;

// メッシュに含まれるトライアングルリスト番号 0 のモデル全体でのトライアングルリスト番号を取得
TriangleListIndex = MV1GetMeshTList( MeshNo, 0 ) ;

// トライアングルリストの頂点データタイプを取得
TriangleListDataType = MV1GetTriangleListVertexType( TriangleListIndex ) ;
</div></pre>
<hr>
<br>
                    　上記プログラムの結果、TriangleListDataType に代入された値が<br><br>

                    <b>DX_MV1_VERTEX_TYPE_1FRAME</b> の場合は<br>
                    　LoadVeretxShader の解説にある「剛体メッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_4FRAME</b> の場合は<br>
                    　「１頂点へ影響を与えるフレームの数が１～４個のスキニングメッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_8FRAME</b> の場合は<br>
                    　「１頂点へ影響を与えるフレームの数が１～８個のスキニングメッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_NMAP_1FRAME</b> の場合は<br>
                    　「法線マップ付き剛体メッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_NMAP_4FRAME</b> の場合は<br>
                    　「１頂点へ影響を与えるフレームの数が１～４個の法線マップ付きスキニングメッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_NMAP_8FRAME</b> の場合は<br>
                    　「１頂点へ影響を与えるフレームの数が１～８個の法線マップ付きスキニングメッシュの場合」のデータ形式、<br><br>

                    　となります。<br><br>

                    　また、<b><a href="dxfunc_3d_shader.html#R17N29">SetUseTextureToShader</a></b> で特にテクスチャが設定されていない場合は３Ｄモデル描画時はデフォルトで<br><br>

                    StageIndex 0 にディフューズマップテクスチャが、<br>
                    StageIndex 1 に法線マップテクスチャが<br>
                    StageIndex 2 にスペキュラマップテクスチャが、<br>
                    StageIndex 3 にトゥーンレンダリング用のディフューズグラデーションテクスチャが、<br>
                    StageIndex 4 にトゥーンレンダリング用のスペキュラグラデーションテクスチャが、<br>
                    StageIndex 5 にトゥーンレンダリング用の数値飽和処理用のボリュームテクスチャが、<br>
                    StageIndex 6 にトゥーンレンダリング用のスフィアマップテクスチャが、<br><br>

                    　それぞれ存在する場合は設定されます。<br><br><br>


                    　尚、この関数で TRUE を設定したとしてもプログラムを実行するＰＣがプログラマブルシェーダーに対応していない場合はシェーダープログラムを使用しない描画になりますので注意してください。
                    ( プログラマブルシェーダーが使用できるかどうかは <b><a href="dxfunc_3d_shader.html#R17N1">GetValidShaderVersion</a></b> で確認することができます )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　オリジナルシェーダーを利用した３Ｄモデルの描画サンプルや、デフォルトのシェーダー処理についての情報などは<br>
            　<a href="../program/dxprogram_3D.html"><b>こちら</b></a>をご参照ください。
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N2">宣言</a></b></td><td><font color="#000088"><b>int MV1SetSemiTransDrawMode( int DrawMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの半透明要素がある部分についての描画モードを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int DrawMode ：　モデルの半透明要素がある部分についての描画モード<br>
            　　　　　DX_SEMITRANSDRAWMODE_ALWAYS　　　　　： 半透明かどうか関係なく描画する( デフォルト )<br>
            　　　　　DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY　　　： 半透明の部分のみ描画する<br>
            　　　　　DX_SEMITRANSDRAWMODE_NOT_SEMITRANS_ONLY ： 半透明ではない部分のみ描画する<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　モデルの半透明要素がある部分についての描画モードを設定します。<br>
		    設定できるモードは以下の３つです。<br><br><br>

                    　DX_SEMITRANSDRAWMODE_ALWAYS<br><br>

                    　　半透明の要素があるかどうか関係なく必ず描画します。<br>
	            　　デフォルトではこのモードになっています。<br><br><br>


                    　DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY<br><br>

	            　　半透明の要素がある部分のみ描画します。少しでも半透明の要素がある場合は描画され、<br>
		    　　半透明の要素が少しも無い場合は描画されません。<br><br><br>


                    　DX_SEMITRANSDRAWMODE_NOT_SEMITRANS_ONLY<br><br>
	    
	            　　DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY とは逆に半透明の要素が少しでもある部分は<br>
	            　　描画されないモードです。<br><br><br><br>

		    　この関数を呼んだ後の MV1DrawModel、MV1DrawFrame、MV1DrawMesh、MV1DrawTriangleList の呼び出しに影響を与えます。<br><br>

		    　この関数の用途ですが、主に「描画する全ての３Ｄモデルの半透明要素が無い部分のみ」を先に描画して、
		    その後に「描画する全ての３Ｄモデルの半透明要素がある部分のみ」を描画するために使用します。<br><br>

		    　何故先に「半透明要素が無い部分のみ」を描画する必要があるのかと言いますと、
		    それは３Ｄ描画の前後関係解決に使用されるＺバッファと半透明描画の相性の悪さにあります。<br><br>

		    　Ｚバッファは「３Ｄ描画を行った際の各ピクセルの奥行き」を記録しておき、
		    後から同じピクセルに対して３Ｄ描画された際に「前回の３Ｄ描画を行った際に記録しておいた奥行き」より
		    「後から行った３Ｄ描画の奥行き」の方が大きい( 奥にある )場合は描画せず、
		    小さい( 手前にある )場合は描画するという処理をしてくれるもので、３Ｄ描画にはとても便利(
		    ２Ｄ描画のように手前に表示したいものを後から描画しないといけない、といった前後関係を気にする必要が無くなる為 )
		    な機能なのですが、この機能は半透明描画とはとても相性が悪いのです。<br><br>

		    　例えば「半透明のもの」は本来「半透明のものより奥のもの」が透けて見えますが、
		    このＺバッファの機能を使用しながら「半透明のもの」を「半透明のものより奥にあるもの」より先に描画してしまうと、
		    「半透明のものより奥にあるもの」を後から描画してもＺバッファに「既にもっと手前に描画されたものがあるから描画しません」
		    と、本来なら「半透明のもの」が透けてその奥に見える筈の「半透明のものより奥にあるもの」が描画されないという事態を引き起こしてしまいます。<br><br>

		    　この問題を回避するには、以下の様な手順で描画を行う必要があります。<br><br><br>
		    
		    １．半透明要素が無いものを全て描画する<br><br>
		    
		    ２．半透明要素があるものを、奥のものから順番に描画する<br><br><br>

		    　まずＺバッファと相性の良い「半透明要素が無いもの」を先に全て描画してしまい
		    『半透明のものの奥にあるはずのものが表示されていない』という事態を回避します。<br><br>

		    　その次に、Ｚバッファと相性の悪い「半透明要素があるもの」を奥のものから順番に描画します。<br>
		    ( 前述の通り半透明のものはＺバッファを頼りにした前後関係の解決は望めないため )<br><br>

		    　これで正常な描画結果を得ることができます。<br><br>

		    　尚、「半透明要素があるもの」を奥のものから順番に描画しなかった場合に不都合が発生するのは<br><br>

		    『「半透明要素があるもの」同士が画面内で重なり、<br>
		    　且つ手前にある「半透明要素があるもの」が先に描画された場合』<br><br>
		    
		    なので、
		    「半透明要素があるもの」が少なく、滅多に「半透明要素があるもの」同士が画面内で重なることが無い、
		    重なっても一瞬で気付かない程度、という場合は「半透明要素があるもの」についても前後関係を無視して描画してしまうのもありです。
		    ( 奥のものから順番に描画するためのソート処理は負荷が高いことも多いので )<br><br>

		    　改めて MV1SetSemiTransDrawMode の用途ですが、上記の「半透明要素が無いものを先に全て描画する」
		    「半透明要素があるものを後から全て描画する」を実現するために使用します。<br><br>
		    
		    　「半透明要素が無いものを先に全て描画する」を行う場合は DrawMode に
		    DX_SEMITRANSDRAWMODE_NOT_SEMITRANS_ONLY を渡して MV1SetSemiTransDrawMode を呼び出した後に全ての３Ｄモデルを MV1DrawModel で描画、<br><br>

		    　「半透明要素があるものを後から全て描画する」を行う場合は DrawMode に
		    　DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY を渡して MV1SetSemiTransDrawMode を呼び出した後に全ての３Ｄモデルを MV1DrawModel で描画します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　画面左側に通常の設定で半透明の３Ｄモデルと不透明の３Ｄモデルを描画、画面右側に解説にある<br>
	    　手順で同様に半透明の３Ｄモデルと不透明の３Ｄモデルを描画して結果を比較するサンプルです。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

#define CHARA_SPACE			(300.0f)
#define CHARA_X				(250.0f)

int CharaModelHandle ;

// キャラクターモデルの描画
void Chara_Draw( float x )
{
	int i ;

	// 手前から２体描画
	for( i = 0 ; i < 2 ; i ++ )
	{
		// 先頭のキャラを半透明にする
		MV1SetOpacityRate( CharaModelHandle, i == 0 ? 0.5f : 1.0f ) ;

		// 座標を設定
		MV1SetPosition( CharaModelHandle, VGet( x, 0.0f, i * CHARA_SPACE ) ) ;

		// モデルを描画
		MV1DrawModel( CharaModelHandle ) ;
	}
}

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() < 0 )
	{
		// エラーが発生したら終了
		return -1 ;
	}

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キャラクターモデルの読み込み
	CharaModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 400.0f, -700.0f ), VGet( 0.0f, 400.0f, 0.0f ) );

	// 描画する奥行き方向の範囲を設定
	SetCameraNearFar( 20.0f, 5000.0f );

	// 背景の色を灰色に変更
	SetBackgroundColor( 128,128,128 ) ;

	// 画面をクリア
	ClearDrawScreen() ;

	// メインループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 通常の設定で画面左側にキャラクターを描画
		MV1SetSemiTransDrawMode( DX_SEMITRANSDRAWMODE_ALWAYS ) ;
		Chara_Draw( -CHARA_X ) ;

		// 画面右側に先に半透明要素の無い３Ｄモデルのみ描画する設定でキャラクターを描画した後、
		// 半透明要素のある３Ｄモデルのみ描画する設定でキャラクターを描画する
		MV1SetSemiTransDrawMode( DX_SEMITRANSDRAWMODE_NOT_SEMITRANS_ONLY ) ;
		Chara_Draw( CHARA_X ) ;

		MV1SetSemiTransDrawMode( DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY ) ;
		Chara_Draw( CHARA_X ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// モデルハンドルの削除
	<b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( CharaModelHandle ) ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
<br><br>
        </td></tr>



        <tr><td><font size="3" color="#005500"><b>モデル基本制御関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N2">宣言</a></b></td><td><font color="#000088"><b>int MV1SetPosition( int MHandle, VECTOR Position ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの座標をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            VECTOR Position ： モデルにセットする座標
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの座標をセットします。<br><br>

                    　グラフィックハンドルでは座標やスケールと言ったものは画像自体には保持せず <b><a href="dxfunc_graph1.html#R3N7">DrawGraph</a></b> や <b><a href="dxfunc_graph1.html#R3N9">DrawExtendGraph</a></b> などの描画関数を呼ぶ際に直接指定していましたが、
                    ３Ｄモデルは設定すべき情報が多く、項目の数に合わせて描画関数のバリエーションを増やしたらとんでもないことになってしまうので、
                    この <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b> などの関数で描画を行う前に予め座標や回転値を設定するようになっています。<br><br>

                    　座標は VECTOR 型の構造体( float x, y, z をメンバ変数に持つ構造体 )が引数になっていて、
                    いちいち VECTOR 構造体を定義してメンバ変数に座標値を代入して、という手順を踏まなければならなくて面倒ですが、
                    x, y, z の値を引数で渡すと VECTOR 構造体を戻り値として返してくれる <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b> 関数を使用すれば面倒ではなくなります。<br><br>

<pre><div class="NormalFont">    // 普通に引数を渡そうとすると面倒・・・
    VECTOR Position ;

    Position.x = 0.0f ;
    Position.y = 400.0f ;
    Position.z = -600.0f ;
    MV1SetPosition( MHandle, Position ) ;

    -----------------------------------------------

    // VGet 関数を使用すれば簡単
    MV1SetPosition( MHandle, VGet( 0.0f, 400.0f, -600.0f ) ) ;
</div></pre>
                    <br><br>

                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b> のサンプルを参考にして下さい。
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N3">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetPosition( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの座標を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルの座標<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの座標を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b> でセットした座標を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N4">宣言</a></b></td><td><font color="#000088"><b>int MV1SetScale( int MHandle, VECTOR Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの拡大値をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            VECTOR Scale 　： 拡大値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの拡大値を設定します。<br>
                    　Scale で渡す VECTOR 構造体の各メンバ変数( x, y, z )の値を 2.0f にするとモデルが２倍の大きさに、逆に 0.5f 等にすると半分の大きさになります。
                    尚、マイナスの値を渡すと見た目が破綻します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、x軸方向に２倍に拡大して描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのスケールをx軸方向に２倍にする
    <b><a href="dxfunc_3d_model_0.html#R3N4">MV1SetScale</a></b>( ModelHandle, VGet( 2.0f, 1.0f, 1.0f ) ) ;

    // ３Ｄモデルを描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N5">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの拡大値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルの拡大値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの拡大値を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N4">MV1SetScale </a></b>でセットした拡大値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N6">宣言</a></b></td><td><font color="#000088"><b>int MV1SetRotationXYZ( int MHandle, VECTOR Rotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの回転値をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            VECTOR Rotate　　： 回転値( 単位はラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの回転値を設定します。<br>
                    　Rotate で渡す VECTOR 構造体の各メンバ変数( x, y, z )の値はそれぞれ x軸回転値、y軸回転値、z軸回転値を代入しておきます。
                    ( 回転値の単位はラジアンですので、度数単位の値を代入する場合は　度 * DX_PI_F / 180.0f　の計算をしてください )<br><br>

                    　キャラクターモデルの向いている方向を設定する場合は y軸回転を使用します。<br><br>

                    　尚、回転の順番は x軸回転 → y軸回転 → z軸回転 です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、y軸を回転軸として９０度回転して描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３ＤモデルのY軸の回転値を９０度にセットする
    <b><a href="dxfunc_3d_model_0.html#R3N6">MV1SetRotationXYZ</a></b>( ModelHandle, VGet( 0.0f, 90.0f * DX_PI_F / 180.0f, 0.0f ) ) ;

    // ３Ｄモデルを描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N7">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetRotationXYZ( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの回転値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルの回転値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの回転値を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N6">MV1SetRotationXYZ</a></b> でセットした回転値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N8">宣言</a></b></td><td><font color="#000088"><b>int MV1SetRotationZYAxis( int MHandle, VECTOR ZAxis, VECTOR YAxis, float ZTwist ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのＺ軸とＹ軸の方向をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            VECTOR ZAxis ： Ｚ軸の方向<br>
            VECTOR YAxis ： Ｙ軸の方向<br>
            float　　　ZTwist ： ZAxis を回転軸とした回転値( 単位はラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの回転値をＺ軸の方向、Ｙ軸の方向と、ZAxis で指定した方向を軸とした回転値で設定します。
                    ( ZAxis, YAxis は正規化されている必要はありません )<br><br>

                    　この関数は何かのモデルをある方向に向けたい場合などに使用します。( 砲台を敵の方向に向けるなど )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、モデルのz軸の方向を画面左上の方に向けて描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, 0.0f, 600.0f ) ) ;

    // ３ＤモデルのＺ軸を画面左上方向に向ける
    // ( DxChara.x はＺ軸のマイナス方向に向いているので右下方向に傾きます )
    MV1SetRotationZYAxis( ModelHandle, VGet( -0.5f, 0.5f, 0.0f ), VGet( 0.5f, 0.5f, 0.0f ), 0.0f ) ;

    // ３Ｄモデルを描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N11">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMatrix( int MHandle, MATRIX Matrix ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの座標変換用行列をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            MATRIX Matrix ： 座標変換用行列
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの座標変換用行列をセットします。<br><br>

                    　この関数は <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b> 関数や <b><a href="dxfunc_3d_model_0.html#R3N4">MV1SetScale</a></b> や <b><a href="dxfunc_3d_model_0.html#R3N6">MV1SetRotationXYZ</a></b>関数などの代わりに行列を使用してローカル → ワールド座標変換を行いたい場合に使用します。<br><br>
                    　この関数に単位行列以外の行列を渡すと、以後 MV1SetPosition や MV1SetScale 等の関数の設定は無視され、
                    MV1SetMatrix 関数で設定した行列のみを使用してローカル → ワールド座標変換が行われるようになります。
                    ( 解除する場合は MV1SetMatrix 関数に単位行列を渡します )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、拡大率を２倍にしてから座標をカメラの写る位置に移動するということを行列を使用して設定した後に描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ２倍に拡大した後画面に映る位置に３Ｄモデルを移動する行列のセット
    MV1SetMatrix( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N25">MMult</a></b>( <b><a href="dxfunc_3d_math.html#R11N15">MGetScale</a></b>( <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 2.0f, 2.0f, 2.0f ) ), <b><a href="dxfunc_3d_math.html#R11N16">MGetTranslate</a></b>( VGet( 320.0f, -600.0f, 600.0f ) ) ) ) ;

    // ３Ｄモデルを描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N12">宣言</a></b></td><td><font color="#000088"><b>MATRIX MV1GetMatrix( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの座標変換用行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルの座標変換用行列<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの座標変換用行列を取得します。<br>
                    　事前に <b><a href="dxfunc_3d_model_0.html#R3N11">MV1SetMatrix</a></b> で行列を設定していた場合はその値が、
                    設定していなかった場合は <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b> や <b><a href="dxfunc_3d_model_0.html#R3N4">MV1SetScale</a></b> 等の関数で設定した値の結果( 行列 )が返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで複製した後、最初に読み込んだモデルハンドルの方に座標位置変更や拡大率の設定を行い、
            その結果の行列を複製したモデルに設定して描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, SubModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ModelHandle と同じモデルを使用するモデルの作成
    SubModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N2">MV1DuplicateModel</a></b>( ModelHandle ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, 0.0f, 600.0f ) ) ;

    // ３Ｄモデルの拡大率を０．５倍にする
    <b><a href="dxfunc_3d_model_0.html#R3N4">MV1SetScale</a></b>( ModelHandle, VGet( 0.5f, 0.5f, 0.5f ) ) ;

    // ModelHandle に設定した座標変換パラメータの結果の行列を SubModelHandle の座標変換行列として設定する
    MV1SetMatrix( SubModelHandle, MV1GetMatrix( ModelHandle ) ) ;

    // SubModelHandle の方の３Ｄモデルを描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( SubModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( SubModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N13">宣言</a></b></td><td><font color="#000088"><b>int MV1SetVisible( int MHandle, int VisibleFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画するかどうかを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int VisibleFlag ： 描画するかどうか( TRUE：表示する  FALSE：表示しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画するかどうかを設定します。<br>
                    　この関数で描画しない設定にすると、以後 <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b> 等の描画関数を使用しても描画されなくなります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を <b><a href="dxfunc_other.html#R7N1">GetNowCount</a></b> が返す値が奇数秒の時だけ描画する。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // 何かキーが押されるかウインドウが閉じられるまでループする
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリアする
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルをカウンタが奇数秒の時は描画して、偶数表のときは描画しないようにする
        if( <b><a href="dxfunc_other.html#R7N1">GetNowCount</a></b>() % 2000 < 1000 )
        {
            MV1SetVisible( ModelHandle, TRUE ) ;
        }
        else
        {
            MV1SetVisible( ModelHandle, FALSE ) ;
        }

        // ３Ｄモデルの描画
        <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N14">宣言</a></b></td><td><font color="#000088"><b>int MV1GetVisible( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画するかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　TRUE：モデルを描画する  FALSE：モデルを描画しない</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画するかどうかの設定値を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N13">MV1SetVisible</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N15">宣言</a></b></td><td><font color="#000088"><b>int MV1SetDifColorScale( int MHandle, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのディフューズカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　　MHandle ： モデルのハンドル<br>
            COLOR_F Scale　　： カラースケール値( 0.0f ～ 1.0f = 0% ～ 100% )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルのマテリアルのディフューズカラー( 拡散光色 )のスケール値を設定します。<br><br>
                    　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、
                    モデル描画時にマテリアル中のディフューズカラーの緑成分とα成分以外が 0.0f として描画されます。<br><br>

                    　用途としては選択されているモデルの表現や、簡単な色違い表現などがあります。<br><br>

                    　因みに引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="dxfunc_3d_draw.html#R14N14">GetColorF</a></b> を使用すると便利です。<br><br>
<pre><div class="NormalFont">// ディフューズカラーの赤成分を５０％にする
MV1SetDifColorScale( ModelHandle, GetColorF( 0.5f, 1.0f, 1.0f, 1.0f ) ) ;
</div></pre>

                    <br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x のディフューズカラーの緑成分と青成分を０％にして描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのディフューズカラーの緑成分と青成分を０％にする
    <b><a href="dxfunc_3d_model_0.html#R3N15">MV1SetDifColorScale</a></b>( ModelHandle, <b><a href="dxfunc_3d_draw.html#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N16">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetDifColorScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのディフューズカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ディフューズカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのディフューズカラーに適用するスケール値を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N15">MV1SetDifColorScale</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N17">宣言</a></b></td><td><font color="#000088"><b>int MV1SetSpcColorScale( int MHandle, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのスペキュラカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　　MHandle ： モデルのハンドル<br>
            COLOR_F Scale　　： カラースケール値( 0.0f ～ 1.0f = 0% ～ 100% )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルのマテリアルのスペキュラカラー( 反射光色 )のスケール値を設定します。<br><br>
                    　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、
                    モデル描画時にマテリアル中のスペキュラカラーの緑成分とα成分以外が 0.0f として描画されます。<br><br>

                    　用途としては光沢があるオブジェクトの光沢の色を変化させたり、光沢を無くしたりすることができます。<br><br>

                    　因みに、モデルのマテリアルに設定されているスペキュラカラー値に対するスケールなので、
                    設定対象のモデルのマテリアルに元々スペキュラカラー成分が無い場合( スペキュラカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x のスペキュラカラーの緑成分と青成分を０％にして描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのスペキュラカラーの緑成分と青成分を０％にする
    MV1SetSpcColorScale( ModelHandle, <b><a href="dxfunc_3d_draw.html#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N18">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetSpcColorScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのスペキュラカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スペキュラカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのスペキュラカラーに適用するスケール値を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N17">MV1SetSpcColorScale</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N19">宣言</a></b></td><td><font color="#000088"><b>int MV1SetEmiColorScale( int MHandle, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのエミッシブカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　　MHandle ： モデルのハンドル<br>
            COLOR_F Scale　　： カラースケール値( 0.0f ～ 1.0f = 0% ～ 100% )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルのマテリアルのエミッシブカラー( 自己発光色 )のスケール値を設定します。<br><br>
                    　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、
                    モデル描画時にマテリアル中のエミッシブカラーの緑成分とα成分以外が 0.0f として描画されます。<br><br>

                    　用途としては自己発光しているオブジェクトの自己発光を止めたり、自己発光の色を変化させたりすることができます。<br><br>

                    　因みに、モデルのマテリアルに設定されているエミッシブカラー値に対するスケールなので、
                    設定対象のモデルのマテリアルに元々エミッシブカラー成分が無い場合( エミッシブカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x のエミッシブカラーの緑成分と青成分を０％にして描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのエミッシブカラーの緑成分と青成分を０％にする
    MV1SetEmiColorScale( ModelHandle, <b><a href="dxfunc_3d_draw.html#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N20">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetEmiColorScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのエミッシブカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>エミッシブカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのエミッシブカラーに適用するスケール値を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N19">MV1SetEmiColorScale</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N21">宣言</a></b></td><td><font color="#000088"><b>int MV1SetAmbColorScale( int MHandle, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのアンビエントカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　　MHandle ： モデルのハンドル<br>
            COLOR_F Scale　　： カラースケール値( 0.0f ～ 1.0f = 0% ～ 100% )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルのマテリアルのアンビエントカラー( 環境光色 )のスケール値を設定します。<br><br>
                    　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、
                    モデル描画時にマテリアル中のアンビエントカラーの緑成分とα成分以外が 0.0f として描画されます。<br><br>

                    　用途はあまり思いつきませんが、環境光の影響を受けたり受けなかったりを変化させることができます。<br><br>

                    　因みに、モデルのマテリアルに設定されているアンビエントカラー値に対するスケールなので、
                    設定対象のモデルのマテリアルに元々アンビエントカラー成分が無い場合( アンビエントカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x のアンビエントカラーの緑成分と青成分を０％にして描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのアンビエントカラーの緑成分と青成分を０％にする
    MV1SetAmbColorScale( ModelHandle, <b><a href="dxfunc_3d_draw.html#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N22">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetAmbColorScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのアンビエントカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アンビエントカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのアンビエントカラーに適用するスケール値を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N21">MV1SetAmbColorScale</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N23">宣言</a></b></td><td><font color="#000088"><b>int MV1GetSemiTransState( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルに半透明要素があるかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：半透明要素がある　FALSE：半透明要素は無い</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに半透明の要素があるかどうかを取得します。<br><br>

                    　例えば、モデル中のどれかのマテリアルのテクスチャに半透明の部分があったり、
                    モデル中のどれかのフレームの不透明度が 1.0f ではなかったりすると TRUE が返ってきます。<br><br>

                    　半透明要素を持つモデルをＺソートする場合に、各モデルに半透明要素があるかどうかを判定する際などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x の不透明度を上下キーで操作できるようにした上で、
              画面上に MV1GetSemiTransState 関数の戻り値を表示して半透明要素があるかどうかを確認できるようにしています。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float OpacityRate ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // 不透明度を初期化
    OpacityRate = 1.0f ;

    // ESCキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面のクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 上キーが押されたら不透明度を上げる
        if( CheckHitKey( KEY_INPUT_UP ) )
        {
            OpacityRate += 0.05f ;
            if( OpacityRate > 1.0f )
            {
                OpacityRate = 1.0f ;
            }
        }

        // 下キーが押されたら不透明度を下げる
        if( CheckHitKey( KEY_INPUT_DOWN ) )
        {
            OpacityRate -= 0.05f ;
            if( OpacityRate < 0.0f )
            {
                OpacityRate = 0.0f ;
            }
        }

        // ３Ｄモデルの不透明度を設定する
        <b><a href="dxfunc_3d_model_0.html#R3N24">MV1SetOpacityRate</a></b>( ModelHandle, OpacityRate ) ;

        // ３Ｄモデルの描画
        <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 現在の不透明度と、MV1GetSemiTransState の戻り値を描画する
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),
            "ESC Key:Exit OpacityRate:%f SemiTransState:%d",
            OpacityRate, MV1GetSemiTransState( ModelHandle ) ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

            
        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N24">宣言</a></b></td><td><font color="#000088"><b>int MV1SetOpacityRate( int MHandle, float Rate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの不透明度を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            float Rate ： 不透明度( 0.0f ～ 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの不透明度を設定します。<br><br>

                    　Rate の値が 0.0f に近いほど不透明度が下がり( 透明度が上がり )、
                    1.0f に近いほど不透明度が上がり( 透明度が下がり )ます。<br><br>
                
                    　モデルを半透明で表示したかったり、だんだん透明になって消えていくなどの演出をしたい場合に使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x の不透明度を５０％にして描画します。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 透明で描画されているということが分かるように画面全体を赤で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="dxfunc_3d_math.html#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの不透明度を50%にする
    MV1SetOpacityRate( ModelHandle, 0.5f ) ;

    // ３Ｄモデルの描画
    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N25">宣言</a></b></td><td><font color="#000088"><b>float MV1GetOpacityRate( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの不透明度を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルに設定されている不透明度<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに設定されている不透明度を取得します。<br>
                    　<b><a href="dxfunc_3d_model_0.html#R3N24">MV1SetOpacityRate</a></b> でセットした値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N26">宣言</a></b></td><td><font color="#000088"><b>int MV1SetUseZBuffer( int MHandle, int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画する際にＺバッファを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int Flag ： Ｚバッファを使用するかどうかのフラグ<br>
            　　　　　　( TRUE：使用する( 初期設定 )  FALSE：使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルを描画する際にＺバッファを使用するかどうかを設定します。<br><br>
                    
                    　<b><a href="dxfunc_3d_draw.html#R14N12">SetUseZBuffer3D</a></b> のモデル用の関数で、
                    効果は SetUseZBuffer3D と全く同じです。
                    ( Ｚバッファの詳しい説明は SetUseZBuffer3D 関数の解説に記述してあります )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N27">宣言</a></b></td><td><font color="#000088"><b>int MV1SetWriteZBuffer( int MHandle, int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画する際にＺバッファを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int Flag ： Ｚバッファに書き込みを行うかどうかのフラグ<br>
            　　　　　　( TRUE：書き込む( 初期設定 )  FALSE：書き込まない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルを描画する際にＺバッファを使用するかどうかを設定します。<br><br>
                    
                    　<b><a href="dxfunc_3d_draw.html#R14N13">SetWriteZBuffer3D</a></b> のモデル用の関数で、
                    効果は SetWriteZBuffer3D と全く同じです。
                    ( Ｚバッファの詳しい説明は <b><a href="dxfunc_3d_draw.html#R14N12">SetUseZBuffer3D</a></b> 関数の解説に記述してあります )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N28">宣言</a></b></td><td><font color="#000088"><b>int MV1SetUseVertDifColor( int MHandle, int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデル描画のライティング計算に頂点データのディフューズカラーを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int UseFlag ： 頂点データのディフューズカラーを使用するかどうか<br>
            　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルを描画する際のライティング計算に頂点データのディフューズカラーをマテリアルのディフューズカラーとして使用するかどうかを設定します。( 初期設定では使用しません )<br><br>
                    
                    　この関数で頂点ディフューズカラーを使用する設定にした場合はマテリアルのディフューズカラー設定は無視され、
                    代わりに頂点ディフューズカラーが使用されます。<br><br>

                    　尚、ライティング計算を <b><a href="dxfunc_3d_light.html#R13N44">SetUseLighting</a></b> 関数で無効にした場合はこの関数の設定に関係なくマテリアルのディフューズカラーは無視され、頂点ディフューズカラーが使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="dxfunc_3d_model_3.html#R7N27">MV1SetMeshUseVertDifColor関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N29">宣言</a></b></td><td><font color="#000088"><b>int MV1SetUseVertSpcColor( int MHandle, int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデル描画のライティング計算に頂点データのスペキュラカラーを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int UseFlag ： 頂点データのスペキュラカラーを使用するかどうか<br>
            　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルを描画する際のライティング計算に頂点データのスペキュラカラーをマテリアルのスペキュラカラーとして使用するかどうかを設定します。( 初期設定では使用しません )<br><br>
                    
                    　この関数で頂点スペキュラカラーを使用する設定にした場合はマテリアルのスペキュラカラー設定は無視され、
                    代わりに頂点スペキュラカラーが使用されます。<br><br>

                    　尚、ライティング計算を <b><a href="dxfunc_3d_light.html#R13N44">SetUseLighting</a></b> 関数で無効にした場合はこの関数の設定に関係なくマテリアルのスペキュラカラーは無視され、頂点スペキュラカラーが使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N30">宣言</a></b></td><td><font color="#000088"><b>int MV1PhysicsCalculation( int MHandle, float MillisecondTime ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの物理演算を指定時間分経過したと仮定して計算する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle　　　　　 ： モデルのハンドル<br>
            float MillisecondTime ： 経過時間( 単位：ミリ秒 )<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　関数 <b><a href="dxfunc_3d_model_0.html#R1N4">MV1SetLoadModelUsePhysicsMode</a></b>を使用して読み込む３Ｄモデルに対してリアルタイム物理演算を行うように指定した上で、
                物理演算用の情報を持つ３Ｄモデルを関数 <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>
                    で読み込んだ場合に、この関数を使用して実際の物理演算を行います。<br><br>

                    　引数の MillisecondTime で経過したと仮定する時間を指定します。<br>
                    　単位はミリ秒( １秒は 1000.0fミリ秒 )です、通常のゲームは１秒間に６０回、
                    若しくは３０回画面が更新されるので、これに基づいて引数を指定する場合は<br><br>

                    １秒間に６０回の場合は１回に 1000.0f ミリ秒の６０分の１分だけ処理するので<br><br>

                    　　1000.0f / 60.0f = 16.66667f<br><br>

                    １秒間に３０回の場合は１回に 1000.0f ミリ秒の３０分の１分だけ処理するので<br><br>

                    　　1000.0f / 30.0f = 33.33333f<br><br>

                    となります。<br><br>

                    　この関数の結果はモデルの位置や姿勢を変更する関数( <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b> や <b><a href="dxfunc_3d_model_0.html#R3N6">MV1SetRotationXYZ</a></b>、<b><a href="dxfunc_3d_model_0.html#R3N11">MV1SetMatrix</a></b>、<b><a href="dxfunc_3d_model_1.html#R4N1">MV1AttachAnim</a></b>、<b><a href="dxfunc_3d_model_1.html#R4N3">MV1SetAttachAnimTime</a></b>
                    )を使用すると無効になってしまいますので、物理演算の結果を描画する場合は必ず<br><br>

                    　<b>MV1SetPosition や MV1SetRotationXYZ、MV1SetAttachAnimTime などの関数で姿勢を決定した後</b><br><br>
                    
                    に、この関数を実行するようにしてください。<br><br>

                    ＜注意＞<br>
                    リアルタイム物理演算を使用する場合は <b><a href="dxfunc_3d_model_0.html#R3N4">MV1SetScale</a></b> によるスケーリングを行うと正常な演算結果が得られなくなりますので MV1SetScale を使用する場合はリアルタイム物理演算は行わないでください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　リアルタイム物理演算モードで Test.pmd を <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b> で読み込んで<br>
            リアルタイム物理演算を行いながらキーボードの上下左右でモデルの位置を移動します。<br>
            　尚、Test.pmd はＤＸライブラリのパッケージには含まれていませんので、別途用意してください。<br>
            　PMDのキャラクターは大体同じ大きさですので、カメラの設定などはそのままで問題ないと思います。<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int PosX, PosZ, PosY ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 次に読み込むモデルの物理演算モードをリアルタイム物理演算にする
    <b><a href="dxfunc_3d_model_0.html#R1N4">MV1SetLoadModelUsePhysicsMode</a></b>( DX_LOADMODEL_PHYSICS_REALTIME ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="dxfunc_3d_model_0.html#R1N1">MV1LoadModel</a></b>( "Test.pmd" ) ;

    // 描画先を裏画面に変更
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // カメラに映る範囲( カメラからの距離の範囲 )を設定
    <b><a href="dxfunc_3d_camera.html#R12N1">SetCameraNearFar</a></b>( 10.0f, 1000.0f ) ;

    // カメラの位置と向きを設定
    <b><a href="dxfunc_3d_camera.html#R12N2">SetCameraPositionAndTarget_UpVecY</a></b>( VGet( 0.0f, 19.0f, -22.5f ), VGet( 0.0f, 10.0f, 0.0f ) ) ;

    // 座標をリセット
    PosX = 0 ;
    PosY = 0 ;
    PosZ = 0 ;

    // ウインドウが閉じられるまでループ
    while( ProcessMessage() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // キーボードの上下左右でモデルの座標を変更
        // ( シフトキーを押しながら上下キーでモデルを上下に移動 )
        if( CheckHitKey( KEY_INPUT_LSHIFT ) )
        {
            if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosY -- ;
            if( CheckHitKey( KEY_INPUT_UP    ) ) PosY ++ ;
        }
        else
        {
            if( CheckHitKey( KEY_INPUT_LEFT  ) ) PosX -- ;
            if( CheckHitKey( KEY_INPUT_RIGHT ) ) PosX ++ ;
            if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosZ -- ;
            if( CheckHitKey( KEY_INPUT_UP    ) ) PosZ ++ ;
        }

        // モデルの座標をセット
        <b><a href="dxfunc_3d_model_0.html#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( PosX * 0.5f, PosY * 0.5f, PosZ * 0.5f ) ) ;

        // 物理演算を６０分の１秒経過したという想定で実行
        MV1PhysicsCalculation( ModelHandle, 1000.0f / 60.0f ) ;

        // ３Ｄモデルの描画
        <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        ScreenFlip() ;
    }

    // モデルハンドルの削除
    <b><a href="dxfunc_3d_model_0.html#R1N3">MV1DeleteModel</a></b>( ModelHandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        
        <tr><td colspan="4">
            <hr>
            <font size="3"><b>
                <a href="../dxfunc.html">戻る</a>
            </b></font>
        </td></tr>
    </table>
    </div>
    </body>
</html>
