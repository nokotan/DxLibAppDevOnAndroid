<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja-JP">
    <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <link rel="shortcut icon" href="../DxLib.ico">
    <link rel="stylesheet" href="../style.css" type="text/css">
    <title>ＤＸライブラリ置き場　リファレンスページ</title>
    </head>
    <body bgcolor="#ffffff" text="#000000" link="#0033CC" vlink="#800040">
    <div class="NormalFont">

    <table align="center" width="800" cellspacing="0" cellpadding="0" >

        <tr><td><font size="3" color="#005500"><b>ウエイト関係の関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N1">宣言</a></b></td><td><font color="#000088"><b>int    WaitTimer( int WaitTime ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定の時間だけ処理をとめる<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>WaitTime : 止める時間（ミリ秒単位）</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　WaitTimeで指定した分だけ処理を止めます。ただそれだけです。
                    なお止まっている間は常に<a href="../dxfunc.html#R1N3"><b>ProcessMessage』</b></a>関数を実行
                    しています。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ソフトの終了を３秒間待つ<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // ここで３秒まつ
    WaitTimer( 3000 ) ;

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N2">宣言</a></b></td><td><font color="#000088"><b>int    WaitVSync( int SyncNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ディスプレイの垂直同期信号を指定回数待つ<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>SyncNum : 垂直同期信号を待つ回数</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ディスプレイの垂直同期信号を指定回数待ちます。<br>
                    　簡単に説明しますとディスプレイの詳細で設定の出来る『リフレッシュレート』で１秒間を割った時間が回数１回につき待つ時間の長さです（正確には違いますが）。<br>
                    　ともあれこの関数は現在ではあまり使う機会もないと思うので垂直同期信号が何ぞや、と言うことについて詳しく説明はしません。<br><br>

                    　尚、ＤＸライブラリがグラフィックスAPIとして Direct3D 9 を使用している場合のみ、止まっている間は常に<a href="../dxfunc.html#R1N3"><b>『ProcessMessage』関数</b></a>が実行されます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　垂直同期信号を６０回待ちます<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // ここで垂直同期信号を６０回待つ
    WaitVSync( 60 ) ;

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N3">宣言</a></b></td><td><font color="#000088"><b>int WaitKey( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>キーの入力待ち<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>入力されたキーのコード（<a href="dxfunc_input.html#R5N2"><b>『CheckHitKey』関数</b></a>を参照）<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　何かキーが押されるまで待ちます。それだけです。<br>
                    なお止まっている間は常に<a href="../dxfunc.html#R1N3"><b>『ProcessMessage』関数</b></a>を実行
                    しています。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　何かキーが押されるまで待つ<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // ここでキー入力を待つ
    WaitKey() ;

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
            <br><br><br>
        </td></tr>





        <tr><td><font size="3" color="#005500"><b>時間関係の関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N1">宣言</a></b></td><td><font color="#000088"><b>int    GetNowCount( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ミリ秒単位の精度を持つカウンタの現在値を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Windowsが起動してから経過時間をミリ秒単位であらわした値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　すぐ上に書いてありますが、Windows が起動してから経過時間をミリ秒単位であらわした値が返ってきます。この関数の存在意義は時間の計測にあります。特定の時間を取得する事はこの関数では出来ません。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　６秒間待つ<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int StartTime ;

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // 現在経過時間を得る
    StartTime = GetNowCount() ;

    // 計測開始から６秒が過ぎるまでループ
    while( GetNowCount() - StartTime &lt; 6000 )
    {
        // メッセージ処理
        if( ProcessMessage() == -1 )
        {
            break ;    // エラーが起きたらループから抜ける
        }
    }

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N2">宣言</a></b></td><td><font color="#000088"><b>LONGLONG GetNowHiPerformanceCount( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>GetNowCountの高精度バージョン<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Windowsが起動してから経過した時間をマイクロ秒単位で表した値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　GetNowCount の精度がミリ秒からマイクロ秒に向上した関数です。が、注意しなければならないのが戻り値が int型 変数の２倍の桁を持つ LONGLONG型 だと言うことです。それ以外は GetNowCount関数 と同じです。用途は同じく時間の計測ですが、より精度の高い計測を行う際に使用します<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　６秒間待つ<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    LONGLONG StartTime ;

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // 現在経過時間を得る
    StartTime = GetNowHiPerformanceCount() ;

    // 計測開始から６秒が過ぎるまでループ
    while( GetNowHiPerformanceCount() - StartTime &lt; 6000000 )
    {
        // メッセージ処理
        if( ProcessMessage() == -1 )
        {
            break ;    // エラーが起きたらループから抜ける
        }
    }

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N3">宣言</a></b></td><td><font color="#000088"><b>int    GetDateTime( DATEDATA *DateBuf ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>現在時刻を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>DateBuf : ＤＸライブラリ独自の<b>DATEDATA構造体</b>のポインタ</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ＤＸライブラリ独自の <b>DATEDATA</b> 構造体に現在時刻を格納します。 <b>DATEDATA</b> 構造体は以下のようなメンバ変数で成り立っています。<br><br>

                    <table align="left" cellspacing="0" cellpadding="0">
                        <tr><td>int Year ; </td><td>// 年</td></tr>
                        <tr><td>int Mon　; </td><td>// 月</td></tr>
                        <tr><td>int Day　; </td><td>// 日</td></tr>
                        <tr><td>int Hour ; </td><td>// 時間</td></tr>
                        <tr><td>int Min　; </td><td>// 分</td></tr>
                        <tr><td>int Sec　; </td><td>// 秒</td></tr>
                    </table>
                    <br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　現在時刻を取得する<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    DATEDATA Date ;

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // 現在時刻を得る
    GetDateTime( &amp;Date ) ;

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
            <br><br><br>
        </td></tr>






















        <tr><td><font size="3" color="#005500"><b>乱数取得関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R10N1">宣言</a></b></td><td><font color="#000088"><b>int    GetRand( int RandMax ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>乱数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>RandMax : 取得する乱数の最大値</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０　から　RandMax　で指定した数値のどれかの数値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　乱数を得ます。この関数は ０ から RandMax で指定した数値のどれかの数値を返します。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ランダムな座標で１０００個の点を描画します<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int i ;
    int Cr ;

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // 白色の値を取得
    Cr = GetColor( 255 , 255 , 255 ) ;

    // １０００個の点を描く
    for( i = 0 ; i &lt; 1000 ; i ++ )
    {
        // ランダムな位置に点を描く（『GetRand』を使用） 
        DrawPixel( GetRand( 639 ) , GetRand( 479 ) , Cr ) ;
    }

    WaitKey() ;        // 結果を見るためにキー待ち(『WaitKey』を使用)

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R10N2">宣言</a></b></td><td><font color="#000088"><b>int    SRand( int Seed ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>乱数の初期値を設定する。<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>int Seed : 乱数の初期化値</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R10N1"><b>GetRand</b></a> 関数で取得する乱数の初期値を設定します。<br>
                    　コンピューター上の乱数というものはすべて疑似的なものであり、
                    結果的には計算で算出するので初期値が同じであれば初期値を
                    設定した後に取得できる乱数は常に同じものとなります。<br><br><br>

                    　例　初期値を０にした時の乱数値<br><br>

                    １番目：１８　　　　　２番目：６１１<br>
                    　(これはいつ初期値を設定してもかならずこの結果になる)<br><br>

                    
                    　なので、普通ゲームソフトなどでは毎回違う結果が出るように
                    ソフトの起動時にその時のパソコンが保持している日時データなどを
                    元に初期値を設定したりします。<br>
                    　ＤＸライブラリでは標準でこの処理を行うのですが、時に自分で
                    初期値を明示的に設定したい時などがあります。<br><br>
                    
                    　この関数はそんな時のためにあります。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません<br>
            <br><br><br><br><br>
        </td></tr>











        <tr><td><font size="3" color="#005500"><b>ウインドウモード・フルスクリーンモード変更用関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N1">宣言</a></b></td><td><font color="#000088"><b>int ChangeWindowMode( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ウインドウモード・フルスクリーンモードの変更を行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>Flag : ウインドウモードで起動するかのフラグ情報<br>
                    　　　　　TRUE  : ウインドモードで起動<br>
                    　　　　　FALSE : フルスクリーンモードで起動（デフォルト）</td>
            </tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>DX_CHANGESCREEN_OK　　　: モードの移行は成功した<br>
                DX_CHANGESCREEN_RETURN　: モードの変更は失敗し、元の画面モードに戻された<br>
                DX_CHANGESCREEN_DEFAULT    : モードの変更は失敗しデフォルトの画面モードに変更された<br>
　            </td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ソフトをウインドウモードで実行するか、フルスクリーンモードで実行するのかを変更します。
                    一般にはウインドウモードよりフルスクリーンで実行する方が動作条件は良くなるのですが、
                    ソフトのデバッグ作業をフルスクリーンで行うのはどうしても困難なので、
                    制作中のみウインドウモードで実行し、完成バージョンではフルスクリーン実行にする、
                    等の用途に使えます。<br>
                    　もしソフト中でウインドウモードとフルスクリーンモードの変更が出来るようにする場合はフルスクリーンとウインドウモードとのカラービット数の違いに気を付ける必要があります。
                    特に２５６色モードで実行するソフトでの配布版での変更は望ましくありません。<br><br>

                <font color="#a00000">
                    ＜注意＞<br>
                    　この関数を実行するとロードしたすべてのグラフィックハンドルと３Ｄモデルハンドル、
                    作成したフォントハンドルは自動的に削除され、<a href="dxfunc_graph3.html#R4N3">SetDrawArea</a>, <a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a>, <a href="dxfunc_graph1.html#R3N16">SetDrawMode</a>,
                    <a href="dxfunc_graph1.html#R3N17">SetDrawBlendMode</a>, <a href="dxfunc_graph1.html#R3N18">SetDrawBright</a> 等の描画に関係する設定を行う関数による設定も全て初期状態に戻りますので、
                    画面モード変更後 <a href="dxfunc_graph1.html#R3N2">LoadGraph</a>関数や <a href="dxfunc_graph2.html#R17N10">CreateFontToHandle</a>関数等で再度ハンドルを作成し直し、
                    描画可能領域、描画対象画面等の各種描画系の設定も再度行う必要があります。<br><br>
                </font>

                    次にフルスクリーンモードとウインドウモードの違いを示します<br><br>

                <table align="left" border="2" cellspacing="4" cellpadding="4">
                    <tr><td align="center"> </td><td align="center">Full</td><td align="center">Window</td></tr>
                    <tr><td align="center">マウスカーソル<br>初期状態</td><td align="center">表示されない</td><td align="center">表示される</td></tr>
                    <tr><td align="center">ScreenFlip関数</td><td>    表画面と裏画面を<br>交換する</td><td>裏画面の内容を<br>表画面にコピーする</td></tr>
                    <tr><td align="center">画面モード</td>
                        <td><a href="dxfunc_graph3.html#R4N1"><b>SetGraphMode関数</b></a>で<br>変更可能、及び標準で<br>640×480 16bit Color</td>
                        <td><a href="dxfunc_graph3.html#R4N1"><b>SetGraphMode関数</b></a>での<br>変更不可、常に起動時の<br>デスクトップの画面モードとなる</td>
                    </tr>
                </table>
                </td>
            </tr>

            <tr>
                <td></td>
                <td>
                    <br><br>
                    追記<br>
                    　なおこの関数を <a href="../dxfunc.html#R1N1">DxLib_Init</a> 関数を使用する前に呼び出すことにより初期状態を変更することが出来ます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ウインドウモード起動して文字列を描画する<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int Cr ;

    // ウインドウモードに変更
    ChangeWindowMode( TRUE ) ;

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // 白色の値を取得
    Cr = GetColor( 255 , 255 , 255 ) ;

    // 文字列の描画
    DrawString( 250 , 240 - 16 , "Hello C World!" , Cr );

    WaitKey() ;        // キーの入力待ち(『WaitKey』を使用)

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N13">宣言</a></b></td><td><font color="#000088"><b>int SetMainWindowText( char *WindowText ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ウインドウのタイトルを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>char *WindowText : 変更後のタイトルの文字列が入った先頭アドレス</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ウインドウのタイトルとはウインドウのシステムバー(×ボタンや縮小
                    ・拡大ボタンがある一番上のバー)の左端に表示されている文字列で、
                    この関数はこの文字列を変更する時に使用します。<br><br>

                    　尚、この関数を DxLib_Init 使用前に呼び出すことにより、初期状態の
                    タイトルを設定することが出来ます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>


                　ウインドウモードで起動し、ウインドウのタイトルを『test』に変更して、ボタンが押されるまで待ちます<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // タイトルを test に変更
    SetMainWindowText( "test" ) ;

    // ウインドウモードに変更
    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリ初期化処理
    if( DxLib_Init() == -1 )
         return -1;    // エラーが起きたら直ちに終了

    // キーの入力待ち(『WaitKey』を使用)
    WaitKey() ;

    // ＤＸライブラリ使用の終了処理
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N2">宣言</a></b></td><td><font color="#000088"><b>int SetWindowIconID( int ID ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ウインドウのアイコンを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int ID : 変更後のアイコンのＩＤ</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　この関数は、ソフトを起動したときにタスクバーの左端やウインドウの
                    左上端に表示されるアイコンを変更する時に使用します。<br>
                    　まず、ソフトに専用のアイコンを組み込む方法については本サイトの
                    ミニテクコーナーの『<a href="../dxtec.html#M2">自作ソフトにオリジナルアイコンを付ける</a>』をご参照下さい。<br>
                    　ここではアイコンが既にソフトに組み込まれていることを前提で進めます。<br><br>

                    <font color="#004400"><b>Borland C++ の場合</b></font><br>

                    　まず、ミニテクコーナーで作成した Resource.rc を開いてください。<br>
                    　この中で、『MAINICON』と書かれている部分がありますが、実はここは
                    数値でも問題がありません。というわけで、MAINICON の代わりに 101 や 102
                    等の適当な数値に置き換えて下さい。<br>
                    　そして次に SetWindowIconID に先ほど『MAINICON』の代わりに入力した
                    数値を引数として渡して下さい。恐らくそれでウインドウのアイコンが
                    変わるはずです。<br><br>

                    <font color="#004400"><b>VisualC++ の場合</b></font><br>

                    　ミニテクコーナーの一連の作業を行った場合、VisualC++ はプロジェクトの
                        フォルダに勝手に『resource.h』というヘッダファイルを作成します。<br>
                    　このファイルを開くと、色々書かれていますが、その中で<br><br>

                    <font color="#000077">#define IDI_ICON1　　101</font><br><br>

                    　等のような定義が何処かにされていると思いますが、正にこれが
                    SetWindowIconID の引数として渡すべきアイコンのＩＤとなります。<br>
                    　なので、徐に resource.h をインクルードして、SetWindowIconID
                    にこのＩＤを渡せばウインドウのアイコンが変わります。<br><br><br>

                    　尚、この関数を DxLib_Init より前に呼び出すことにより、初期状態の
                    アイコンを変更することが出来ます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>


                　ありません。<br><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N3">宣言</a></b></td><td><font color="#000088"><b>int SetWindowSizeChangeEnableFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ウインドウモードの時にウインドウのサイズを自由に変更出来るようにするかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int Flag : ウインドウのサイズを変更出来るようにするかどうかのフラグ情報<br>
                    　　　　　　TRUE : 変更出来るようにする<br>
                    　　　　　　FALSE : 変更出来ないようにする(デフォルト)</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　この関数はウインドウモードでソフトを動かしている時に
                ウインドウの枠を左クリックで抓まんで、ウインドウのサイズを自由に
                変更できるようにするかどうかを設定する関数です。<br>
                　TRUE を渡すと変更できるようになり、FALSE を渡すと変更出来ないように
                なります。(起動時には FALSE の状態になっています)<br><br>
                
                <font color="#ff0000"><b>
                《注意》<br>
                　この関数に TRUE を渡してサイズを自由に変更出来るようにした時は、
                <a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a> 関数に DX_SCREEN_BACK を渡して、
                絶対に表画面に直接描画しないようにして下さい。(表画面に直接描画すると正しい描画結果が得られません)<br><br>
                </b></font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>


                　ありません。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N4">宣言</a></b></td><td><font color="#000088"><b>int SetWindowSizeExtendRate( double ExRate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ウインドウモードの時のウインドウの大きさと描画画面の大きさの比率を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>double ExRate : ウインドウのサイズと描画画面のサイズの比率</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ウインドウモード時のウインドウの大きさをゲーム画面の ExRate 倍にします。<br>
                　ゲーム画面のサイズが小さく、ウインドウモードにすると迫力が無い、という時に使用します。<br><br>

                <font color="#ff0000"><b>
                《注意》<br>
                　この関数に 1.0 以外の値を渡した場合は <a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a> 関数に DX_SCREEN_BACK を渡して、
                絶対に表画面に直接描画しないようにして下さい。(表画面に直接描画すると正しい描画結果が得られません)<br><br>
                </b></font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>


                　ありません。<br><br><br><br><br>
        </td></tr>


                        



        <tr><td><font size="3" color="#005500"><b>通信関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N1">宣言</a></b></td><td><font color="#000088"><b>int    ConnectNetWork( IPDATA IPData, int Port ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>他マシンに接続する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                    IPDATA　IPData : 接続先マシンのＩＰアドレスデータ<br>
                    int　Port : 通信に使用するポート番号<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：確立した接続を示すネットワークハンドル(int型の識別値)</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　　ＬＡＮやインターネット等で繋がっている他のマシンと通信状態を確立します。<br><br>

                    　当たり前ですが、相手と自分がともにインターネットをしていないと接続を確立することは出来ません。
                    (ＬＡＮなら相手のマシンと繋がっていないとだめです)<br><br>

                    　接続先のマシンはＩＰアドレスを使って指定します。
                    ＩＰアドレスとはネットワーク環境に接続しているマシンすべてに割り当てられる電話番号みたいなもので、
                    電話回線を使ったネット環境ではインターネットをする度にＩＰアドレスは変動します。(ＬＡＮなら固定です)<br><br>

                    　ですのでまず接続したい相手のマシンのＩＰアドレスを知る必要がありますが、
                    相手のマシンのＩＰアドレスを自分で調べることは出来ないので、
                    接続したい相手の方に自分のマシンのＩＰアドレスを調べてもらう必要があります。<br><br>
                    　
                    　調べ方はインターネットネットワークの場合は調べるためのソフトなどがフリーソフトとして公開されていますのでそれを使って調べます。<br><br>
                    
                    　ＬＡＮの場合はコントロールパネルのネットワークを開いて、
                    リストの中のＴＣＰ/ＩＰをダブルクリックすればそこにＩＰアドレスが載っています。<br><br>

                    　ちなみにＩＰアドレスとは以下のようなものです<br><br>

                    　ＩＰアドレスの例    192.168.5.226<br><br>

                    　４つの数値が『.』で区切られている、という形であらわされます。<br><br>

                    　次に相手のマシンは接続されるのを待つ状態にしなくてはなりません、
                    接続を待つ状態にするには <a href="#R13N3"><b>PreparationListenNetWork関数</b></a>を実行ます、
                    この関数は引数のないただ実行するだけの関数です。<br><br>

                    　さて、ＩＰアドレスがわかり、相手のマシンが接続を待つ状態になったらいよいよ
                    ConnectNetWork 関数で相手に接続することが出来ます。<br>
                    　接続には接続先のマシンのＩＰアドレスと通信に使用するポート番号をＤＸライブラリの構造体の IPDATA 構造体を使って指定します。
                    　IPDATA 構造体の中には以下のデータが入っています。<br><br>
                    
                    {<br>
                    　　unsigned char d1 ;<br>
                    　　unsigned char d2 ;<br>
                    　　unsigned char d3 ;<br>
                    　　unsigned char d4 ;<br>
                    }<br><br>

                    　１バイトデータ型である unsigned char 型の変数が４つ、ピンときた方もいると思いますが、
                    そうです、ＩＰアドレスが『 192.168.5.226 』だった場合 IPDATA 構造体には以下のようにデータを代入します。<br><br>

                    例<br><br>

                    IPDATA ip ;<br><br>

                    ip.d1 = 192 ;<br>
                    ip.d2 = 168 ;<br>
                    ip.d3 = 5 ;<br>
                    ip.d4 = 226 ;<br><br>

                    　おわかりいただけたでしょうか？要はＩＰアドレスの左から順にd1.d2.d3.d4に対応しているのです。
                    こうして代入したＩＰデータを ConnectNetWork関数に渡します。<br>
                    　もう一つの引数 Port ですが、こちらは通信に使用するポート番号です、
                    ポート番号は 0 から 65535 までの値を指定することができますが、
                    メール送受信用に使われている番号( 465 )やＷｅｂサイトの情報の送受信に使用されている番号( 80 )など、
                    使用すると他のソフトの挙動に支障をきたす番号が沢山ありますので、
                    使用しても問題ない番号はインターネットで調べてみてください。<br><br>

                    　これで接続が成功したらネットワークハンドルが返ってきます。
                    ネットワークハンドルとは int 型の識別番号値で、データを送信するときや、
                    通信を終了するときなどに相手のマシンを決定するときに使いますので保存しておいてください。
                    接続に失敗したら－１が返ります。(ハンドルは０以上の数値です)<br><br>

                    　接続が終わったらこちらは接続されたかすぐわかりますが、相手のマシンは
                    接続されたことを知りませんので、接続を待っているマシンは一定周期で
                    <a href="#R13N10"><b>GetNewAcceptNetWork関数</b></a> を使って誰かが接続してきたか調べる必要が
                    あります。<br><br>

                    　接続が完了したら後はデータを送信したり、受信したりするだけです。
                    　それらについてはそれぞれの関数の解説を参照してください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　接続を確立して相手に『繋がったか～！？』という文字列を送り、相手は届いたら
                『繋がったぞ～！！』という文字列を送り返してきます。<br><br>
            <hr>
<pre><div class="NormalFont">-- 接続側プログラム
-----------------------------------
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    char StrBuf[ 256 ] ;    // データバッファ
    IPDATA Ip ;        // 接続用ＩＰアドレスデータ
    int NetHandle ;        // ネットワークハンドル
    int DataLength ;        // 受信データ量保存用変数

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // ＩＰアドレスを設定( ここにある４つのＩＰ値は仮です )
    Ip.d1 = 192 ;
    Ip.d2 = 168 ;
    Ip.d3 = 5   ;
    Ip.d4 = 227 ;

    // 通信を確立
    NetHandle = ConnectNetWork( Ip, 9850 ) ;

    // 確立が成功した場合のみ中の処理をする
    if( NetHandle != -1 )
    { 
        // データ送信
        NetWorkSend( NetHandle , "繋がったか～！？" , 17 ) ;

        // データがくるのを待つ
        while( !ProcessMessage() )
        {
            // 取得していない受信データ量を得る
            DataLength = GetNetWorkDataLength( NetHandle ) ;

            // 取得してない受信データ量が０じゃない場合はループを抜ける
            if( DataLength != 0 ) break ;
        }

        // データ受信
        NetWorkRecv( NetHandle , StrBuf , DataLength ) ;    // データをバッファに取得

        // 受信したデータを描画
        DrawString( 0 , 0 , StrBuf , GetColor( 255 , 255 , 255 ) ) ;

        // キー入力待ち
        WaitKey() ;

        // 接続を断つ
        CloseNetWork( NetHandle ) ;
    }

    DxLib_End() ;    // ＤＸライブラリ使用の終了処理

    return 0 ;    // ソフトの終了
}

-- 接続待ち側プログラム
-----------------------------------
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    char StrBuf[ 256 ] ;        // データバッファ
    int NetHandle , LostHandle ;    // ネットワークハンドル
    int DataLength ;            // 受信データ量保存用変数
    IPDATA Ip ;            // 接続先ＩＰアドレスデータ

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
        return -1;    // エラーが起きたら直ちに終了
    }

    // 接続してくるのを待つ状態にする
    PreparationListenNetWork( 9850 ) ;

    // 接続してくるかＥＳＣキーが押されるまでループ
    NetHandle = -1 ;
    while( !ProcessMessage() &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 新しい接続があったらそのネットワークハンドルを得る
        NetHandle = GetNewAcceptNetWork() ;
        if( NetHandle != -1 ) break ;
    }

    // 接続されていたら次に進む
    if( NetHandle != -1 )
    {
        // 接続の受付を終了する
        StopListenNetWork() ;

        // 接続してきたマシンのＩＰアドレスを得る
        GetNetWorkIP( NetHandle , &amp;Ip ) ;

        // データが送られて来るまで待つ
        while( !ProcessMessage() )
        {
            // 取得していない受信データ量が０以外のときはループから抜ける
            if( GetNetWorkDataLength( NetHandle ) != 0 ) break ;
        }

        // データ受信
        DataLength = GetNetWorkDataLength( NetHandle ) ;    // データの量を取得
        NetWorkRecv( NetHandle , StrBuf , DataLength );    // データをバッファに取得

        // 受信したデータを描画
        DrawString( 0 , 0 , StrBuf , GetColor( 255 , 255 , 255 ) ) ;

        // 受信成功のデータを送信
        NetWorkSend( NetHandle , "繋がったぞ～！！" , 17 ) ;

        // 相手が通信を切断するまで待つ
        while( !ProcessMessage() )
        {
            // 新たに切断されたネットワークハンドルを得る
            LostHandle = GetLostNetWork() ;

            // 切断された接続が今まで通信してた相手だった場合ループを抜ける
            if( LostHandle == NetHandle ) break ;
        }

        // 切断確認表示
        DrawString( 0 , 16 , "切断しました" , GetColor( 255 , 255 , 255 ) ) ;

        // キー入力待ち
        WaitKey() ;
    }

    DxLib_End() ;    // ＤＸライブラリ使用の終了処理

    return 0 ;    // ソフトの終了
}
</div></pre>
            <hr>
            <br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N2">宣言</a></b></td><td><font color="#000088"><b>
                int    CloseNetWork( int NetHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>接続を終了する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int NetHandle : 接続を終了するネットワークハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N1"><b>ConnectNetWork関数</b></a>で確立した接続状態を終了し、データの送受信を
                    終了します。<br>
                    　ネットワーク送受信に関する説明は<a href="#R13N1"><b>ConnectNetWork関数</b></a>の解説を参照
                    してください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N3">宣言</a></b></td><td><font color="#000088"><b>
                int PreparationListenNetWork( int Port ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>接続を受けられる状態にする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td> int Port : 通信に使用するポート番号</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　自分のマシンが他マシンからの<a href="#R13N1"><b>ConnectNetWork関数</b></a>によって接続を確立出来る状態にします。<br>
                    　この関数は別に接続を受けるまで関数から出て来ないわけでは無いので、この関数を使用後、接続があったかどうかを、
                    そして新たに確立した接続を示すネットワークハンドルを得るために<a href="#R13N10"><b>GetNewAcceptNetWork関数</b></a>を使用する必要があります。<br>
                    　取得したネットワークハンドルは<a href="#R13N1"><b>ConnectNetWork関数</b></a>で取得できるものと区別はありませんので接続を終了したい場合は<a href="#R13N2"><b>CloseNetWork関数</b></a>で切断することが出来ます。<br><br>
                    　引数の Port では通信に使用するポート番号を指定します、この番号は ConnectNetWork関数で接続を試みる側が指定するポート番号と一致している必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい。<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N4">宣言</a></b></td><td><font color="#000088"><b>
                int    StopListenNetWork( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>接続を受け付けている状態を解除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N3"><b>PreparationListenNetWork関数</b></a>によって接続受けつけ状態になったマシンの
                    受けつけ状態を解除します。以降<a href="#R13N1"><b>ConnectNetWork関数</b></a>による通信接続要求には
                    反応しなくなります。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N5">宣言</a></b></td><td><font color="#000088"><b>
                int NetWorkSend( int NetHandle, void *Buffer, int Length ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>データを送信する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                    int NetHandle : データを送信する接続先を示すネットワークハンドル<br>
                    void *Buffer　: 送信するデータがあるアドレス<br>
                    int Length　　: 送信するデータの量(バイト単位)<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N1"><b>ConnectNetWork関数</b></a>や<a href="#R13N10"><b>GetNewAcceptNetWork関数</b></a>によって取得
                    したネットワークハンドルの示す接続先マシンに Buffer の示すアドレスから Length の
                    バイト数分だけデータを送信します。<br><br>

                    　送られたデータは相手の受信データ一時記憶バッファに蓄えられ、<a href="#R13N8"><b>NetWorkRecv
                    関数</b></a>によって晴れて相手マシンの処理プログラムに渡されることとなります。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N6">宣言</a></b></td><td><font color="#000088"><b>
                int GetNetWorkDataLength( int NetHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>受信データ一時記憶バッファに溜まっているデータの量を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int NetHandle : 受信データの量を調べたい接続を示すネットワークハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>　０以上：受信データ一時記憶バッファに溜まっているデータの量(バイト単位)</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　相手マシンが<a href="#R13N5"><b>NetWorkSend関数</b></a>を使用して送信してきたデータは
                    自機の受信データ一時記憶バッファに格納されます。この関数は NetHandle が
                    示す接続先マシンが送ってきたデータを溜める一時記憶バッファに溜まっている
                    データの量を得ます。(すごいわかりにくいですね)<br><br>

                    　因みに<a href="#R13N8"><b>NetWorkRecv関数</b></a>によってバッファから読み出されたデータは
                    バッファから順次消去されます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N7">宣言</a></b></td><td><font color="#000088"><b>
                int GetNetWorkSendDataLength( int NetHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>未送信のデータの量を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int NetHandle : 未送信データ量を得たいネットのハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>　０以上：未送信のデータ量(バイト単位)</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N5"><b>NetWorkSend</b></a> 関数で送信をしたデータはすぐに
                    送信されるわけではない場合があり、その場合はライブラリ内部のメモリ領域に
                    一時的に保存されます、この関数はそうしてたまっているデータ量を取得するた
                    めにあります。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N8">宣言</a></b></td><td><font color="#000088"><b>
                int    NetWorkRecv( int NetHandle, void *Buffer, int Length ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>受信データ一時記憶バッファに溜まっているデータを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                    int NetHandle : 受信データを読み取りたい接続先を示すネットワークハンドル<br>
                    void *Buffer　: バッファに溜まったデータをコピーする先のアドレス<br>
                    int Length　　: バッファからコピーするデータの量(バイト単位)<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　相手マシンが<a href="#R13N5"><b>NetWorkSend関数</b></a>を使用して送信してきたデータは
                    自機の受信データ一時記憶バッファに格納されます。この関数はそうして一時記憶
                    バッファに溜まったデータを読み取る目的で使用します。<br><br>
                    
                    　関数は NetHandle が示す接続先が送ってきたデータを Buffer が示すアドレスに
                    Length バイト数分だけコピーします。<br><br>

                    　もし Length の示す要求データ量よりも一時記憶バッファに保存されている
                    データ量の方が少ない場合はこの関数は失敗します。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N9">宣言</a></b></td><td><font color="#000088"><b>
                int    NetWorkRecvToPeek( int NetHandle, void *Buffer, int Length ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>受信したデータを読み込む、読み込んだデータはバッファから削除されない<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                    int NetHandle : 受信データを読み取りたい接続先を示すネットワークハンドル<br>
                    void *Buffer　: バッファに溜まったデータをコピーする先のアドレス<br>
                    int Length　　: バッファからコピーするデータの量(バイト単位)<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　相手マシンが<a href="#R13N5"><b>NetWorkSend関数</b></a>を使用して送信してきたデータは
                    自機の受信データ一時記憶バッファに格納されます。この関数はそうして一時記憶
                    バッファに溜まったデータを読み取る目的で使用します。<br><br>
                    
                    　関数は NetHandle が示す接続先が送ってきたデータを Buffer が示すアドレスに
                    Length バイト数分だけコピーします。<br><br>

                    　もし Length の示す要求データ量よりも一時記憶バッファに保存されている
                    データ量の方が少ない場合はこの関数は失敗します。<br><br>

                    　などなど、<a href="#R13N8"><b>NetWorkRecv</b></a> に非常によくにていますがこの関数は NetWorkRecv
                    と違い受信したデータを受信バッファから取得しても受信バッファから読み
                    出したデータが失われません。<br>
                    　ただそれだけです。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　特に有りません<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N10">宣言</a></b></td><td><font color="#000088"><b>
                int GetNewAcceptNetWork( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>新たに確立した接続を示すネットワークハンドルを得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上 ： 新たに確立された接続を示すネットワークハンドル( int型 識別番号 )</td></tr>
            <tr><td width="100">　</td><td>－１：新たに確立された接続は無い<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N3"><b>PreparationListenNetWork関数</b></a>によって接続受けつけ状態に
                    なったマシンは、別に接続されるまで関数から返って来ないわけでは無いので
                    この関数によって<a href="#R13N3"><b>PreparationListenNetWork関数</b></a>使用後に新たに確立
                    された接続のネットワークハンドルを得る必要があるのです。<br><br>

                    　上記のように、－１が返ってきた場合は新たに確立された接続はない事を示し
                    ０以上の値が返ってきた場合はネットワークハンドルであることを示します。<br><br>

                    <font color="#ff0000"><b>《注意》</b></font><br><br>

                    　新たに確立された接続があった場合、この関数はその接続のネットワークハンドルを
                    １度しか返してきません。<br>
                    　ですので次のようなプログラムで、新たな接続があるのを確認してからそのネット
                    ワークハンドルを受け取るなどのようなことは出来ないので注意してください。<br><br><br>


                    　出来ない例<br><br>

<pre><div class="NormalFont">    int NetHandle ;

    // 新たな接続があるまでループしている
    while( !ProcessMessage() &amp;&amp; GetNewAcceptNetWork() == -1 ){}

    // あったのを確認後その接続のネットワークハンドルを受け取る。
    // はずなのだが一度しかネットワークハンドルは返って来ないので
    // これでは駄目。
    NetHandle = GetNewAcceptNetWork() ;
</div></pre>
<br><br>

                    　実際はこのようにする必要があります。<br><br>

                    　正解<br><br>

<pre><div class="NormalFont">    int NetHandle ;

    // 新たな接続があるか調べると同時に
    // あった場合はそのままネットワークハンドルを受け取れるようにする
    while( !ProcessMessage() )
    {
        NetHandle = GetNewAcceptNetWork() ;
        if( NetHandle != -1 ) break ;
    }
</div></pre>
<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N11">宣言</a></b></td><td><font color="#000088"><b>
                int    GetLostNetWork( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>新たに破棄された接続を示すネットワークハンドルを得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上 : 新たに絶たれた接続を示すネットワークハンドル</td></tr>
            <tr><td width="100">　</td><td>－１ : 新たに切断された接続は無い<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　通信エラーや、相手側の<a href="#R13N2"><b>CloseNetWork関数</b></a>使用などにより
                    絶たれた接続を示すネットワークハンドルを得ます。<br>
                    　接続を絶たれたマシンと再び通信状態を確立するには再度
                    <a href="#R13N1"><b>ConnectNetWork関数</b></a>がどちらかが行う必要があります。<br><br><br>


                    <font color="#ff0000"><b>《注意》</b></font><br><br>

                    　この関数も<a href="#R13N10"><b>GetNewAcceptNetWork関数</b></a>同様、絶たれた接続の
                    ネットワークハンドルは一度しか通知されませんので注意してください。<br><br>
                    
                    　因みに、接続は絶たれてもこの関数での確認が出来るように接続データ
                    自体は生きているので、切断確認後<a href="#R13N2"><b>CloseNetWork関数</b></a>を使用して
                    明示的に接続処理を終了する必要があります。<br><br>

                    　さらに、自分で<a href="#R13N2"><b>CloseNetWork関数</b></a>を使用して切断した
                    接続はこの関数には引っかからないので心得ておいてください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N12">宣言</a></b></td><td><font color="#000088"><b>
                int GetNetWorkAcceptState( int NetHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>接続状態を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int NetHandle : 状態を得たい接続を示すネットワークハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０ : 接続されていない</td></tr>
            <tr><td width="100">　</td><td>１ : 接続されている<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N11"><b>GetLostNetWork関数</b></a>や<a href="#R13N10"><b>GetNewAcceptNetWork関数</b></a>
                    によって接続状態の変化情報は漏れなく得ることが出きるのですが、
                    ダイレクトに現在接続状態にあるのかどうかを知りたいときにこの
                    関数を使用します。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N13">宣言</a></b></td><td><font color="#000088"><b>
                int    GetNetWorkIP( int NetHandle , IPDATA *IpBuf ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>接続先のＩＰアドレスを得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>    int NetHandle : ＩＰアドレスを得たい接続を示すネットワークハンドル<br>
                    IPDATA *IpBuf : 取得したＩＰアドレスを保存する IPDATA 構造体のポインタ<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　接続してきた、又はしたマシンのＩＰアドレスを得ます。<br>
                    　主に接続された側は、接続してきた側のマシンのＩＰアドレスはわから
                    ないので、接続してきた側のＩＰアドレスを得るために使用します。<br>
                    　使用目的としては、接続された側が、何らかの形で接続が絶たれてしまった
                    ときに接続された側から再度接続を試みる際に必要なＩＰアドレスを取得
                    する場合等で使用します。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N1"><b>ConnectNetWork関数</b></a>のサンプルを参照して下さい。<br>
            <br><br><br><br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N14">宣言</a></b></td><td><font color="#000088"><b>int MakeUDPSocket( int RecvPort )</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ＵＤＰを使用して通信するためのソケットを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                    int RecvPort : 受信に使用するポート番号<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：ＵＤＰ通信用のソケットハンドル(int型の識別値)</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　送受信が高速なＵＤＰを使用してデータ通信を行うためのソケットハンドルを作成します。<br>
                    　戻り値の「ＵＤＰ通信用のソケットハンドル」を使用してデータの送受信を行いますので、
                    戻り値は変数などに保存するようにしてください。<br><br>

                    　<a href="#R13N1"><b>ConnectNetWork</b></a> 関数で作成するネットハンドルは通信品質の高い代わりに通信速度の遅いＴＣＰを使用して通信を行いますが、
                    この MakeUDPSocket 関数を含め関数名に「UDP」が付いている関数は全て通信品質が低い代わりに通信速度が高速なＵＤＰを使用して通信を行うための関数です。<br><br>

                    　ConnectNetWork, <a href="#R13N5"><b>NetWorkSend</b></a>, <a href="#R13N8"><b>NetWorkRecv</b></a> 等の関数が使用するＴＣＰに対する、MakeUDPSocket, <a href="#R13N16"><b>NetWorkSendUDP</b></a>, <a href="#R13N17"><b>NetWorkRecvUDP</b></a> 等の関数が使用するＵＤＰとの違いは以下の通りです。<br><br><br>

                    ・「接続を確立する」という手順が無い<br><br>

                    　　ＵＤＰはデータを送信する度に送信先のＩＰとポート番号をしていするので、<br>
                    　接続を確立する、接続を解除する( 切断する )といったような「接続状態」<br>
                    　というものがありません。<br><br><br>

                    ・データが相手に届かないことがある<br><br>

                    　　ＴＣＰの場合は NetWorkSend で送信されたデータが何処かで無くなってしまった<br>
                    　場合は自動的に再送信する仕様になっているので、NetWorkSend したデータが<br>
                    　相手に届かないことがあることはあまり想定する必要はありませんが、ＵＤＰでは<br>
                    　そのような仕組みが無いので NetWorkSendUDP で送信したデータが必ず相手に<br>
                    　届かないことがあります。( その代わり早いです )<br><br><br>

                    ・データが順番通りに届かないことがある<br><br>

                    　　ＴＣＰの場合は NetWorkSend で送信したデータは、送信した順番通りに相手の<br>
                    　NetWorkRecv で取得できる受信データとして届きますが、ＵＤＰの場合は後から<br>
                    　NetWorkSendUDP で送信したデータが先に NetWorkSendUDP で送信したデータ<br>
                    　より早く相手に届く、ということがあります。<br><br><br>

                    ・一度に送信できる最大データサイズは 65507byte<br><br>

                    　　ＴＣＰを使用する NetWorkSend では基本的に一度に送信できるデータの<br>
                    　最大サイズに制限はありませんが、ＵＤＰを使用する NetWorkSendUDP<br>
                    　では一度に送信できるデータの最大サイズは 65507byte となります。<br>
                    　　ただ、ＵＤＰでは一度に送信するデータのサイズが大きくなれば<br>
                    　なるほど相手に届く確率が低くなるので、一般的にはこのサイズの<br>
                    　データを一度に送信することはありません。<br>
                    　( インターネットを介してデータの送受信を行う場合は、一度に送信する<br>
                    　データのサイズは 500byte 程度に抑えた方が良いです )<br><br><br>

                    ・データは送信時のサイズそのまま受信側に届く<br><br>

                    　　例えばＴＣＰを使用する NetWorkSend の場合 100byteのデータを<br>
                    　２回に分けて送信しても、受信側では一回の NetWorkRecv で 200byteの<br>
                    　データを受信することがありますが、ＵＤＰを使用する NetWorkSendUDP で<br>
                    　同じことをした場合は必ず NetWorkRecvUDP 側では 100byteづつ取得する<br>
                    　ことになります。<br>
                    　　この点はＴＣＰより扱いやすいかもしれません。<br><br><br>

                    　以上のように制限が多いですが、
                    基本的に対戦格闘ゲームのオンライン対戦のようなリアルタイム性の高いゲームの通信対戦では必ずＵＤＰを使うことになりますので( ＴＣＰでは速度が追いつかない )、
                    そのような通信対戦機能をソフトに搭載したい場合は何とか使いこなす必要があります。<br><br>

                    　引数で指定するポート番号はデータを受信するポート番号となります。<br>
                    ＵＤＰではデータを送信する関数 NetWorkSendUDP でその都度送信先のＩＰとポート番号を指定しますので、
                    RecvPort に -1 を渡すことで送信専用のソケットにすることができます。<br>
                    　尚、<font color="#880000"><b>一つのマシンではソフトが違っても同じポート番号を持つソケットを同時に複数作成・保持することはできませんので注意してください</b></font>。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　送信側は『メッセージ！！』という文字列を送り、受信側は送られてきた文字列を画面に表示します。<br><br>
            <hr>
<pre><div class="NormalFont">-- 送信側プログラム
-----------------------------------
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    IPDATA Ip ;        // 送信用ＩＰアドレスデータ
    int NetUDPHandle ;        // ネットワークハンドル

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // ＵＤＰ通信用のソケットハンドルを作成
    NetUDPHandle = MakeUDPSocket( -1 ) ;

    // ＩＰアドレスを設定( ここにある４つのＩＰ値は仮です )
    Ip.d1 = 192 ;
    Ip.d2 = 168 ;
    Ip.d3 = 0 ;
    Ip.d4 = 14 ;

    // 文字列の送信
    NetWorkSendUDP( NetUDPHandle, Ip, 9850, "メッセージ！！", 15 ) ;

    // 送信したよと表示
    DrawString( 0, 0, "文字列を送信しました、何かキーを押すと終了します", GetColor( 255,255,255 ) ) ;

    // キー入力待ち
    WaitKey() ;

    // ＵＤＰソケットハンドルの削除
    DeleteUDPSocket( NetUDPHandle ) ; 

    DxLib_End() ;    // ＤＸライブラリ使用の終了処理

    return 0 ;    // ソフトの終了
}

-- 受信側プログラム
-----------------------------------
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    char StrBuf[ 256 ] ;    // データバッファ
    int NetUDPHandle ;        // ネットワークハンドル

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // ＵＤＰ通信用のソケットハンドルを作成
    NetUDPHandle = MakeUDPSocket( 9850 ) ;

    // 受信待ちだよと表示
    DrawString( 0, 0, "受信待ち", GetColor( 255,255,255 ) ) ;

    // 文字列の受信を待つ
    while( CheckNetWorkRecvUDP( NetUDPHandle ) == FALSE )
    {
        // ウインドウズメッセージ処理
        if( ProcessMessage() &lt; 0 ) break ;
    }

    // 受信
    NetWorkRecvUDP( NetUDPHandle, NULL, NULL, StrBuf, 256, FALSE ) ;

    // 受信した文字列を画面に描画
    ClearDrawScreen() ;
    DrawString( 0, 0, StrBuf, GetColor( 255,255,255 ) ) ;

    // キー入力待ち
    WaitKey() ;

    // ＵＤＰソケットハンドルの削除
    DeleteUDPSocket( NetUDPHandle ) ; 

    DxLib_End() ;    // ＤＸライブラリ使用の終了処理

    return 0 ;    // ソフトの終了
}
</div></pre>
            <hr>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N15">宣言</a></b></td><td><font color="#000088"><b>
                int DeleteUDPSocket( int NetUDPHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ＵＤＰを使用して通信するためのソケットを削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int NetUDPHandle : ＵＤＰを使用して通信するためのソケットハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N14"><b>MakeUDPSocket関数</b></a>で作成したＵＤＰを使用した通信を行うためのソケットハンドルを削除します。<br>
                    　ＵＤＰを使用したデータ送受信についての説明は<a href="#R13N14"><b>MakeUDPSocket関数</b></a>の解説を参照してください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N14"><b>MakeUDPSocket関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N16">宣言</a></b></td><td><font color="#000088"><b>
                int NetWorkSendUDP( int NetUDPHandle, IPDATA SendIP, int SendPort, void *Buffer, int Length ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ＵＤＰを使用して他のマシンにデータを送信する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                    int NetUDPHandle : データ送信に使用するＵＤＰソケットハンドル<br>
                    IPDATA SendIP : 送信先のＩＰ<br>
                    int SendPort : 送信先のポート番号<br>
                    void *Buffer : 送信するデータがあるアドレス<br>
                    int Length : 送信するデータのサイズ(バイト単位)<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：送信したデータのサイズ</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生</td></tr>
            <tr><td width="100">　</td><td>－２：エラー（送信データのサイズが大きすぎる）</td></tr>
            <tr><td width="100">　</td><td>－３：エラー（送信準備が完了していない）<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N14"><b>MakeUDPSocket関数</b></a>で作成したＵＤＰによるデータ送受信用のソケットハンドルを使用して指定のＩＰに
                    Buffer の示すアドレスから Length のバイト数分だけデータを送信します。<br><br>

                    　<a href="#R13N14"><b>MakeUDPSocket関数</b></a> の解説にもありますが、
                    一度に送信できるデータのサイズは最大で 65507byte ですが、
                    一度に送信するデータのサイズが大きくなればなるほど相手に届く確率が下がりますので、
                    なるべくなら500byte以内にしてください。( 尚、LANなど信頼性の高い通信環境の場合はもっと大きくても大丈夫だと思います )<br><br>

                    　戻り値は、０以上の場合は送信できたサイズです、－２の場合は送信データが大きすぎるというエラーです、
                    －３の場合は送信準備が完了していない場合に返ってきます、間隔を空けずに NetWorkSendUDP を使用した場合や、
                    送信先のＩＰが有効ではない場合に返ってきます。<br><br>

                    　エラーが発生した場合はデータは１バイトも送信されませんので、再度送信するようにしてください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N14"><b>MakeUDPSocket関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N17">宣言</a></b></td><td><font color="#000088"><b>
                int NetWorkRecvUDP( int NetUDPHandle, IPDATA *RecvIP, int *RecvPort, void *Buffer, int Length, int Peek ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ＵＤＰを使用して他のマシンからのデータを受信する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                    int NetUDPHandle : データ受信に使用するＵＤＰソケットハンドル<br>
                    IPDATA *RecvIP : 送信側のＩＰアドレスを格納するための IPDATA 構造体のアドレス<br>
                    int *RecvPort : 送信側が指定したポート番号を格納するための int型変数のアドレス<br>
                    void *Buffer　: 受信データを格納するためのバッファへのアドレス<br>
                    int Length　　: 受信データを格納するためのバッファのサイズ(バイト単位)<br>
                    int Peek　　　: 受信データをキューから削除するかどうかのフラグ<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：受信データのサイズ</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生</td></tr>
            <tr><td width="100">　</td><td>－２：エラー発生（受信データよりバッファのサイズの方が小さい）</td></tr>
            <tr><td width="100">　</td><td>－３：エラー発生（受信データが無い）<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N14"><b>MakeUDPSocket関数</b></a>で作成したＵＤＰによるデータ送受信用のソケットハンドルを使用して
                    MakeUDPSocket 関数を呼び出す際に RecvPort で指定したポート番号に送られてきたデータを Buffer が示すアドレスに受信します。<br><br>

                    　受信に成功した場合の受信データのサイズは必ず NetWorkSendUDP で指定した送信サイズと等しくなります。<br>
                    　関数が成功すると通常受信データは受信データキューから削除されますが、
                    引数 Peek を TRUE にすると受信データがキューにそのまま残ります。
                    この場合、次に NetWorkRecvUDP を呼んだ場合も前回と同じデータを取得することになります。<br><br>

                    　戻り値は、０以上の場合は受信データのサイズです、この値は必ず NetWorkSendUDP で指定した送信サイズと等しくなります 、
                    －２は受信データが引数 Length で指定された受信データ格納用のバッファより大きかったときに返ってきます
                    <a href="#R13N8"><b>NetWorkRecv</b></a>関数とは違い受信データより大きなサイズのバッファを指定してもエラーにはなりませんので、
                    受信予定のデータのサイズより十分大きなバッファを用意してください、－３は受信データが無かった場合に返ってきます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N14"><b>MakeUDPSocket関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N18">宣言</a></b></td><td><font color="#000088"><b>
                int CheckNetWorkRecvUDP( int NetUDPHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ＵＤＰを使用した他のマシンから受信データがあるかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                    int NetUDPHandle : チェックするＵＤＰソケットハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：受信データがある　FALSE：受信データはない</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R13N14"><b>MakeUDPSocket関数</b></a>で作成したＵＤＰによるデータ送受信用のソケットハンドルを使用して
                    MakeUDPSocket 関数を呼び出す際に RecvPort で指定したポート番号に送られてきたデータが存在するかどうかを取得するための関数です。<br><br>

                    　受信データがある場合は TRUE が、無い場合は FALSE が返ります。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R13N14"><b>MakeUDPSocket関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
            <br><br><br>
        </td></tr>










        <tr><td><font size="3" color="#005500"><b>ファイル読み込み関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="750"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N1">宣言</a></b></td><td><font color="#000088"><b>int FileRead_open( char *FilePath, int ASync ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルを開く<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>
                char *FilePath : 開くファイルのパス<br>
                int ASync ： 非同期読み込みを行うかどうか<br>
                　　　　　　( TRUE：非同期読み込み　FALSE：同期読み込み( デフォルト ) )<br><br>
                </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以外：ファイルハンドル</td></tr>
            <tr><td width="100">　</td><td>０：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　FilePath で指定したファイルを開きます。<br>
                　関数が成功すると戻り値として得られるファイルハンドルを使用してファイルの読み込み操作を行います。<br>
                　ファイルの読み込み操作が終わったら<a href="#R19N3"><b>FileRead_close関数</b></a>でファイルを閉じる必要があります。<br><br>

                　この関数は <a href="#R21N1"><b>SetUseASyncLoadFlag</b></a> 関数で非同期読み込みに設定にすると、非同期で行うことができます。<br>
                　ファイルを開く処理が完了したかどうかは <a href="#R21N2"><b>CheckHandleASyncLoad</b></a> で確認することができます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　test.cpp を開いて、一行読んで画面に描画します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int FileHandle ;
    char String[256] ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() == -1 ) return -1 ;

    // test.cpp ファイルを開く
    FileHandle = FileRead_open( "test.cpp" ) ;

    // 一行読む
    FileRead_gets( String, 256, FileHandle ) ;

    // 画面に描画
    DrawString( 0, 0, String, GetColor( 255,255,255 ) ) ;

    // キー入力を待つ
    WaitKey() ;

    // ファイルを閉じる
    FileRead_close( FileHandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N2">宣言</a></b></td><td><font color="#000088"><b>LONGLONG FileRead_size( char *FilePath ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルのサイズを得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>char *FilePath : ファイルサイズを得るファイルのパス<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１以外：ファイルのサイズ</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　FilePath で指定したファイルのサイズをバイト単位で得ます<br><br></td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　<a href="#R19N6"><b>FileRead_read関数</b></a>のサンプルを参照してください。<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N3">宣言</a></b></td><td><font color="#000088"><b>int FileRead_close( int FileHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルを閉じる<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int FileHandle : 閉じるファイルハンドル<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R19N1"><b>FileRead_open関数</b></a>で開いたファイルを閉じます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　<a href="#R19N1"><b>FileRead_open関数</b></a>のサンプルを参照して下さい。<br>
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N4">宣言</a></b></td><td><font color="#000088"><b>LONGLONG FileRead_tell( int FileHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルポインタの位置を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int FileHandle : ファイルハンドル<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R19N1"><b>FileRead_open関数</b></a>で開いたファイルの現在のファイルポインタの位置をバイト単位で得ます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            ありません
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N5">宣言</a></b></td><td><font color="#000088"><b>int FileRead_seek( int FileHandle, LONGLONG Offset, int Origin ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルポインタの位置を変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int FileHandle : ファイルハンドル<br>
                LONGLONG Offset : Origin からのバイト数<br>
                int Origin : 初期位置<br>
                　　　　　　　SEEK_SET=ファイルの先頭<br>
                　　　　　　　SEEK_CUR=現在のファイルポインタの位置<br>
                　　　　　　　SEEK_END=ファイルの終端<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R19N1"><b>FileRead_open関数</b></a>で開いたファイルの現在のファイルポインタの位置を変更します。<br>
                　Origin で指定した初期位置からの相対位置を Offset で指定します。
                (例えば Origin を SEEK_END にして、Offset を -10 にすればファイルの終端から１０バイト戻った位置を指定したことになります)<br><br>

                　この関数は <a href="#R21N1"><b>SetUseASyncLoadFlag</b></a> 関数で非同期読み込みに設定にすると、非同期で行うことができます。<br>
                　ファイルポインタの位置変更が完了したかどうかは <a href="#R21N2"><b>CheckHandleASyncLoad</b></a> で確認することができます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            test.cpp の１１バイト目から一行読み込み描画する。
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int FileHandle ;
    char String[256] ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() == -1 ) return -1 ;

    // test.cpp ファイルを開く
    FileHandle = FileRead_open( "test.cpp" ) ;

    // １１バイト目までファイルポインタを移動する
    FileRead_seek( FileHandle, 11, SEEK_SET ) ;

    // 一行読む
    FileRead_gets( String, 256, FileHandle ) ;

    // 画面に描画
    DrawString( 0, 0, String, GetColor( 255,255,255 ) ) ;

    // キー入力を待つ
    WaitKey() ;

    // ファイルを閉じる
    FileRead_close( FileHandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N6">宣言</a></b></td><td><font color="#000088"><b>int FileRead_read( void *Buffer, int ReadSize, int FileHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルからデータを読み込む<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>void *Buffer : データを読み込むバッファの先頭アドレス<br>
                int ReadSize : 読み出すサイズ(バイト数)<br>
                int FileHandle : ファイルハンドル<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１以外：読み出したサイズ</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R19N1"><b>FileRead_open関数</b></a>で開いたファイルからデータを読み込みます。<br>
                　主にバイナリデータを読み出す用途で使用します。<br><br>

                　この関数は <a href="#R21N1"><b>SetUseASyncLoadFlag</b></a> 関数で非同期読み込みに設定にすると、非同期で行うことができます。<br>
                　データの読み込みが完了したかどうかは <a href="#R21N2"><b>CheckHandleASyncLoad</b></a> で確認することができます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            test1.bmp を丸ごとメモリに読み込んで、グラフィックハンドルを作成して描画する。
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"
#include &lt;malloc.h&gt;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    void *Buffer ;
    int FileSize, FileHandle, GrHandle ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() == -1 ) return -1 ;

    // ファイルのサイズを得る
    FileSize = FileRead_size( "test1.bmp" ) ;

    // ファイルを格納するメモリ領域の確保
    Buffer = malloc( FileSize ) ;

    // test1.bmp を開く
    FileHandle = FileRead_open( "test1.bmp" ) ;

    // ファイルを丸ごとメモリに読み込む
    FileRead_read( Buffer, FileSize, FileHandle ) ;

    // ファイルを閉じる
    FileRead_close( FileHandle ) ;

    // グラフィックハンドルの作成
    GrHandle = <a href="#R15N26"><b>CreateGraphFromMem</b></a>( Buffer, FileSize ) ;

    // メモリの解放
    free( Buffer ) ;

    // 画面に描画
    DrawGraph( 0, 0, GrHandle, TRUE ) ; 

    // グラフィックハンドルの削除
    DeleteGraph( GrHandle ) ;

    // キー入力待ち
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N7">宣言</a></b></td><td><font color="#000088"><b>int FileRead_eof( int FileHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルの終端かどうかを調べる<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int FileHandle : ファイルハンドル<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：ファイルの終端ではない</td></tr>
            <tr><td width="100">　</td><td>０以外：ファイルの終端<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R19N1"><b>FileRead_open関数</b></a>で開いたファイルのファイルポインタが終端に達しているかどうかを調べたい時に使用します。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　test.cpp をファイルの終端に達するまで一行読み込み、描画を繰り返す
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    char String[256] ;
    int FileHandle, y ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() == -1 ) return -1 ;

    // test.cpp を開く
    FileHandle = FileRead_open( "test.cpp" ) ;

    // 表示Ｙ座標の初期化
    y = 0 ;

    // ファイルの終端が来るまで表示する
    while( FileRead_eof( FileHandle ) == 0 )
    {
        // 一行読み込み
        FileRead_gets( String, 256, FileHandle ) ;

        // 画面に描画
        DrawString( 0, y, String, GetColor( 255,255,255 ) ) ;

        // 表示Ｙ座標を下にずらす
        y += 16 ;
    }

    // ファイルを閉じる
    FileRead_close( FileHandle ) ;

    // キー入力待ち
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N8">宣言</a></b></td><td><font color="#000088"><b>int FileRead_gets( char *Buffer, int Num, int FileHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルから一行読み出す<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>char *Buffer : 読み出した文字列を格納するメモリ領域の先頭アドレス<br>
                int Num : 文字列を格納するメモリ領域のサイズ<br>
                int FileHandle : ファイルハンドル<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１以外：読み出した文字列の長さ</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R19N1"><b>FileRead_open関数</b></a>で開いたファイルから文字列を一行読み込みます。<br>
                　改行があるか、ファイルの終端に達するか、Num で指定されたサイズ－１バイト分の文字列があった所までの文字列を Buffer に格納します。<br>
                (文字列の終端にはヌル文字(\0)が格納されるので、最大でも Num で指定されたサイズ－１バイト分となります)<br>
                　読み込み後のファイルポインタは、改行があった場合は次の行の先頭、ファイルの終端に達した場合はファイルの終端、Num
                で指定されたサイズを超えたために読み込み終了となった場合は、
                読み込んだ最後の文字の次の文字となります。<br>
                (読み込んだ最後の文字の次が改行コードの場合は、次の FileRead_gets では Buffer にヌル文字(\0)のみ格納されることになります)<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　<b><a href="#R19N1">FileRead_open関数</a></b>のサンプルを参照してください。
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N9">宣言</a></b></td><td><font color="#000088"><b>int FileRead_getc( int FileHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルから一文字読み出す<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int FileHandle : ファイルハンドル<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１以外：読み出した文字コード</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R19N1"><b>FileRead_open関数</b></a>で開いたファイルから一文字読み込みます。<br>
                　正常に読み込めるのは１バイト文字だけで、一文字２バイトの全角文字などは正常に読み込めません。(１バイト目だけが返ってきます)<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　ありません<br>
            <br><br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N10">宣言</a></b></td><td><font color="#000088"><b>int FileRead_scanf( int FileHandle , char *Format , ... ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ファイルから書式付きデータを読み出す<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int FileHandle : ファイルハンドル<br>
                char *Format : 書式制御文字列<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１以外：読み出した文字数</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R19N1"><b>FileRead_open関数</b></a>で開いたファイルから書式付きで文字列を読み込みます。<br>
                　Ｃ言語標準ライブラリの fscanf と同等の機能を FileRead_ 系の関数に実装したものですので、
                書式制御文字列についてはＣ言語の書籍や解説サイトをご参照ください。(すいません、説明が大変なんです・・・orz)<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　ありません<br>
            <br><br><br><br><br>
        </td></tr>

        <tr><td><font size="3" color="#005500"><b>ドット単位で画像にアクセスしたい関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N1">宣言</a></b></td><td><font color="#000088"><b>int LoadSoftImage( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの読み込み<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>char *FileName : 読み込むファイルのパス<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　たまに <a href="dxfunc_graph1.html#R3N2"><b>LoadGraph</b></a> で読み込んだ画像をドット単位でアクセスしたい、ということがあると思います。<br>
                　画像をマップデータの代わりに使うとか、格闘ゲームでパレットだけいじって２Ｐキャラ用にしたい、など。<br>
                　ですが LoadGraph で読み込まれた画像は描画に適した形式に変換され、読み込みアクセスが低速なＶＲＡＭへと転送されているので内容を参照したりいじったりということに向いていません。<br><br>

                　また、オリジナルの画像データ形式で画像を管理したい、ということもあるとおもいます。<br>
                　ですがＤＸライブラリで読み込むには LoadGraph で対応している画像形式にする必要がある・・・なんとかならないかぁと・・・<br><br>

                　そこで登場するのが LoadSoftImage で LoadGraph 感覚で読み込んで作成するソフトウエアイメージハンドルです。<br>
                　この関数で読み込まれた画像はグラフィックハンドルの様に <a href="dxfunc_graph1.html#R3N7"><b>DrawGraph</b></a> や <a href="dxfunc_graph1.html#R3N10"><b>DrawRotaGraph</b></a> 等の描画関数を使って描画することはできませんが、
                代わりに画像内容を参照したり書き換えたりする機能と、編集したソフトウエアイメージハンドルからグラフィックハンドルを作成する機能を備えています。<br>
                　なので、主に画像を描画目的以外で使用したいとき、パレットだけいじってグラフィックハンドルを作成したいとき、
                独自の画像形式のデータをＤＸライブラリで使用したいときなどに有効です。<br><br>

                　具体的な使い方としては LoadSoftImage 関数でソフトウェアイメージハンドルを作成し、<a href="#R20N13"><b>GetPixelSoftImage</b></a> 関数でドットの色を取得したり、
                <a href="#R20N12"><b>DrawPixelSoftImage</b></a> 関数でドットを書き込んだりします。<br>
                　LoadSoftImage で読み込んだ画像がパレット画像の場合は <a href="#R20N8"><b>GetPaletteSoftImage</b></a> 関数でパレットを参照したり、<a href="#R20N9"><b>SetPaletteSoftImage</b></a> 関数でパレットを変更したりすることも可能です。<br>
                　その後、編集した画像をグラフィックハンドルにしたい場合は <a href="#R20N16"><b>CreateGraphFromSoftImage</b></a> 関数や <a href="#R20N17"><b>CreateDivGraphFromSoftImage</b></a> 関数でグラフィックハンドルにする、という感じです。<br><br>

                　なお、ソフトウエアイメージハンドルは LoadGraph で読み込むグラフィックハンドルと異なり DxLib_End
                を実行しても自動的に解放されることはありませんので、使用後は必ず <a href="#R20N5"><b>DeleteSoftImage</b></a> 関数でハンドルを削除するようにしてください。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　test.bmp をソフトウエアイメージハンドルとして読み込んで１ドット毎に DrawBox を使って描画する
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int handle, i, j, w, h, r, g, b, a ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 画像の読み込み
    handle = LoadSoftImage( "Test1.bmp" ) ;

    // 画像のサイズを取得
    GetSoftImageSize( handle, &amp;w, &amp;h ) ;

    // 画像の色を１ドットづつ参照して DrawBox で３倍の大きさにして描画
    for( i = 0; i &lt; h; i ++ )
    {
        for( j = 0; j &lt; w; j ++ )
        {
            // １ドットの色を取得
            GetPixelSoftImage( handle, j, i, &amp;r, &amp;g, &amp;b, &amp;a ) ;

            // DrawBox で描画
            DrawBox( j * 3, i * 3, j * 3 + 3, i * 3 + 3, GetColor( r, g, b ), TRUE ) ;
        }
    }

    // 使い終わったら解放
    DeleteSoftImage( handle ) ;

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="1100"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N20">宣言</a></b></td><td><font color="#000088"><b>int LoadARGB8ColorSoftImage( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの読み込み( RGBA8 カラーに変換 )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>char *FileName : 読み込むファイルのパス<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> の補助関数です。<br>
                　LoadSoftImage で画像を読み込んで戻り値として得られるソフトウェアイメージハンドルの画像の形式は、
                読み込んだ画像の形式に合わせて『アルファチャンネル付きの 32ビット画像( ARGB8 )』だったり、『アルファチャンネル無しの 24ビット画像( RGB8 )』だったり、『パレット２５６色形式画像( PAL8 )』だったりと様々です。<br>
                　なので、例えば『アルファチャンネル無しの 24bit画像( RGB8 )』の画像を LoadSoftImage で読み込んで得たソフトウェアイメージハンドルに対して <a href="#R20N12"><b>DrawPixelSoftImage</b></a>
                などの関数で画像データに R, G, B の値と共にアルファ値の値も書き込みたいと思っても、ソフトウェアイメージハンドルが持つ画像にアルファ値の情報が無い( RGB8形式なので )のでアルファ値を書き込めません。<br><br>

                　このような場合は LoadSoftImage で得るソフトウェアイメージハンドルとは別に関数 <a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> を使用してアルファチャンネル付きのソフトウェアハンドルを作成し、
                そのソフトウェアハンドルに <a href="#R20N14"><b>BltSoftImage</b></a> を使用して LoadSoftImage で読み込んだ画像を転送した上で DrawPixelSoftImage などの関数でアルファ値を書き込む、といったことをする必要があります。<br><br>

                　ただ、その場合<br><br>

                　　１．LoadSoftImage で画像ファイルを読み込み<br><br>
                　　２．<a href="#R20N6"><b>GetSoftImageSize</b></a> で画像のサイズを取得<br><br>
                　　３．MakeARGB8ColorSoftImage で １ で読み込んだ画像と同じサイズの ARGB8形式のソフトウェアイメージハンドルを作成<br><br>
                　　４．BltSoftImage で １ で読み込んだ画像を ３ で作成したソフトウェアイメージハンドルに転送<br><br>
                　　５．１ で読み込んだ画像のソフトウェアイメージハンドルは不要になったので、<a href="#R20N5"><b>DeleteSoftImage</b></a> で削除<br><br>
                　　６．３ で作成したソフトウェアイメージハンドルに対して <a href="#R20N12"><b>DrawPixelSoftImage</b></a> などの関数で書き込む<br><br>

                　と、DrawPixelSoftImage で書き込みを行うまでの手順が多いので若干面倒です。<br>
                　それに対して LoadARGB8ColorSoftImage では上記の１から５までの手順( 読み込んだ画像を『アルファチャンネル付きの 32ビット画像( ARGB8 )』に変換する )を内部で行ってしまいます。<br>
                　なので、上記の手順を<br><br>

                　　１．LoadARGB8ColorSoftImage で画像ファイルを読み込む<br>
                　　　　( 得られるソフトウェアイメージハンドルの内容は必ず ARGB8形式になる )<br><br>
                　　２．１ で作成したソフトウェアイメージハンドルに対して DrawPixelSoftImage などの関数で書き込む<br><br>

                　と、大幅に短縮することができます。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　test.bmp を『アルファチャンネル付き32bit画像( ARGB8 )』のソフトウエアイメージハンドルとして読み込んで画像全体のアルファ値を 128 ( 不透明度50% )に書き換えてから画面に描画する
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int handle, i, j, w, h, r, g, b, a ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 画像を ARGB8 形式で読み込み
    handle = LoadARGB8ColorSoftImage( "Test1.bmp" ) ;

    // 画像のサイズを取得
    GetSoftImageSize( handle, &amp;w, &amp;h ) ;

    // 画像の全ピクセルのアルファ値を 128 にする
    for( i = 0; i &lt; h; i ++ )
    {
        for( j = 0; j &lt; w; j ++ )
        {
            // １ドットの色を取得
            GetPixelSoftImage( handle, j, i, &amp;r, &amp;g, &amp;b, &amp;a ) ;

            // アルファ値を 128 にして書き込み
            DrawPixelSoftImage( handle, j, i, r, g, b, 128 ) ;
        }
    }

    // 画面に画像を描画
    DrawSoftImage( 0, 0, handle ) ;

    // 使い終わったら解放
    DeleteSoftImage( handle ) ;

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N21">宣言</a></b></td><td><font color="#000088"><b>int LoadXRGB8ColorSoftImage( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの読み込み( XGBA8 カラーに変換 )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>char *FileName : 読み込むファイルのパス<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N20"><b>LoadARGB8ColorSoftImage</b></a> の画像フォーマットが『アルファチャンネル無し 32bit画像( XRGB8 )』になっただけの関数です。<br>
		　読み込んだ画像を内部で『アルファチャンネル無し 32bit画像( XRGB8 )』に変換します。<br>
                </td>
            </tr>
        </table></td></tr>

         <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R20N20"><b>LoadARGB8ColorSoftImage関数</b></a>のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N2">宣言</a></b></td><td><font color="#000088"><b>int LoadSoftImageToMem( void *FileImage, int FileImageSize ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージのメモリからの読み込み<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>void *FileImage : ファイルイメージの先頭アドレス<br>
                    int FileImageSize : ファイルイメージのサイズ<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> は画像ファイルからソフトウエアイメージハンドルを作成しますが、
                仮に暗号化された状態でファイルを保存していて、メモリに読み込んでから暗号化を解除した、ということもソフトウエア開発に慣れた方ならあると思います。<br>
                　そんなときは暗号化解除した画像ファイルを一々ファイルに書き出して LoadSoftImage で読み込む、というのは無駄なので、この関数で読み込むことになります。<br>
                　引数の FileImage は画像ファイルイメージが格納されたメモリ領域の先頭アドレスを、FileImageSize は格納されているファイルイメージのサイズを渡します。<br>
                　まあ、対応している画像形式は LoadGraph で読み込める画像形式と一緒ですので、独自の暗号化をされる方がこの関数を使うことは無いかもしれませんが一応・・・<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　test.bmp をメモリに読み込んで LoadSoftImageToMem でソフトウエアイメージハンドルとして読み込んでみる
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int handle, i, j, w, h, r, g, b, a, fhandle ;
    void *image ;
    int image_size ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 画像ファイルを丸ごとメモリに読み込む
    fhandle = FileRead_open( "test1.bmp" ) ;
    image_size = FileRead_size( "test1.bmp" ) ;
    image = malloc( image_size ) ;
    FileRead_read( image, image_size, fhandle ) ;
    FileRead_close( fhandle ) ;

    // LoadSoftImageToMem で読み込む
    handle = LoadSoftImageToMem( image, image_size ) ;

    // 読み込んでしまった後はファイルイメージは必要なし
    free( image ) ;

    // 画像のサイズを取得
    GetSoftImageSize( handle, &amp;w, &amp;h ) ;

    // 画像の色を１ドットづつ参照して DrawBox で３倍の大きさにして描画
    for( i = 0; i &lt; h; i ++ )
    {
        for( j = 0; j &lt; w; j ++ )
        {
            // １ドットの色を取得
            GetPixelSoftImage( handle, j, i, &amp;r, &amp;g, &amp;b, &amp;a ) ;

            // DrawBox で描画
            DrawBox( j * 3, i * 3, j * 3 + 3, i * 3 + 3, GetColor( r, g, b ), TRUE ) ;
        }
    }

    // 使い終わったら解放
    DeleteSoftImage( handle ) ;

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N22">宣言</a></b></td><td><font color="#000088"><b>int LoadARGB8ColorSoftImageToMem( void *FileImage, int FileImageSize ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージのメモリからの読み込み( ARGB8 カラーに変換 )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>void *FileImage : ファイルイメージの先頭アドレス<br>
                    int FileImageSize : ファイルイメージのサイズ<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N20"><b>LoadARGB8ColorSoftImage</b></a> のメモリに展開されたファイルのイメージから読み込むバージョンです。<br>
		　メモリに展開されたファイルのイメージから読み込む処理については <a href="#R20N2"><b>LoadSoftImageToMem</b></a> の解説を、内部で特定のカラーに変換する処理については <a href="#R20N20"><b>LoadARGB8ColorSoftImage</b></a> の解説を参照してください。<br>
                </td>
            </tr>
        </table></td></tr>

         <tr><td>
            <b>サンプル</b><br><br>

                　メモリに展開されたファイルのイメージから読み込む処理については <a href="#R20N2"><b>LoadSoftImageToMem</b></a> のサンプルを、内部で特定のカラーに変換する処理については <a href="#R20N20"><b>LoadARGB8ColorSoftImage</b></a> のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N23">宣言</a></b></td><td><font color="#000088"><b>int LoadXRGB8ColorSoftImageToMem( void *FileImage, int FileImageSize ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージのメモリからの読み込み( XRGB8 カラーに変換 )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>void *FileImage : ファイルイメージの先頭アドレス<br>
                    int FileImageSize : ファイルイメージのサイズ<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N21"><b>LoadXRGB8ColorSoftImage</b></a> のメモリに展開されたファイルのイメージから読み込むバージョンです。<br>
		　メモリに展開されたファイルのイメージから読み込む処理については <a href="#R20N2"><b>LoadSoftImageToMem</b></a> の解説を、内部で特定のカラーに変換する処理については <a href="#R20N20"><b>LoadARGB8ColorSoftImage</b></a> の解説を参照してください。<br>
                </td>
            </tr>
        </table></td></tr>

         <tr><td>
            <b>サンプル</b><br><br>

                　メモリに展開されたファイルのイメージから読み込む処理については <a href="#R20N2"><b>LoadSoftImageToMem</b></a> のサンプルを、内部で特定のカラーに変換する処理については <a href="#R20N20"><b>LoadARGB8ColorSoftImage</b></a> のサンプルを参照して下さい<br>
            <br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N3">宣言</a></b></td><td><font color="#000088"><b>int MakeARGB8ColorSoftImage( int SizeX, int SizeY ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの作成( RGBA8 カラー )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SizeX : 作成する画像の横幅<br>
                    int SizeY : 作成する画像の縦幅<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　この関数や <a href="#R20N4"><b>MakePAL8ColorSoftImage</b></a> 関数、 <a href="#R20N18"><b>MakeXRGB8ColorSoftImage</b></a> 関数は何も書かれていないソフトウエアイメージハンドルを作成します。<br>
                　主にソフトウエアイメージハンドルの機能を使って独自の画像フォーマットのイメージデータをＤＸライブラリで使用したい場合や、
                プログラムで動的に画像を作成して使いたいときに、この関数で作成したソフトウエアイメージハンドルに対して <a href="#R20N12"><b>DrawPixelSoftImage</b></a> 関数で描画を行い、
                 <a href="#R20N16"><b>CreateGraphFromSoftImage</b></a> 関数でグラフィックハンドルにする、というような使い方をします。<br><br>

                 　この MakeARGB8ColorSoftImage 関数は、透明情報(アルファチャンネル)つきのフルカラー画像を作成する関数で、
                 <a href="#R20N4"><b>MakePAL8ColorSoftImage</b></a> 関数は２５６色のパレット画像を作成する関数、
                 <a href="#R20N4"><b>MakeXRGB8ColorSoftImage</b></a> 関数は透明情報なしのフルカラー画像を作成する関数となりますので、
                用途に応じて使い分けてください。<br>
                (アルファチャンネル付きの画像はアルファチャンネル無しの画像に比べて描画負荷が高くなりますので、
                １個の透過色で済む画像を作成する場合や、そもそも画像を一切透過させる必要が無い場合等は MakeXRGB8ColorSoftImage 関数で画像を作成するようにした方がお得です)
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　空のソフトウエアイメージハンドルを作成して、プログラムで透明なグラデーションの画像を作成して描画する
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int handle, i, j, grhandle ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 空のフルカラー画像を作成する
    handle = MakeARGB8ColorSoftImage( 256, 256 ) ;

    // 縦方向に透明グラデーションした真っ赤な画像を作成する
    for( i = 0; i &lt; 256; i ++ )
    {
        for( j = 0; j &lt; 256; j ++ )
        {
            // 色をセット
            DrawPixelSoftImage( handle, j, i, 255, 0, 0, i ) ;
        }
    }

    // 透明かどうかわかるように画面を緑で塗りつぶす
    DrawBox( 0, 0, 640, 480, GetColor( 0, 255, 0 ), TRUE ) ;

    // グラフィックハンドルを作成
    grhandle = CreateGraphFromSoftImage( handle ) ;

    // 使い終わったら解放
    DeleteSoftImage( handle ) ;

    // グラフィックハンドルを描画
    DrawGraph( 0, 0, grhandle, TRUE ) ;

    // グラフィックハンドルの削除
    DeleteGraph( grhandle ) ;

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N18">宣言</a></b></td><td><font color="#000088"><b>int MakeXRGB8ColorSoftImage( int SizeX, int SizeY ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの作成( RGBA8 カラー )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SizeX : 作成する画像の横幅<br>
                    int SizeY : 作成する画像の縦幅<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N4"><b>MakeARGB8ColorSoftImage</b></a> 関数と同様に空のソフトウエアイメージハンドルを作成するための関数です。<br>
                透明情報(アルファチャンネル)が必要ない場合にはこちらを使った方が、ソフトウエアイメージハンドルからグラフィックハンドルを作成した際に、
                作成したグラフィックハンドルの描画負荷が低くなります。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　空のソフトウエアイメージハンドルを作成して、プログラムで黒から赤になるグラデーションの画像を作成して描画する
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int handle, i, j, grhandle ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 空のフルカラー画像を作成する
    handle = MakeXRGB8ColorSoftImage( 256, 256 ) ;

    // 縦方向に黒から赤にグラデーションした画像を作成する
    for( i = 0; i &lt; 256; i ++ )
    {
        for( j = 0; j &lt; 256; j ++ )
        {
            // 色をセット
            DrawPixelSoftImage( handle, j, i, i, 0, 0, 0 ) ;
        }
    }

    // グラフィックハンドルを作成
    grhandle = CreateGraphFromSoftImage( handle ) ;

    // 使い終わったら解放
    DeleteSoftImage( handle ) ;

    // グラフィックハンドルを描画
    DrawGraph( 0, 0, grhandle, TRUE ) ;

    // グラフィックハンドルの削除
    DeleteGraph( grhandle ) ;

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N4">宣言</a></b></td><td><font color="#000088"><b>int MakePAL8ColorSoftImage( int SizeX, int SizeY ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの作成( RGBA8 カラー )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SizeX : 作成する画像の横幅<br>
                    int SizeY : 作成する画像の縦幅<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　－１：エラー</td></tr>
            <tr><td width="100">　</td><td>－１以外：ソフトウェアイメージハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N4"><b>MakeARGB8ColorSoftImage</b></a> 関数と同様に空のソフトウエアイメージハンドルを作成するための関数です。<br>
                　この関数は他の二つの空イメージ作成関数とは違い、パレット画像を作成する関数となっています。<br><br>

                　初期状態ではＲＧＢを満遍なく満たしたパレットとなっていますが、恐らくこの関数をお使いになる方は独自のパレットをご用意されると思いますので、
                <a href="#R20N9"><b>SetPaletteSoftImage</b></a> 関数でパレットを変更することになると思います。<br>
                　また、パレット画像に限り画像内容の参照・描画もＲＧＢＡ値の取得ではなくパレット番号の取得・描画の方が都合が良いことが多いので、
                ＲＧＢＡ値を指定・取得する <a href="#R20N12"><b>DrawPixelSoftImage</b></a> 関数や <a href="#R20N13"><b>GetPixelSoftImage</b></a>
                関数の代わりにパレット番号を指定・取得する <a href="#R20N12"><b>DrawPixelPalCodeSoftImage</b></a> 関数, <a href="#R20N13"><b>GetPixelPalCodeSoftImage</b></a> を使用することになると思います。<br>
                ( パレット画像で DrawPixelSoftImage が使用された場合は指定された色に最も近いパレット番号が書き込まれます、あと、現在パレット画像ではアルファ値は無視されます )<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　空のソフトウエアイメージハンドルを作成して、プログラムで黒から緑になるグラデーションの画像を作成して描画する
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int handle, i, j, grhandle ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 空のパレット画像を作成する
    handle = MakePAL8ColorSoftImage( 256, 256 ) ;

    // パレット０から２５５に掛けて緑色のグラデーションをセットする
    for( i = 0 ; i &lt; 256 ; i ++ )
        SetPaletteSoftImage( handle, i, 0, i, 0, 0 ) ;

    // 縦方向に黒から赤にグラデーションした画像を作成する
    for( i = 0; i &lt; 256; i ++ )
    {
        for( j = 0; j &lt; 256; j ++ )
        {
            // パレット番号をセット
            DrawPixelPalCodeSoftImage( handle, j, i, i ) ;
        }
    }

    // グラフィックハンドルを作成
    grhandle = CreateGraphFromSoftImage( handle ) ;

    // 使い終わったら解放
    DeleteSoftImage( handle ) ;

    // グラフィックハンドルを描画
    DrawGraph( 0, 0, grhandle, TRUE ) ;

    // グラフィックハンドルの削除
    DeleteGraph( grhandle ) ;

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N5">宣言</a></b></td><td><font color="#000088"><b>int DeleteSoftImage( int SIHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの解放<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : ソフトウエアイメージハンドル<br><br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N4"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルをメモリ上から解放するときに使用します。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N19">宣言</a></b></td><td><font color="#000088"><b>int InitSoftImage( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージを全て解放<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N4"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成した全てのソフトウエアイメージハンドルをメモリ上から解放するときに使用します。<br>
                　作成したソフトウエアイメージハンドル全部に <a href="#R20N5"><b>DeleteSoftImage</b></a> を実行するのと効果は同じです。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません。
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N6">宣言</a></b></td><td><font color="#000088"><b>int GetSoftImageSize( int SIHandle, int *Width, int *Height ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージのサイズを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle　:　サイズを調べるソフトウエアイメージハンドル<br>
                    int Width　　:　イメージの幅を保存するint型変数のアドレス<br>
                    int Height　　:　イメージの高さを保存するint型変数のアドレス</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N4"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルの幅と高さを取得するために使用します。<br>
                使い方は <a href="dxfunc_graph1.html#R3N13"><b>GetGraphSize</b></a> 関数と同じです。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N7">宣言</a></b></td><td><font color="#000088"><b>int FillSoftImage( int SIHandle, int r, int g, int b, int a ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージを指定色で塗りつぶす(各色要素は０～２５５)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : 指定色で塗りつぶすソフトウエアイメージハンドル<br>
                    int r : 塗りつぶす色の赤成分( ０～２５５ )<br>
                    int g : 塗りつぶす色の緑成分( ０～２５５ )<br>
                    int b : 塗りつぶす色の青成分( ０～２５５ )<br>
                    int a : 塗りつぶす色の透明度( ０～２５５ )<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N4"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルを指定の色で塗りつぶします。<br>
                　普通に考えて LoadSoftImage で読み込んだ画像を塗りつぶすということは無いと思いますので、主に MakeARGB8ColorSoftImage 関数などで作成した空イメージを初期化する場合に使用する、というのが主だと思います。<br>
                　ただ、空イメージを作成した場合も全ドットを埋める場合は使う必要がないという、謎の関数です。<br>
                　DrawLine や DrawBox に相当する関数がソフトウエアイメージハンドルには存在していないので、ふと初期化したいときに困るかもしれないから追加した代物だったりします。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N9">宣言</a></b></td><td><font color="#000088"><b>int SetPaletteSoftImage( int SIHandle, int PaletteNo, int r, int g, int b, int a ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージのパレットをセットする(各色要素は０～２５５)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : ソフトウエアイメージハンドル<br>
                    int PaletteNo : 色を変更するパレット番号<br>
                    int r : 変更後のパレットの赤成分( ０～２５５ )<br>
                    int g : 変更後のパレットの緑成分( ０～２５５ )<br>
                    int b : 変更後のパレットの青成分( ０～２５５ )<br>
                    int a : 0 を指定してください<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数で読み込んだパレット画像のソフトウエアイメージハンドルや、<a href="#R20N4"><b>MakePAL8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルが持つパレットの指定番号の色を変更します。<br>
                　各色成分の値は０から２５５です。今のところ a の値は何も意味が無いので、０を指定して下さい。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R20N1"><b>MakePAL8ColorSoftImage</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N8">宣言</a></b></td><td><font color="#000088"><b>int GetPaletteSoftImage( int SIHandle, int PaletteNo, int *r, int *g, int *b, int *a ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージのパレットを取得する(各色要素は０～２５５)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : ソフトウエアイメージハンドル<br>
                    int PaletteNo : 色を取得するパレット番号<br>
                    int *r : パレットの赤成分を保存する変数のアドレス<br>
                    int *g : パレットの緑成分を保存する変数のアドレス<br>
                    int *b : パレットの青成分を保存する変数のアドレス<br>
                    int *a : 0 を指定してください<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数で読み込んだパレット画像のソフトウエアイメージハンドルや、<a href="#R20N4"><b>MakePAL8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルが持つパレットの指定番号の色を取得します。<br>
                　各色成分の値は０から２５５です。今のところ a の値は何も意味が無いので、０を指定して下さい。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　パレット画像である Test1.bmp のパレットの一覧を１６ｘ１６マス使って表示する
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int handle, i, j, r, g, b ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 画像の読み込み
    handle = LoadSoftImage( "Test1.bmp" ) ;

    // パレットの一覧を描画
    for( i = 0 ; i &lt; 16 ; i ++ )
    {
        for( j = 0 ; j &lt; 16 ; j ++ )
        {
            // パレットの色を取得する
            GetPaletteSoftImage( handle, j + i * 16, &amp;r, &amp;g, &amp;b, 0 ) ;

            // DrawBox を使って描画
            DrawBox( j * 16, i * 16, j * 16 + 16, i * 16 + 16, GetColor( r, g, b ), TRUE ) ;
        }
    }

    // 使い終わったら解放
    DeleteSoftImage( handle ) ;

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N10">宣言</a></b></td><td><font color="#000088"><b>int DrawPixelPalCodeSoftImage( int SIHandle, int x, int y, int palNo ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの指定座標にドットを描画する(パレット画像用、有効値は０～２５５)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : ソフトウエアイメージハンドル<br>
                    int x, int y : 書き込む座標<br>
                    int palNo : 書き込むパレット番号<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数で読み込んだパレット画像のソフトウエアイメージハンドルや、<a href="#R20N4"><b>MakePAL8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルの指定の座標にパレット番号を書き込みます。<br>
                　パレット画像は各ドット０～２５５の値を持ちますので、渡せる値も０から２５５となります。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R20N1"><b>MakePAL8ColorSoftImage</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N11">宣言</a></b></td><td><font color="#000088"><b>int GetPixelPalCodeSoftImage( int SIHandle, int x, int y ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージのパレットを取得する(各色要素は０～２５５)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : ソフトウエアイメージハンドル<br>
                    int x, int y : パレット番号を取得する座標<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>パレット番号<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数で読み込んだパレット画像のソフトウエアイメージハンドルや、<a href="#R20N4"><b>MakePAL8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルの指定の座標のパレット番号を取得します。<br>
                　パレット画像は各ドット０～２５５の値を持ちますので、返ってくる値も０から２５５となります。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N12">宣言</a></b></td><td><font color="#000088"><b>int DrawPixelSoftImage( int SIHandle, int x, int y, int  r, int  g, int  b, int  a ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの指定座標にドットを描画する(各色要素は０～２５５)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : ソフトウエアイメージハンドル<br>
                    int x, int y : 色を書き込む座標<br>
                    int r : 書き込む色の赤成分( ０～２５５ )<br>
                    int g : 書き込む色の緑成分( ０～２５５ )<br>
                    int b : 書き込む色の青成分( ０～２５５ )<br>
                    int a : 書き込む色の透明度( ０～２５５ )<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルの指定の座標の色を変更します。<br>
                　赤・緑・青・透明度各成分の値は０～２５５です。透明情報の無い画像形式の場合は透明度は無視されます。書き込み対象がパレット画像の場合は指定された色に一番近いパレットの番号が書き込まれます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N13">宣言</a></b></td><td><font color="#000088"><b>int GetPixelSoftImage( int SIHandle, int x, int y, int *r, int *g, int *b, int *a ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージの指定座標の色を取得する(各色要素は０～２５５)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : ソフトウエアイメージハンドル<br>
                    int x, int y : 色を取得する座標<br>
                    int *r : 取得した色の赤成分を書き込む変数のアドレス<br>
                    int *g : 取得した色の緑成分を書き込む変数のアドレス<br>
                    int *b : 取得した色の青成分を書き込む変数のアドレス<br>
                    int *a : 取得した色の透明度を書き込む変数のアドレス<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルの指定の座標の色を取得します。<br>
                　赤・緑・青・透明度各成分の値は０～２５５です。透明情報の無い画像形式の場合の透明度は不定です。読み込み対象がパレット画像の場合は指定された座標のパレットの色が変数に代入されます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N14">宣言</a></b></td><td><font color="#000088"><b>int BltSoftImage( int SrcX, int SrcY, int SrcSizeX, int SrcSizeY, int SrcSIHandle, int DestX, int DestY, int DestSIHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージを別のイメージ上に転送する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SrcX, int SrcY : 転送元から転送する画像領域の左上座標<br>
                    int SrcSizeX, int SrcSizeY : 転送元から転送する画像領域の幅と高さ<br>
                    int SrcSIHandle : 転送元のソフトウエアイメージハンドル<br>
                    int DestX, int DestY : 転送元の画像を格納する転送先の座標<br>
                    int DestSIHandle : 転送先のソフトウエアイメージハンドル<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルを他のソフトウエアイメージハンドルにコピーしたいときに使用します。<br>
                　転送元から転送先にコピーしたい領域の左上座標を SrcX, SrcY で指定し、領域の幅と高さを SrcSizeX, SrcSizeY で指定します。<br>
                　転送先の座標は、転送元からコピーする領域の左上座標に対応する座標を DestX, DestY で指定します。<br>
                　転送元と転送先のピクセルフォーマットやパレットが違う場合は、カラーマッチングが行われエラーになることはありませんが、低速です。<br><br>

                　用途は・・・なんでしょう。パッとは思いつきませんが、無いと困ることがあるような気がします。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　Test1.bmp を読み込んで、MakePAL8ColorSoftImage で作成した空画像に転送します<br>
                ( MakePAL8ColorSoftImage で用意されるパレットは Test1.bmp
                に最適化されていないので見た目が悪くなるのがわかると思います )
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int handle, w, h, handle2 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 画像の読み込み
    handle = LoadSoftImage( "Test1.bmp" ) ;

    // 画像のサイズを取得
    GetSoftImageSize( handle, &amp;w, &amp;h ) ;

    // 読み込んだ画像と同じサイズの空パレット画像の作成
    handle2 = MakePAL8ColorSoftImage( w, h ) ;

    // 空パレット画像に読み込んだ画像を転送
    BltSoftImage( 0, 0, w, h, handle, 0, 0, handle2 ) ;

    // 画面に描画
    DrawSoftImage( 0, 0, handle2 ) ;

    // 使い終わったら解放
    DeleteSoftImage( handle ) ;
    DeleteSoftImage( handle2 ) ;

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N15">宣言</a></b></td><td><font color="#000088"><b>int DrawSoftImage( int x, int y, int SIHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージを画面に描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int x, int y : ソフトウエアイメージハンドルを描画する座標<br>
                    int SIHandle : ソフトウエアイメージハンドル<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルを
                <a href="dxfunc_graph3.html#R4N6"><b>SetDrawScreen</b></a> 関数で設定されている描画先に描画します。<br>
                　主に編集した画像が正しいかどうかを確認するためにしようするものです。<br>
                　グラフィックハンドルの描画に比べて負荷が非常に高いので、確認以外の用途で使用することは避けた方が賢明です。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R20N14"><b>BltSoftImage</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N16">宣言</a></b></td><td><font color="#000088"><b>int CreateGraphFromSoftImage( int SIHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージからグラフィックハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle : ソフトウエアイメージハンドル<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>－１以外：グラフィックハンドル　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルからグラフィックハンドルを作成します。<br>
                　主に編集したソフトウエアイメージハンドルから描画に適したグラフィックハンドルを作成するために使用します。<br>
                　作成後のグラフィックハンドルを使うにあたって、作成に使用したソフトウエアイメージハンドルは必要ありませんので、作成後にソフトウエアイメージハンドルの内容を弄っても、解放してしまっても大丈夫です。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N17">宣言</a></b></td><td><font color="#000088"><b>int CreateDivGraphFromSoftImage( int SIHandle, int AllNum, int XNum, int YNum, int SizeX, int SizeY, int *HandleBuf ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ＣＰＵで扱うイメージから分割グラフィックハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int SIHandle　　　　　: ソフトウエアイメージハンドル<br>
                    int AllNum　　　　　　:　画像の分割総数<br>
                    int XNum ,int YNum　:　画像の横向きに対する分割数と縦に対する分割数<br>
                    int SizeX ,int SizeY　:　分割された画像一つの大きさ<br>
                    int *HandleBuf　　　  :　分割読み込みして得たグラフィックハンドルを<br>
                    　　　　　　　　　　　　　保存するint型の配列へのポインタ</td>
                </tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：正常終了　－１：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R20N1"><b>LoadSoftImage</b></a> 関数や、<a href="#R20N3"><b>MakeARGB8ColorSoftImage</b></a> 関数等で作成したソフトウエアイメージハンドルから分割グラフィックハンドルを作成します。<br>
                　主に編集したソフトウエアイメージハンドルから描画に適したグラフィックハンドルを作成するために使用します。<br>
                　作成後のグラフィックハンドルを使うにあたって、作成に使用したソフトウエアイメージハンドルは必要ありませんので、作成後にソフトウエアイメージハンドルの内容を弄っても、解放してしまっても大丈夫です。<br><br>

                　使用方法に関しては <a href="dxfunc_graph1.html#R3N3"><b>LoadDivGraph</b></a> 関数と同じですので、引数については LoadDivGraph 関数の解説をご参照下さい。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません。
            <br><br><br><br><br>
        </td></tr>






        <tr><td><font size="3" color="#005500"><b>非同期読み込み関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R21N1">宣言</a></b></td><td><font color="#000088"><b>int SetUseASyncLoadFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>非同期読み込みを行うかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int Flag ： 非同期読み込みを行うかどうか<br>
                　　　　　　( TRUE：非同期読み込み　FALSE：同期読み込み( デフォルト ) )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　ゲームソフトではよくロード中に「Now Loading」と表示しながら、その文字が動いていたり、何か画面が動いていたりします。<br>
                　それはゲームに必要な情報をディスクから読み込んでいる間も平行して演出用のプログラムが動いているからです。<br>
                　ＤＸライブラリのデータ読み込み関数である <a href="dxfunc_graph1.html#R3N2"><b>LoadGraph</b></a> や <a href="dxfunc_sound.html#R8N4"><b>LoadSoundMem</b></a> は標準動作ではデータを読み込み終わるまで関数から出てこない「同期読み込み」ですが、
                この関数を使って設定を「非同期読み込み」にすると、データの読み込みが終わる前に関数から出てきます。<br>
                　当然読み込みが終わっていないので別途 <a href="#R21N2"><b>CheckHandleASyncLoad</b></a> や <a href="#R21N3"><b>GetASyncLoadNum</b></a> で読み込みが終わるのを確認してからではないとハンドルを使えるようにはなりませんが、
                読み込みが終わるまでの間、前述の「Now Loading」のアニメーションなどを行うことができます。<br><br>

                　非同期読み込みを使用して読み込んでいる間も画面上で演出を行うことで、
                主にプレイヤーが「データが読み込み終わるまで止まった画面を見続けなければならない」という状態を回避することができます。<br><br>

                　因みに非同期読み込みはそれなりに負荷の高い処理なので、
                パワーがあまり無いＣＰＵ( ノートパソコン搭載のＣＰＵや、その中でも特にシングルコアのＣＰＵ )では、
                非同期読み込みの間ガクッガクッと度々高負荷で動きがぎこちなくなると思います。<br>
                　なので、ゲームのプレイ中に次のステージのデータを先読みしてステージをクリア後読み込み画面無しで次のステージに移行！
                みたいな格好良いことをしようと思った場合は、それなりに性能の高いＣＰＵではないとスムーズに処理されないと考えてください。<br><br><br>

                <b>＜使い方＞</b><br><br>

                　非同期読み込みを行いたいファイルを読み込む前に SetUseASyncLoadFlag( TRUE ) ; を実行して、
                非同期読み込み設定にします。<br>
                　その上で後述の非同期読み込みに対応した関数を使用してデータ読み込みを行うことで非同期読み込みを行うことができます。<br><br>

                　非同期読み込みが完了したかどうかは <a href="#R21N2"><b>CheckHandleASyncLoad</b></a> か、<a href="#R21N3"><b>GetASyncLoadNum</b></a> を使用して確認します。<br>
                　CheckHandleASyncLoad は特定のハンドルの非同期読み込みが完了したかどうかをチェックすることができ、
                GetASyncLoadNum は行っている非同期読み込みの数を取得することができます。<br>
                　ハンドル別にチェックしたいときは CheckHandleASyncLoad、
                全体の非同期読み込みが完了しているかだけチェックしたいときは GetASyncLoadNum を使う、といった感じです。<br><br>
                
                　尚、非同期読み込みを開始してみたもののファイルが無かったりメモリが足りなかったりして読み込みが失敗した場合は、
                ハンドルは自動的に削除されます。<br>
                　その場合は CheckHandleASyncLoad の戻り値が -1 になりますので、読み込みが失敗したかどうかはそれで判断してください。<br><br><br>

                <b>＜非同期読み込みに対応している関数＞</b><br><br>

                （ 主な関数 ）<br>
                MakeGraph, MakeScreen, LoadGraph, LoadDivGraph, LoadBlendGraph,<br>
                LoadMask, LoadDivMask,<br>
                LoadSoundMem, LoadMusicMen,<br>
                MV1LoadModel,<br>
                CreateFontToHandle,<br>
                LoadSoftImage,<br>
                LoadPixelShader, LoadVertexShader<br>
                FileRead_open, FileRead_seek, FileRead_read<br><br>

                （ リファレンスには載っていない関数も含めた一覧 ）<br>
                MaekGraph, MaekScreen, LoadGraph, LoadReverseGraph, LoadDivGraph, LoadReverseDivGraph, LoadBlendGraph,<br>
                ReloadGraph, ReloadDivGraph, ReloadReverseGraph, ReloadReverseDivGraph,<br>
                CreateGraphFromMem, CreateDivGraphFromMem, ReCreateGraphFromMem, ReCreateDivGraphFromMem,<br>
                CreateGraphFromBmp, CreateDivGraphFromBmp, ReCreateGraphFromBmp, ReCreateDivGraphFromBmp,<br>
                CreateGraphFromGraphImage, CreateDivGraphFromGraphImage, ReCreateGraphFromGraphImage, ReCreateDivGraphFromGraphImage,<br>
                CreateGraphFromBaseImage, CreateDivGraphFromBaseImage, ReCreateGraphFromBaseImage, ReCreateDivGraphFromBaseImage,<br>
                CreateGraphFromSoftImage, CreateDivGraphFromSoftImage, ReCreateGraphFromSoftImage, ReCreateDivGraphFromSoftImage,<br>
                MakeMask, LoadMask, LoadDivMask,<br>
                LoadSoftImage, LoadSoftImageToMem,<br>
                LoadVertexShader, LoadVertexShaderFromMem, LoadPixelShader, LoadPixelShaderFromMem,<br>
                LoadSoundMem, LoadSoundMem2, LoadSoundMemBase, LoadSoundMemToBufNumSitei,<br>
                LoadSoundMemByMemImageBase, LoadSoundMemByMemImage, LoadSoundMemByMemImage2,<br>
                LoadSoundMemByMemImageToBufNumSitei, LoadSoundMem2ByMemImage, LoadBGM,<br>
                LoadSoftSound, LoadSoftSoundFromMemImage,<br>
                LoadMusicMem, LoadMusicMemByMemImage,<br>
                MV1LoadModel,<br>
                CreateFontToHandle,<br>
                FileRead_open, FileRead_read,<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　Test1.bmp を 20回読み込んで、読み込みが終わったグラフィックハンドルから描画する<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int GrHandle[ 20 ] ;
    int i ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1 ;

    // 非同期読み込み設定に変更
    SetUseASyncLoadFlag( TRUE ) ;

    // Test1.bmp を 20回読み込む
    for( i = 0 ; i &lt; 20 ; i ++ )
    {
        GrHandle[ i ] = LoadGraph( "Test1.bmp" ) ;
    }

    // 同期読み込み設定に変更
    SetUseASyncLoadFlag( FALSE ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // メインループ(何かキーが押されたらループを抜ける)
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {                                                       
        // 画面のクリア
        ClearDrawScreen() ;

        // 読み込みが終わっていたら画像を描画する
        for( i = 0 ; i &lt; 20 ; i ++ )
        {
            if( CheckHandleASyncLoad( GrHandle[ i ] ) == FALSE )
            {
                DrawGraph( i * 32, 0, GrHandle[ i ], TRUE ) ;
            }
        }

        // 非同期読み込みの数を描画
        DrawFormatString( 0, 0, GetColor( 255,255,255 ), "非同期読み込みの数 %d", GetASyncLoadNum() ) ;

        // 裏画面の内容を表画面に反映
        ScreenFlip();
    }

    // 読み込んだ画像のグラフィックハンドルを削除する
    for( i = 0 ; i &lt; 20 ; i ++ )
    {
        DeleteGraph( GrHandle[ i ] ) ;
    }

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R21N2">宣言</a></b></td><td><font color="#000088"><b>int CheckHandleASyncLoad( int Handle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ハンドルの非同期読み込みが完了しているかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int Handle ： チェックしたいハンドル<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：非同期読み込み中　FALSE：非同期読み込みは終了している　-1：エラー<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R21N1"><b>SetUseASyncLoadFlag</b></a> 関数で非同期読み込みの設定にした状態で非同期読み込みに対応した関数を使用した場合は、
                返ってくるハンドルは読み込みが完了するまで使うことができません。<br>
                　この関数は、ハンドルの非同期読み込みが終わったかどうかをチェックするために使用します。<br>
                　引数にハンドル( グラフィックハンドル、サウンドハンドル、フォントハンドル、ハンドルはなんでも )を渡すと、
                非同期読み込みがまだ終わっていない場合は TRUE が、終わっている場合は FALSE が返ってきます。<br>
                　尚、確かに正しいハンドルを渡しているはずなのに戻り値がエラーを示す -1 だ、という場合は、非同期読み込みが失敗したことを示します。
                ( 非同期読み込みが失敗するとハンドルは自動的に削除されます )
                <br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R21N1"><b>SetUseASyncLoadFlag</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="700"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R21N3">宣言</a></b></td><td><font color="#000088"><b>int GetASyncLoadNum( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　非同期読み込み中の処理の数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>なし<br></td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>実行しいる非同期読み込み処理の数<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　<a href="#R21N1"><b>SetUseASyncLoadFlag</b></a> 関数で非同期読み込みの設定にした状態で非同期読み込みに対応した関数を使用して非同期読み込みを開始した場合は、
                読み込みが終了するまで少し時間が掛かります。<br>
                　各ハンドルが読み込みが完了したかどうかは <a href="#R21N2"><b>CheckHandleASyncLoad</b></a> で確認することができますが、
                もっと大雑把に非同期読み込みが終わったかどうかを確認したいときはこの GetASyncLoadNum を使用します。<br>
                　この関数は非同期読み込みが終わっていない処理の数を取得します、
                単純に戻り値が０なら全ての非同期読み込みは完了していて、
                １以上ならまだ非同期読み込みが終わっていないと判断することができます。<br><br>

                　因みに、非同期読み込みが終わっていないハンドルの数ではなく、処理の数です。<br>
                　例えば LoadDivGraph で 1000個のハンドルを生成する非同期読み込みが実行されていても、
                GetASyncLoadNum では LoadDivGraph の処理一つ分ということで 1 が返ってきます。<br><br>
                
                　尚、非同期読み込みがファイルが無かったりメモリが足りなかったりして失敗した場合も「非同期読み込み終了」として GetASyncLoadNum の戻り値は小さくなりますので、
                エラーが発生したかどうかの確認は CheckHandleASyncLoad を使用する必要があります。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R21N1"><b>SetUseASyncLoadFlag</b></a> 関数のサンプルで使用していますので、そちらを参照してください。
            <br><br><br><br><br><br><br><br><br><br><br>
        </td></tr>














        <tr><td><font size="3" color="#005500"><b>文字関係関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="900"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R22N1">宣言</a></b></td><td><font color="#000088"><b>int SetUseCharCodeFormat( int CharCodeFormat ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　文字列の引数の文字コードを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int CharCodeFormat : 文字列の引数として使用する文字コード、以下の何れか<br>
　　DX_CHARCODEFORMAT_SHIFTJIS　　　　　： シフトJIS（ デフォルト ）<br>
　　DX_CHARCODEFORMAT_GB2312 　　　　　 ： 簡体字文字<br>
　　DX_CHARCODEFORMAT_UHC 　　　　　　　： ハングル文字<br>
　　DX_CHARCODEFORMAT_BIG5　　　　　　　： 繁体文字<br>
　　DX_CHARCODEFORMAT_UTF16LE　　　　　： UTF-16 リトルエンディアン<br>
　　DX_CHARCODEFORMAT_UTF16BE　　　　　： UTF-16 ビッグエンディアン<br>
　　DX_CHARCODEFORMAT_WINDOWS_1252　： 欧文（ ラテン文字 ）<br>
　　DX_CHARCODEFORMAT_ISO_IEC_8859_15 ： 欧文（ ラテン文字 ）<br>
　　DX_CHARCODEFORMAT_UTF8　　　　　　　： UTF-8<br>
　　DX_CHARCODEFORMAT_ASCII　　　　　　　： アスキー文字<br>
　　DX_CHARCODEFORMAT_UTF32LE　　　　　： UTF-32 リトルエンディアン<br>
　　DX_CHARCODEFORMAT_UTF32BE　　　　　： UTF-32 ビッグエンディアン<br>
                　　　　　</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ＤＸライブラリの関数は初期状態では引数として受け取る文字列は文字コード『シフトJIS』形式として処理しますが( Androidアプリの場合は文字コード『UTF-8』形式 )、
                    『シフトJIS』は主に日本語文字用の文字コードなので、他の言語に対応させたい場合や、
                    Androidアプリと同じ『UTF-8』を使用したい場合などにこの関数を使用して関数の引数として渡す文字列の文字コードを変更します。<br>
                    　なお、この関数はいつでも使用できますが、不都合が無ければ DxLib_Init を呼ぶ前の個所でこの関数を呼び、設定を変更しておくことをお勧めします。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="900"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R22N2">宣言</a></b></td><td><font color="#000088"><b>int GetCharBytes( int CharCodeFormat, void *String ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　文字列の先頭の文字のバイト数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int CharCodeFormat : 引数の文字列の文字コード、以下の何れか<br>
　　DX_CHARCODEFORMAT_SHIFTJIS　　　　　： シフトJIS（ デフォルト ）<br>
　　DX_CHARCODEFORMAT_GB2312 　　　　　 ： 簡体字文字<br>
　　DX_CHARCODEFORMAT_UHC 　　　　　　　： ハングル文字<br>
　　DX_CHARCODEFORMAT_BIG5　　　　　　　： 繁体文字<br>
　　DX_CHARCODEFORMAT_UTF16LE　　　　　： UTF-16 リトルエンディアン<br>
　　DX_CHARCODEFORMAT_UTF16BE　　　　　： UTF-16 ビッグエンディアン<br>
　　DX_CHARCODEFORMAT_WINDOWS_1252　： 欧文（ ラテン文字 ）<br>
　　DX_CHARCODEFORMAT_ISO_IEC_8859_15 ： 欧文（ ラテン文字 ）<br>
　　DX_CHARCODEFORMAT_UTF8　　　　　　　： UTF-8<br>
　　DX_CHARCODEFORMAT_ASCII　　　　　　　： アスキー文字<br>
　　DX_CHARCODEFORMAT_UTF32LE　　　　　： UTF-32 リトルエンディアン<br>
　　DX_CHARCODEFORMAT_UTF32BE　　　　　： UTF-32 ビッグエンディアン<br>
                void *String : 先頭の文字のバイト数を取得したい文字列<br>
                　　　　　</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０以上：先頭の文字のバイト数<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　コンピュータ上では文字も数値で扱います( 例えば『A』という文字は数値の『65 ( 16進数の 41 )』として扱うなど )が、
                    1文字当たりのバイト数は、文字コードや文字によって異なります。( 例えば、文字コード『シフトJIS』では、半角文字は 1文字 1バイト、全角文字は 1文字 2バイト、といった具合にです )<br>
                    　1文字が何バイトなのかを判別する方法も文字コードによって異なるので、
                    「何種類もある文字コード毎に何バイトか調べるプログラムを書くのは面倒！」という場合にこの関数を使用すると便利です。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　1文字のバイト数が異なる文字が混ざっている文字列『aあbいcうdえeお』の文字の数を数える<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int CharBytes ;
    int CharNum ;
    int i ;
    const char *String = "aあbいcうdえeお" ;

    // ウインドウモードで起動
    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1 ;

    // 文字の数を数える
    i = 0 ;
    CharNum = 0 ;
    while( String[ i ] != '\0' )
    {
        // 文字のバイト数を取得
        CharBytes = GetCharBytes( DX_CHARCODEFORMAT_SHIFTJIS, &String[ i ] ) ;

        // 文字の数を増やす
        CharNum ++ ;

        // 調べる位置を移動する
        i += CharBytes ;
    }

    // 結果を表示
    DrawFormatString( 0, 0, GetColor( 255,255,255 ), "「%s」の文字数は %d です", String, CharNum ) ;

    // キー入力待ち
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用<BR>
	    ( 実行には cppファイルを文字コード『Unicode(UTF-8 シグネチャ付き)』で保存する必要があります )</B></FONT>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int android_main( void )
{
    int CharBytes ;
    int CharNum ;
    int i ;
    const char *String = "aあbいcうdえeお" ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1 ;

    // 文字の数を数える
    i = 0 ;
    CharNum = 0 ;
    while( String[ i ] != '\0' )
    {
        // 文字のバイト数を取得
        CharBytes = GetCharBytes( DX_CHARCODEFORMAT_UTF8, &String[ i ] ) ;

        // 文字の数を増やす
        CharNum ++ ;

        // 調べる位置を移動する
        i += CharBytes ;
    }

    // 結果を表示
    DrawFormatString( 0, 0, GetColor( 255,255,255 ), "「%s」の文字数は %d です", String, CharNum ) ;

    // キー入力待ち
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
            <br><br><br><br><br><br><br>
        </td></tr>












        <tr><td><font size="3" color="#005500"><b>マイナー関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N22">宣言</a></b></td><td><font color="#000088"><b>int SetAlwaysRunFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　ウインドウがアクティブではない状態でも処理を続行するか、フラグをセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int Flag : 非アクティブでも処理を続行するかを決定するフラグ<br>
                　　　　　( TRUE:続行する　FALSE:非アクティブの間は処理を停止(標準) )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ＤＸライブラリをウインドウモードで起動した場合、ソフトのウインドウが
                    非アクティブ状態になるとデフォルトの状態では再びウインドウがアクティブに
                    なるまでソフトの処理は停止します。<br>
                    　が、この関数で非アクティブ時にも処理を続行する設定にすることにより、
                    ウインドウが非アクティブ時でもソフトの処理を実行しつづけることが出来ます。
                    　ＤＸライブラリでバックグラウンドで何か処理を行うといった用途のソフトを
                    作成されることは非常にまれですが、そのようなソフトを作る場合に有効です。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N14">宣言</a></b></td><td><font color="#000088"><b>int    SetOutApplicationLogValidFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ログ出力を行うか否かのセット<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int Flag : ログ出力を行うか否かのフラグ(TRUE:行う FALSE:行わない)</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ＤＸライブラリは通常デバッグ情報用のログファイルである『Log.txt』にデバッグ情報を出力します。この関数はその出力を抑制する場合に使用します。<br><br>

                <font color="#a00000">
                    　なおこの関数を他の全てのＤＸライブラリの関数より先に( DxLib_Init や ChangeWindowMode よりも先に ) FALSE を渡して呼び出すことにより、『Log.txt』を作成しないようにすることができます。<br><br>
		</font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません<br><br><br><br>

        </td></tr>

<!--
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="70"><b><a name="R15N36">宣言</a></b></td>
            <td><font color="#000088"><b>int SetSysCommandOffFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="70"><b>概略</b></td>
            <td>　ALTキーや Windowsキーを無効にするかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="70"><b>引数</b></td>
                <td>int Flag : 無効にするかどうか( TRUE=無効  FALSE=有効(デフォルト) )</td>
            </tr>
            <tr><td valign="top" width="70"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="70"><b>解説</b></td>
                <td>　Windowsアプリケーションは通常、ALT+TAB でタスクの切り替え、
                Windowsキーでスタートメニューを表示したりすることが出来ますが、
                ときにこの機能が煩わしくなることがあります(
                フルスクリーンのアクションゲームの最中に間違って押してしまってデスクトップに戻ってしまった！など
                )この関数はそんな事故が起きないように ALTキーや Windowsキーを無効にする用途で使用する関数です。<br>
                　引数の Flag に TRUEを渡して呼べば無効に、FALSEを渡して呼べば有効になります。<br>
                (尚、この関数は DxLib_Init を呼んだ後じゃないと使用できませんのでご注意下さい)<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br><br>
        </td></tr>
-->



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="70"><b><a name="R15N30">宣言</a></b></td>
            <td><font color="#000088"><b>int SetUseDXArchiveFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="70"><b>概略</b></td>
            <td>　ＤＸアーカイブファイルの読み込み機能を使うかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="70"><b>引数</b></td>
                <td>int Flag : アーカイブファイルの読み込み機能を使用するかどうかのフラグ<br>
                　　　　　　　　　　( TRUE:使用する FALSE:使用しない )</td>
            </tr>
            <tr><td valign="top" width="70"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="70"><b>解説</b></td>
                <td>　ＤＸライブラリは DxaEncode.exe で作成できるアーカイブファイルをフォルダに見立てて使うことが出来ますが、
                この関数はその機能を使うかどうかを設定します。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="70"><b><a name="R15N31">宣言</a></b></td>
            <td><font color="#000088"><b>int SetDXArchiveExtension( char *Extension ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="70"><b>概略</b></td>
            <td>　検索するＤＸアーカイブファイルの拡張子を変更する<br><br></td></tr>
            <tr><td valign="top" width="70"><b>引数</b></td>
                <td>char *Extension : 変更後の検索拡張子</td>
            </tr>
            <tr><td valign="top" width="70"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="70"><b>解説</b></td>
                <td>　ＤＸライブラリは DxaEncode.exe で作成できるアーカイブファイルをフォルダに見立てて使うことが出来ますが、
                拡張子が標準の『dxa』のままだと如何にも『ＤＸライブラリを使ってます』と言っているようなものなので、
                それが嫌なときにＤＸアーカイブファイルの拡張子を変更すると同時にこの関数で変更後の拡張子のファイルをＤＸライブラリがアーカイブファイルだと見なすように設定してやります。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="70"><b><a name="R15N32">宣言</a></b></td>
            <td><font color="#000088"><b>int SetDXArchiveKeyString( char *KeyString ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="70"><b>概略</b></td>
            <td>　ＤＸアーカイブファイルの鍵文字列を設定する<br><br></td></tr>
            <tr><td valign="top" width="70"><b>引数</b></td>
                <td>char *KeyString : 鍵文字列</td>
            </tr>
            <tr><td valign="top" width="70"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="70"><b>解説</b></td>
                <td>　ＤＸライブラリは DxaEncode.exe で作成できるアーカイブファイルを使うことが出来ますが、そのアーカイブファイルには作成時にパスワード(鍵文字列)を設定することができます。<br>
                　ただ、アーカイブファイルにパスワードが設定されている場合は、ＤＸライブラリで使用する際も予めこの関数で使用するアーカイブファイルのパスワードを教えておく必要がある、というわけです。<br><br>

                  <font color="#aa0000"><b>
                　！注意！　DxaEncode.exe のバージョン 1.02 ～ 1.06 で作成したパスワード付きＤＸアーカイブでは解析によってパスワードが分かってしまう問題について<br><br>

                　　DxaEncode.exe のバージョン 1.02 ～ 1.06 の DxaEncode.exe( ＤＸライブラリのバージョン 3.19b までに同梱されている DxaEncode.exe )で作成したパスワード付きＤＸアーカイブは、アーカイブファイルを解析するだけでパスワードが分かってしまうという問題があります。<br>
                　なので、バージョン 1.07 の DxaEncode.exe( ＤＸライブラリのバージョン 3.19d 以降に同梱されている DxaEncode.exe )でＤＸアーカイブを再作成する場合は以前とは別のパスワードを使用するようにしてください。<br><br>

		　尚、アーカイブファイル機能やパスワードの安全性などの詳細についてはミニテクニックコーナーの『<A HREF="../dxtec.html#T11"><B>アーカイブ機能を使ってファイルを一つに纏める</B></A>』を参照してください。</font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="70"><b><a name="R15N37">宣言</a></b></td>
            <td><font color="#000088"><b>int SetEmulation320x240( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="70"><b>概略</b></td>
            <td>　６４０ｘ４８０の画面で３２０ｘ２４０の画面解像度にするかどうかのフラグをセットする、６４０ｘ４８０以外の解像度では無効<br><br></td></tr>
            <tr><td valign="top" width="70"><b>引数</b></td>
                <td>int Flag : この機能を有効にするかどうか( TRUE:有効  FALSE:無効 )</td>
            </tr>
            <tr><td valign="top" width="70"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="70"><b>解説</b></td>
                <td>　３２０ｘ２４０という低解像度の画面を使用して古きよきファミコン位の頃のゲーム画面を表現してみたいと思うときがあります。<br>
                　ですが、最近のグラフィックチップやモニタでは３２０ｘ２４０という解像度に対応していないことが偶にあり(ノートＰＣで多いようです)そのような環境では SetGraphMode
                関数で３２０ｘ２４０画面にしても正常にフルスクリーン表示されません。<br>
                　それでもどうしてもフルスクリーン表示したいという場合は別の方法を使って３２０ｘ２４０の画面をモニタ一杯に表示する必要があるわけですが、
                この関数はその手段の内の一つです。<br><br>

                　まず SetGraphMode( 640, 480, 32 ) ; を実行して、画面モードが６４０ｘ４８０にします、次にこの関数に TRUE を渡して呼び出すと６４０ｘ４８０の画面に３２０ｘ２４０の画面を２倍拡大して表示されます。<br>
                　要は３２０ｘ２４０の画面モードに対応していないなら、６４０ｘ４８０の画面に３２０ｘ２４０の画面を２倍拡大して、擬似的に３２０ｘ２４０の画面を表現しようというわけです。<br>
                　ただ、３２０ｘ２４０の画面には対応しているけど、この関数の機能( ３２０ｘ２４０を２倍拡大表示する機能 )には対応していない、という場合もありますので、
                この関数を使用する際は、必ずソフトウエア側にオプションとして付けるようにして下さい。( デフォルトでは３２０ｘ２４０の画面を使用して、
                オプションとしてこの関数を使用するかどうかを決められる等 )<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N1">宣言</a></b></td><td><font color="#000088"><b>int    SetUse3DFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ機能を使うか、のフラグをセット<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>Flag : ３Ｄ機能を使うかを指定するフラグ情報<br>
                    　　　　TRUE　 : 使用する（デフォルト）<br>
                    　　　　FALSE　: 使用しない</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ＤＸライブラリの回転描画、拡大描画、半透明描画加算ブレンド描画、
                    描画輝度設定等はすべてグラフィックカードの３Ｄ機能を用いて実現して
                    います。ですが、グラフィックカードは色々かメーカーが製造しており
                    機能や性能はメーカーごと、機種ごとにそれぞれ違いますので、３Ｄ機能も
                    機種によって結果に違いが出たり時には利用者の全く意図しない結果が
                    出てしまったりすることがあります。<br>
                    　そこでこの関数はグラフィックカード同士の結果の差異が多い３Ｄの
                    機能を使用するか否かを設定する事が出来ます。３Ｄの機能を停止する
                    事により描画機能の低下は免れませんが、その分ソフトの安定性は高まる
                    ことになります。<br>
                    (とはいえ３Ｄ機能を使わないことによる機能制限の概念などには技術的な
                    話がついて回るので、ある程度これらの話に詳しい方のみ使うように
                    してください)<br><br><br>


                    　３Ｄ機能を停止する事により発生する機能制限は描画関数全般の速度低下、です。
                    それだけと言えばそれだけですが、ＤＸライブラリ利用目的の殆どは描画関係だと
                    思いますので、かなり大きい制限だと思います。<br><br>
<!--
                    　ただし、３Ｄ機能を停止する事により使用可能になる機能もあります。
                    それを次に示します。<br><br>

                    　　　グラフィックメモリへの直接アクセスをするための<a href="#R15N3"><b>『GraphLock』</b></a><br>
                    　　<a href="#R15N4"><b>『GraphUnLock』関数</b></a>で、画面以外のグラフィックメモリにも<br>
                    　　アクセスが可能になる。<br><br> 

                    　　　<a href="dxfunc_graph3.html#R4N6"><b>SetDrawScreen関数</b></a>で描画先を<a href="dxfunc_graph1.html#R3N6"><b>MakeGraph</b></a>,<a href="dxfunc_graph1.html#R3N2"><b>LoadGraph</b></a>,<a href="dxfunc_graph1.html#R3N3"><b>LoadDivGraph</b></a><br>
                    　　で作成したグラフィック領域を指定できるようになる。これにより<br>
                    　　<a href="dxfunc_graph1.html#R3N12"><b>GetDrawScreenGraph関数</b></a>でグラフィックハンドルの示すグラフィック<br>
                    　　を取得する事も可能になる。<br><br>

                    　　　<a href="#R15N2"><b>SetUseVramFlag関数</b></a>、<a href="#R15N15"><b>SetBasicBlend関数</b></a>が有効になる。<br><br><br><br>



                    ＜余談＞<br><br>

                    　『このグラフィックだけ３Ｄの機能を使わないグラフィックにして、<br>
                    直接アクセスしたい、他は３Ｄ機能を使ったグラフィックにしたい』<br>
                    という場合がございましたら、
                    <a href="dxfunc_graph1.html#R3N6"><b>MakeGraph</b></a>, <a href="dxfunc_graph1.html#R3N2"><b>LoadGraph</b></a>, <a href="dxfunc_graph1.html#R3N3"><b>LoadDivGraph</b></a><br>
                    関数等の引数を一つ増やす事で可能になります。その引数は３Ｄ機能を<br>
                    使ったグラフィックにしないか、というフラグになっておりまして、<br>
                    TRUEを指定することにより３Ｄ機能を使わないグラフィックとして作成、<br>
                    ロード等を行います。こうして作られたグラフィックには<a href="#R15N3"><b>GraphLock関数</b></a><br>
                    を利用して直接アクセスが出来るようになります。<br><br>
            
                    　<b>例</b><br>
<pre><div class="NormalFont">    // 普通は
    MakeGraph( 640 , 480 ) ;

    // これが一つ引数が増えます(LoadGraphもLoadDivGraphも同様です）
    MakeGraph( 640 , 480 , TRUE ) ;
</div></pre>
                    <br><br>            -->
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません。
            <br><br><br><br>
        </td></tr>

<!--    <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N17">宣言</a></b></td><td><font color="#000088"><b>int GetUse3DFlag( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　画面の描画に３Ｄアクセラレータを使っているか、の情報を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE(1):３Ｄアクセラレータ使用　FALSE(0):ソフトウエア描画<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　そのままです、画面の描画に３Ｄアクセラレータを使っている
                    かどうかを知ることが出来ます。<br>
                    　基本的に３ＤアクセラレータでやっていることをＣＰＵ演算で
                    エミュレーションするのは大変なことなので、３Ｄアクセラレータ
                    がない場合は…という分岐を作りたいときに使えます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません。
            <br><br><br><br>
        </td></tr> -->

<!--    <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N2">宣言</a></b></td><td><font color="#000088"><b>int SetUseVramFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
                <td>グラフィックデータにＶＲＡＭを使用するか、のフラグをセットする（３Ｄ機能をＯＦＦにしている時のみ有効）<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>Flag : グラフィックデータの保存にＶＲＡＭを使用するか、のフラグ情報<br>
                    　　　　TRUE  : 使用（デフォルト）<br>
                    　　　　FALSE : 使用しない</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄの機能を<a href="#R15N1"><b>SetUse3DFlag 関数</b></a>で無効にした時のみ有効な関数です。
                    ３Ｄ機能を無効にすることによりグラフィックデータへの直接アクセスが
                    可能になりますが、グラフィックデータを保存するメモリにはグラフィック
                    カード上にあるＶＲＡＭといわゆるシステムメモリと呼ばれるただのＲＡＭ
                    があり、ＶＲＡＭに対する直接アクセスは特に読み出しが遅い事で有名です。<br>
                    　ですのでこの関数を使ってグラフィックデータをＶＲＡＭに保存しない
                    ようにすることにより、グラフィックデータへの直接アクセスの速度を
                    上げようと言うことです。（因みにただ描画するだけならＶＲＡＭにグラ
                    フィックデータがあったほうが高速です）<br>
                    　ＲＡＭにグラフィックデータを保存するようにすることにより起こる
                    機能の制限や操作の変更は一切ありませんのでご安心下さい。<br><br>

                    　あと３Ｄ機能を有効にしている場合でも隠れ引数により３Ｄ機能を
                    使わない設定にして作成したグラフィックデータには３Ｄ機能ＯＮ中でも
                    設定は有効です。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ＲＡＭ上に画面と同じ大きさのグラフィックデータを作成して、
                グラフィックデータへの直接アクセスでランダムに点を描き、
                最後に画面に描画します<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int i ;
    int Pitch , GHandle ;
    short *DrawPoint , Cr ;
    char *GraphData ;

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // ３Ｄの描画機能を停止します
    SetUse3DFlag( FALSE ) ;

    // ＶＲＡＭを使用しない設定にします
    SetUseVramFlag( FALSE ) ;

    // 画面と同じ大きさのグラフィックデータを作成します
    GHandle = MakeGraph( 640 , 480 ) ;

    // グラフィックをロックします(『GraphLock』使用)
    GraphLock( GHandle , &Pitch , ( void ** )&GraphData ) ;

    // 白色の値を取得
    Cr = ( short )GetColor( 255 , 255 , 255 ) ;

    // ランダムに点を１０００個描画
    for( i = 0 ; i &lt; 1000 ; i ++ )
    {
        // 描画する座標のポインタを計算
        DrawPoint = ( short * )( GraphData +
                     GetRand( 639 ) * ( 16 / 8 ) + 
                     GetRand( 479 ) * Pitch ) ; 

        // グラフィックデータへの直接アクセスで点を描画
        *DrawPoint = Cr ;
    }

    // グラフィックのロックを解除(『GraphUnLock』使用)
    GraphUnLock( GHandle ) ;

    // グラフィックデータを画面に描画する
    DrawGraph( 0 , 0 , GHandle , FALSE ) ;

    // キー入力待ち
    WaitKey() ;

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>    -->


<!--        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N16">宣言</a></b></td><td><font color="#000088"><b>int SetScreenMemToVramFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　画面の画像データをＶＲＡＭに配置するかどうかを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>Flag : ＶＲＡＭに配置するか否かのフラグ<br>
                    　　　　　　( TRUE:ＶＲＡＭに配置(デフォルト) FALSE:システムメモリに配置 )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　グラフィックを実際に描画する画面のデータ領域をＶＲＡＭにするか
                    システムメモリにするか変更する事が出来ます。<br><br>

                    　ＶＲＡＭとはビデオＲＡＭ、グラフィックカードに装備されているメモリ
                    のことで、システムメモリとは『パソコンの搭載メモリ』として表記されている
                    普通のメモリの事です。<br><br>

                    　この関数の説明をする前に以下の前提を覚えてください。<br><br>

                    １．　ＣＰＵがＶＲＡＭに記憶されているデータを読み出すのは非常に低速である<br>
                    ２．　画面のグラフィックデータは通常ＶＲＡＭに配置されている<br>
                    ３．　ＣＰＵで半透明系の描画処理をする場合は画面のグラフィックデータを<br>
                    　　　読みこむ必要がある。<br><br>

                    　<a href="#R15N1"><b>SetUse3DFlag</b></a> 関数によって３Ｄアクセラレータを使わないようにした場合、
                    描画処理はすべてＣＰＵで行います。<br>
                    　この時 <a href="dxfunc_graph1.html#R3N17"><b>SetDrawBlendMode</b></a> 関数によって半透明描画をするよう指定した場合、
                    ＣＰＵは上記の第３項目である画面のグラフィックデータを読みこむ処理をしますが、
                    第２第１項目をみていただければわかるように、ＶＲＡＭのデータを読みこむ
                    処理が発生してしまうために処理が非常に低速になります。<br>
                    　この最悪な現象を回避するにはどうすれば良いか？<br>
                    　そう、画面のグラフィックデータがＶＲＡＭになければいいのです。<br><br>

                    　と、いうわけでこの関数は画面のグラフィックデータのありかをＶＲＡＭか
                    普通のＲＡＭどちらに配置するか決める事が出来ます。<br><br>

                    　ですが注意が必要です。<br>
                    　画面のグラフィックデータがＶＲＡＭにない場合は３Ｄアクセラレータを使う事が
                    出来なくなるために、この関数を使って画面のグラフィックデータをシステムメモリに
                    した場合は自動的に３Ｄアクセラレータによる描画は出来なくなり、それまでにロード
                    したグラフィックデータはすべて破棄されます。<br>
                    ( <a href="#R15N1"><b>SetUse3DFlag</b></a> 関数で３Ｄアクセラレータの使用を止めたときと同じ状態に
                    なります )<br>
                    　つまり完全に２Ｄ描画のみで処理をすべて行う事が前提となります。<br><br>

                    　さらにこの関数を使用しても表画面はＶＲＡＭに存在しつづけますので描画
                    処理時には必ず <a href="dxfunc_graph3.html#R4N6"><b>SetDrawScreen</b></a> 関数で DX_SCREEN_BACK を使用して裏画面への
                    描画に変更する必要があります。<br>
                    (表画面への描画はＶＲＡＭにある場合と変わりません)<br><br>

                    　総じて癖の強い関数です。<br>
                    　ですが半透明等の処理速度は画面のグラフィックデータがＶＲＡＭにある場合に
                    比べて２倍近く速くなりますので３Ｄアクセラレータ無しで半透明描画処理を多用
                    する場合は必ず使う事をお勧めします。<br><br>

                    <font color="#880000"><b>＜注意！＞</b><br>
                    　この関数は <a href="../dxfunc.html#R1N1"><b>DxLib_Init</b></a> の前で実行した場合のみ効果が得られます<br><br>
                    </font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　画面データをシステムメモリに配置し、アルファブレンド処理を行います。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int Alpha , AddAlpha ;
    int Graph1 , Graph2 ;

    // 画面のグラフィックデータをシステムメモリに配置
    SetScreenMemToVramFlag( FALSE ) ;

    // ＤＸライブラリ初期化処理
    if( DxLib_Init() == -1 ) return -1;

    // 簡略化ブレンド処理をしない FALSE を TRUE にする事によって
    // 簡略化ブレンド処理に変更する事が出来ます
    SetBasicBlendFlag( FALSE ) ;

    // 裏画面に描画をするよう指定
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 画像をロード
    Graph1 = LoadGraph( "Scene1.jpg" ) ;
    Graph2 = LoadGraph( "Scene2.jpg" ) ;

    // アルファ値とアルファ値推移値の初期化
    AddAlpha = 1 ;
    Alpha = 0 ;

    // 描画ループ
    while( !ProcessMessage() )
    {
        // ブレンド処理を行わないで下になるグラフィックを描画
        SetDrawBlendMode( DX_BLENDMODE_NOBLEND , 0 ) ;
        DrawGraph( 0 , 0 , Graph2 , FALSE ) ;

        // アルファブレンドでグラフィックを描画
        SetDrawBlendMode( DX_BLENDMODE_ALPHA , Alpha ) ;
        DrawGraph( 0 , 0 , Graph1 , FALSE ) ;

        // アルファ値を変更
        Alpha += AddAlpha ;
        if( Alpha == 256 ){ Alpha = 255 ; AddAlpha = -1 ; }
        if( Alpha == -1 ){ Alpha = 0 ; AddAlpha = 1 ; }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリ使用の終了処理
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
        <hr>
            <br><br>
        </td></tr> -->


<!--
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N23">宣言</a></b></td><td><font color="#000088"><b>int GetVideoMemorySize( int *AllSize, int *FreeSize ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　ビデオメモリの容量を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int *AllSize : ビデオメモリの総容量を格納する<br>
            　　　　　　　　　　　　int 型変数のアドレス( NULL も可 )<br>
                int *FreeSize : ビデオメモリの空き容量を格納する<br>
                　　　　　　　　　　int 型変数のアドレス( NULL も可 )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　実行されているパソコンのビデオシステムのメモリの総容量と空き容量を
                    取得することが出来ます。<br>
                    　総容量は AllSize で指定したアドレスの変数へ、空き容量は FreeSize で
                    指定したアドレスの変数へ格納されます。<br><br>
                    
                    例<br>
                    　　　int AllSize, FreeSize ;<br><br>

                    　　　GetVideoMemorySize( &amp;AllSize, &amp;FreeSize ) ;<br><br>

                    　なお、必要のない情報は NULL を指定することにより取得をキャンセル
                    することが出来ます。<br><br>

                    例<br>
                    　　　int FreeSize ;<br><br>

                    　　　GetVideoMemorySize( NULL, &amp;FreeSize ) ;<br><br>

                    　この関数の用途としては…<br>
                    　起動前にソフトで必要となるビデオメモリの容量に達していない環境で実行
                    された場合、その旨を警告を出力するとか…でしょうか。<br>
                    　機能自体は面白い関数ですがあまり使い道はありません。(汗)<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません
            <br><br><br><br>
        </td></tr>

-->


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N5">宣言</a></b></td><td><font color="#000088"><b>int    SetWaitVSyncFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　ScreenFlip関数 実行時にＣＲＴの垂直同期信号待ちをするかのフラグセット<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>Flag : ＣＲＴの垂直同期信号を待つか否かを決めるフラグ情報<br>
                    　　　　　　TRUE  : 待つ（デフォルト）<br>
                    　　　　　　FALSE : 待たない</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="dxfunc_graph3.html#R4N7"><b>ScreenFlip関数</b></a>の実行時にＣＲＴの垂直同期信号を待つか、を
                    決めるフラグを設定する関数です。基本的に待ったほうが画面の
                    ちらつきが減り綺麗に表示されます。<br>
                    　この関数は垂直同期信号の意味を理解していて、その上で状態を
                    変更したい方だけが使用してください。恐らく普通は変更する必要は
                    ないと思います。<br><br>

                    <font color="#660000"><b>
                    ！注意！<br><br>
                    　この関数は Ver3.0 以降( DirectX9版以降 )では DxLib_Init の前に呼んだ場合のみ効果が現れる関数に仕様が変更となりました。<br>
                    　DxLib_Init を呼んだ後にこの関数を呼んでも効果はありませんので注意してください。<br><br>
                    </b></font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません<br><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N24">宣言</a></b></td><td><font color="#000088"><b>int SetUseDivGraphFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　必要ならグラフィックの分割を行うか否かを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int Flag : 必要ならグラフィックの分割を行うか否かを決定するフラグ<br>
                　　　　　　　　( TRUE : 行う(デフォルト)　　　FALSE : 行わない )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ＤＸライブラリでは標準でパソコンに搭載されているグラフィックカードに
                    ３Ｄアクセラレータ機能が搭載されている場合は、その高速なハードウエア機能を
                    使い２Ｄグラフィック描画を実現します。(３Ｄアクセラレータ機能は当然
                    ３Ｄ空間を描画するためにあるのですが、使いようによっては平面的な２Ｄ
                    描画にもつかえるのです。)<br>
                    　そして３Ｄアクセラレータを使って絵を画面に描画する場合、描画する絵の
                    サイズは３Ｄアクセラレータの仕様上　幅・高さ共に２の n 乗でなければ
                    なりません。( ２のｎ乗の数値 → 1 2 4 8 16 32 64 128 ... )
                    　つまり、幅300 高さ200 の絵や、幅640 高さ480 の絵などは、そのままでは
                    描画することが出来ないのです。<br><br>

                    　この問題を解決する方法は２つあります。<br><br>

                    １．　描画したい絵を、描画したい絵より大きい２のｎ乗の大きさを持つ絵として<br>
                    　　処理する。<br>
                    ２．　複数の２のｎ乗の大きさを持つ絵に分解して、結果的にひとつの絵に見える<br>
                    　　ように処理する。<br><br>

                    　１の方法は、たとえば幅300 高さ300(以後 300x300 と記述します)の大きさを
                    持つグラフィックを表示したい場合、２のｎ乗で300より大きい数値である512
                    の値を採用し、512x512 の大きさを持つ絵として扱う方法です。<br><br>

                    　２の方法は、たとえば 300x300 の大きさをもつ絵を、２のｎ乗の大きさを持つ
                    複数の絵で扱う方法で、具体的には 256x256 の絵と、64x256 の絵、 256x64 の絵、
                    64x64 の絵の合計４つの絵を継ぎはぎして 300x300 というひとつの絵を処理
                    する方法です。<br><br>

                    　どちらも一長一短で、まず１の方法は 300x300 の絵を 512x512 の絵として扱う
                    ため、使われていない 幅212 高さ212 の部分はそのまま無駄になってしまいます。
                    ２の方法では複数の絵で表現するために１の方法よりも無駄は省けますが、沢山の
                    絵を扱うことになり、その分１の方法よりも処理速度は遅くなります。<br><br>

                    　ＤＸライブラリはデフォルトでは２の方法を使いますが、描画速度を優先させ
                    たい場合にはこの関数で処理形態を変更することが出来ます。<br>
                    　この関数に TRUE を渡した場合は２、FALSE を渡した場合は１の処理で絵が
                    描画されますので、状況に応じて使い分けてください。<br>
                    (この設定をどうするにしろ、もともとの絵が２のｎ乗の大きさだった場合は
                    どちらの設定でも同じ処理がされるのですが…)<br><br>

                    　なお、この関数を使用して処理形態を変えた後に LoadGraph 関数などを使って
                    作られたグラフィックから変更が適用されます。１の処理形態になるか２の処理
                    形態になるかはグラフィックを読み込んだ時に決定され、既にメモリに読み込ま
                    れていグラフィックに対しては SetUseDivGraphFlag 関数は何の影響も及ぼしま
                    せんので注意してください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません
            <br><br><br><br>
        </td></tr>


<!--    <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N10">宣言</a></b></td><td><font color="#000088"><b>int SetGraphDataShavedMode( int ShavedMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　グラフィック減色時の画像劣化緩和処理モードの変更<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>ShavedMode : 劣化緩和処理モード　　DX_SHAVEDMODE_DITHER　　: ディザリングによる緩和<br>
                    　　　　　　　　　　　　　　　　　　DX_SHAVEDMODE_DIFFUS　: 誤差拡散による緩和<br>
                    　　　　　　　　　　　　　　　　　　DX_SHAVEDMODE_NONE　　: 画像劣化緩和処理を行わない</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　フルカラー(1677万色)画像をハイカラー(65536色)画像として
                    ロードした場合は、減色処理が起こります。<br>
                    　その時単純な減色処理を施してしまうと画像の劣化が激しいので
                    一般には劣化を緩和するために色々な処理が行われます。<br><br>

                    　ＤＸライブラリでは標準では何も劣化緩和処理を行わない
                    DX_SHAVEDMODE_NONE オプションが指定されていますが、
                    この関数を使用して劣化緩和処理を施すようにする事も出来ます。<br>
                    　ただ劣化緩和処理を行った場合は画像が全体的にぶつぶつした
                    ものになりますので、拡大表示する画像に対しては何もしない方が
                    良いかもしれません。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません<br><br><br><br>

        </td></tr> -->



<!--     <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N15">宣言</a></b></td><td><font color="#000088"><b>int SetBasicBlendFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　　３Ｄアクセラレータを使わない半透明描画処理を高速な簡略化された処理を使用するか否かを変更する
                    （３Ｄ機能をＯＦＦにしている時のみ有効）<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int Flag : 簡略化された処理を使用するか否かのフラグ<br>
                    　　　　　　　( TRUE:簡略化された処理を使用する FALSE:使用しない(デフォルト) )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="#R15N1"><b>SetUse3DFlag</b></a> 関数によって３Ｄアクセラレータを使用しないで描画処理を
                    行うようにした場合、又はグラフィックカードに３Ｄアクセラレータが装備されて
                    いない場合、ＤＸライブラリではＣＰＵによって３Ｄアクセラレータでやっていた
                    事をエミュレートします。<br>
                    　ですが３Ｄアクセラレータでやっていた事をＣＰＵで真似るのは相当の処理
                    負荷となり、特に半透明系のグラフィック描画処理は場合によっては１００倍
                    近い負荷差が生じます。<br>
                    　この関数はその高い負荷をエミュレートの精度を下げる事によって実現しています。<br>
                    　デフォルトでは半透明や加算半透明は <a href="dxfunc_graph1.html#R3N17"><b>SetDrawBlendMode</b></a> で設定する事が
                    出来、その精度は０～２５５と２５６段階ありますが、この関数を使用して簡略化
                    された処理に変更すると処理負荷は精度を下げる前に比べ０．５～０．８倍まで
                    軽減できる代わりに精度は１６段階に丸めこまれます。<br>
                    　精度よりも速度を優先したい場合は引数に TRUE を、速度よりも精度を優先
                    したい場合は FALSE を引数に渡してください。<br><br>

                    　なお、SetDrawBlendMode で指定するパラメータ値は１６段階にする必要は
                    ありません。ライブラリ側が描画時に勝手に２５６段階を１６段階に丸めこみます。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R15N16"><b>SetScreenMemToVramFlag</b></a> のサンプルを参照して下さい            <br><br><br><br>

        </td></tr> -->


<!--        <tr><td><table align="center" width="800" cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="70"><b><a name="R15N29">宣言</a></b></td>
            <td><font color="#000088"><b>int SetMaskReverseEffectFlag( int ReverseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="70"><b>概略</b></td>
            <td>　マスクの数値に対する効果を逆転させるかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="70"><b>引数</b></td>
                <td>ReverseFlag : 効果を逆転させるかどうかのフラグ<br>
                　　　　　　　　　　( TRUE:逆転させる FALSE:逆転させない )</td>
            </tr>
            <tr><td valign="top" width="70"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="70"><b>解説</b></td>
                <td>　本リファレンスの <a href="dxfunc_graph4.html#R16N1"><b>CreateMaskScreen</b></a> 関数の説明には
                    マスクスクリーン上のの１の部分は元の画像が残り、０の部分は新たな
                    描画処理により画像が書き換わる、と書いてありますが、なんと
                    Ver1.98( 2002年 9月 ) から Ver2.14e( 2004年 11月 )までの約２年間、
                    実際の効果はずっとリファレンスに書かれている事と逆、つまりマスク
                    スクリーン上の０の部分は元の画像が残り、１の部分は新たな描画処理に
                    より画像が書き換わる、というようになっていました。<br>
                    　Ver2.14f からは Ver1.98 以前のようにリファレンス通りの効果に
                    戻ったのですが、前述どおり約２年もの間効果が逆になっていたため、
                    効果が逆になっていることを前提にマスク機能を使っている方がいる
                    ことは火を見るより明らかです。<br><br>

                    　そんなわけでその応急処置として追加されたのがこの関数です。<br>
                    　この関数に TRUE を渡して呼んで頂ければ、マスクスクリーンに
                    書き込んだ値に対する効果は Ver1.98 ～ Ver2.14e までのように<br><br>

                    ０＝元の画像が残る<br>
                    １＝新しい画像が書き込まれる<br><br>

                    　となります。<br>
                    　大変申し訳ありませんが、この２年の間に当機能を使用されていた
                    方は対応の方よろしくお願いします。orz<br><br>

                    <font color="#660000"><b>
                    注意…この関数は <a href="../dxfunc.html#R1N1">DxLib_Init</a> の前に使用することは出来ません。<br>
                    　　　更に、この関数の設定は <a href="#R11N1">ChangeWindowMode</a>関数, <a href="dxfunc_graph3.html#R4N1">SetGraphMode</a>関数,<br>
                    　　　<a href="#R15N16">SetScreenMemToVramFlag</a>関数 を使用するとリセットされますので、<br>
                    　　　その場合は再設定する必要があります。<br>
                    </b></font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br>
        </td></tr> -->



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N12">宣言</a></b></td><td><font color="#000088"><b>int LoadPauseGraph( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　フォーカスが他のソフトに移っているときにバックグラウンドに表示するグラフィックのロード、登録(NULL で解除)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>char *FileName : バックグラウンドに描画するグラフィックファイルパス</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　　ウインドウモード時に他のソフトのウインドウがアクティブになって<br>
                    ＤＸライブラリソフトが一時停止している間常にバックグラウンドで<br>
                    表示しておくグラフィックのロード、および登録を行います。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません<br><br><br><br>

        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N19">宣言</a></b></td><td><font color="#000088"><b>int    ScreenCopy( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　画面コピー関数、画面の裏ページ（普段は表示されていない）を 表ページ（普段表示されている）にコピーする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="dxfunc_graph3.html#R4N7"><b>ScreenFlip</b></a> 関数は裏画面と表画面の内容を取りかえる関数
                    でしたが、この関数は『取りかえる』のではなくコピーします、複写
                    です。<br>
                    　『取りかえる』場合、裏画面に来る画像は前々回フレームで扱った
                    ものとなり、その画像をリサイクルすることは困難ですが、複写では
                    裏画面には今の今まで扱っていた画像が残りますので、画面の一部だけ
                    更新して再び表画面にコピー表示する等のことが出来、このような場合
                    画面すべてを更新するよりも大幅な処理負荷の軽減を果たす事が出来ます。<br><br>

                    　基本的には ScreenCopy関数 は ScreenFlip関数 よりも多少処理負荷が
                    ありますので上記のような処理をしない場合は ScreenCopy関数 を使う
                    ことによるご利益はありません。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません
            <br><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N6">宣言</a></b></td><td><font color="#000088"><b>int    GetColorBitDepth( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　画面の色ビット数を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>画面モードのカラービット数<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　画面モードのカラービット数を得ます。これは<a href="dxfunc_graph3.html#R4N1">SetGraphMode関数</a>で言うところの
                    ColorBitNum 引数に当たる数値です。<br>
                    　これは主にウインドウモードで実行するソフト等で実行時にはどのカラービット数
                    かわからない時等に使います。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません<br><br><br><br>
        </td></tr>





        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N11">宣言</a></b></td><td><font color="#000088"><b>int SaveDrawScreen( int x1, int y1, int x2, int y2, char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　現在描画対象になっている画面をＢＭＰ形式で保存する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>int x1 ,y1 : 保存する領域の左上座標<br>
                    int x2 ,y2 : 保存する領域の右下＋１座標<br>
                    char *FileName : 保存時のファイル名</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　現在描画対象になっている画面の特定領域をＢＭＰ形式の画像
                    ファイルにして記憶装置(ハードディスク等)に保存します。<br><br>

                    　保存したい領域の一番左上に位置するドット座標を x1,y1 に
                    保存したい領域の一番右下＋１に位置するドット座標を x2,y2 に
                    セットします。<br><br>

                    　例　６４０×４８０の画面全体を Save.bmp として保存する<br><br>

                        SaveDrawScreen( 0 , 0 , 640 , 480 ) ;<br><br>

                    　x2,y2 の値を『保存したい領域の一番右下＋１に位置するドット
                    座標』にしたのはその方が直感的である、と判断したためです。
                    ( 例　『保存したい領域の一番右下に位置するドット座標』にした場合<br>
                        SaveDrawScreen( 0 , 0 , 639 , 479 ) ;<br>
                    　のように分かりにくく、間違いやすい記述をしなくてはならない。)<br><br>

                    ＜補足＞<br>
                    　拡張子『.bmp』は自動的には付きませんので注意してください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　test1.bmp を読み込み、赤成分を抜いた状態で画面に描画し、その結果を
                Save.bmp というファイル名で保存します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int GraphHandle ;

    // 画面モードを１６ビットカラーにセット
    SetGraphMode( 640 , 480 , 16 ) ;

    // ＤＸライブラリ初期化
    if( DxLib_Init() == -1 )    return -1 ;

    // 画像のロード
    GraphHandle = LoadGraph( "test1.bmp" ) ;

    // 描画輝度を設定、赤成分を０にする
    SetDrawBright( 0 , 255 , 255 ) ;

    // 画面に描画
    DrawGraph( 0 , 0 , GraphHandle , FALSE ) ;

    // 画面全体を Save.bmp として保存
    SaveDrawScreen( 0 , 0 , 640 , 480 , "Save.bmp" ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    DeleteGraph( GraphHandle ) ;

    // ＤＸライブラリ使用の終了処理
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N20">宣言</a></b></td><td><font color="#000088"><b>int EnumFontName( char *NameBuffer , int NameBufferNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　使用可能なフォントの名前を列挙する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>char *NameBuffer : フォントの名前を格納する２次元配列の先頭アドレス<br>
                int NameBufferNum : 列挙するフォント名の最大数</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>列挙したフォント名の数<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　この関数は、パソコンにインストールされているフォントの名前を
                    列挙することが出来ます。<br>
                    　<a href="dxfunc_graph2.html#R17N9"><b>ChangeFont</b></a> や <a href="dxfunc_graph2.html#R17N10"><b>CreateFontToHandle</b></a> 等の関数は任意の名前を持つフォントの
                    データハンドルを作成することが出来るものの、標準以外のフォントは
                    パソコン個々でインストールされているものが違ったり、又はなかったり
                    するので、あるかどうかもわからないフォントを下手に指定することは
                    あまり望ましくありません。<br><br>

                    　そんな時にこの関数です。<br>
                    　この関数はパソコンにインストールされているＤＸライブラリで使用
                    可能なフォントの名前をすべて列挙し、指定の文字列配列に格納することが
                    出来ます。<br>
                    　この関数で列挙したフォントはすべて ChangeFont や CreateFontToHandle 等で
                    使うことが出来るので、自分の使いたいフォントがパソコンにインストール
                    されているか調べたい時や、サウンドノベルなどの文章表示に使うフォントを
                    プレイヤーに選択してもらったりする時に利用できます。<br><br>

                    　さて使い方です。<br>
                    　まず一つのフォントの名前を格納するのに、ＤＸライブラリでは余裕を
                    持って半角６３文字分入る char 型配列を一つを使います。<br><br>
<pre><div class="NormalFont">    char NameBuffer[64] ;    // フォント一個分
</div></pre>
                    　つまり、十個分のフォント名を格納するためにはこれが十個必要なわけ
                    ですから<br><br>
<pre><div class="NormalFont">    char NameBuffer[10][64] ;    // フォント十個分<br><br>
</div></pre>
                    　という２次元配列になります。<br>
                    　とりあえずパソコンにインストールされているフォント１０個分の名前を
                    取得する例を次に示します。<br>
<pre><div class="NormalFont">    char NameBuffer[10][64] ;

    EnumFontName( &amp;NameBuffer[0][0] , 10 ) ;
</div></pre>
                    　とまあこんな感じです。これで NameBuffer[0] から NameBuffer[9] までの
                    文字列配列にフォント名が入ります。<br>
                    　もしインストールされているフォントが１０個以下だった場合はすべての
                    配列にはフォント名は格納されません、実際列挙されたフォントの数は
                     EnumFontName 関数の戻り値として返って来るので、この値を参照することに
                    より幾つのフォントが列挙されたのか知ることが出来ます。<br><br>
<pre><div class="NormalFont">    char NameBuffer[10][64] ;
    int FontNum ;

    FontNum = EnumFontName( &amp;NameBuffer[0][0] , 10 ) ;
</div></pre>
                    　これでもし FontNum に５が代入されたら、１０個分のフォント名が列挙
                    出来る配列を渡したものの、実際には５個のフォント名しか列挙されなかった、
                    ということになります。<br><br>
                    
                    　次に列挙したフォントをＤＸライブラリの文字列描画で使う方法を示します。<br>
                    　例えば上の例で列挙した一番最初のフォントを描画用フォントにしたい場合は<br><br>
<pre><div class="NormalFont">    ChangeFont( NameBuffer[0] ) ;
</div></pre>
                    　とすることで変更できます。もし０番目に『ＭＳ 明朝』というフォント名が
                    格納されていたらこれ以後文字列描画に使われるフォントは ＭＳ 明朝体 に
                    変更されます。<br><br><br>


                    　これで列挙して利用するまでの一通りの説明は終りましたが、次に数を限定せずに
                    すべてのフォントを列挙する方法を解説したいと思います。<br>
                    　実際はバッファの数を２００個などにしてしまえば、恐らくインストールされている
                    すべてのフォントを列挙することが出来るとは思いますが、世の中どれだけ沢山の
                    フォントをパソコンにインストールしている人がいるのかわかりませんので、一応
                    どんな状況でもすべてのフォント名を列挙する方法を示しておきたいと思います。<br><br>

                    　まず EnumFontName 関数の第１引数、つまりフォントネームを格納する配列
                    のアドレスを NULL にし、第２引数を０にして関数を呼び、戻り値を得ます。<br><br>
<pre><div class="NormalFont">    int FontNum ;

    FontNum = EnumFontName( NULL , 0 ) ;
</div></pre>

                    　すると、フォントネームは取得できないものの、フォントの数だけはしっかり
                    戻り値として返ってきます。この時戻り値として返ってくるのはパソコンに
                    インストールされているすべてのフォントの数です。<br>
                    　つまりこの戻り値の数分だけフォント名を格納出来るサイズを持った配列が
                    あればすべてのフォント名を列挙することが出来ます。が、実際にはプログラムの
                    実行中に動的にサイズを変えられる配列は存在しません。<br>
                    　ので、ここはＣの標準関数である malloc を使います。この関数はパソコン上の
                    空きメモリから任意のサイズのメモリ領域を確保することが出来るので、これを
                    使ってすべてのフォント名を格納できるメモリ領域を確保することにします。<br><br>

                    　確保すべきメモリの量は ６４バイト×戻り値 となります。６４バイトというのは
                    言うまでもなく一つのフォント名に必要なメモリ領域です。(半角１文字の情報を
                    表現するのに必要なデータサイズは１バイト)<br>
                    　確保したメモリ領域のアドレスは char 型のポインタに格納します。<br><br>
<pre><div class="NormalFont">    #include &lt;malloc.h&gt;

    char *NameBuffer ;
    int FontNum ;

    FontNum = EnumFontName( NULL , 0 ) ;

    // フォント名の数分だけメモリを確保
    NameBuffer = ( char * )malloc( 64 * FontNum ) ;
</div></pre>

                    　次に確保したこのメモリ領域にフォント名を列挙し格納します。<br><br><br>

<pre><div class="NormalFont">    #include &lt;malloc.h&gt;

    char *NameBuffer ;
    int FontNum ;

    FontNum = EnumFontName( NULL , 0 ) ;
    NameBuffer = ( char * )malloc( 64 * FontNum ) ;
    EnumFontName( NameBuffer , FontNum ) ;
</div></pre>

                    　これで確保したメモリ領域にデータを格納することができました。<br>
                    　実際に使う時の注意としては、確保したメモリ領域は二次元配列ではないので、
                    フォント名を指定する時は<br><br>

                        確保したメモリの先頭アドレス ＋ 取得したフォント名の番号 × ６４<br><br>

                    　と指定してやる必要があると言うことです。<br><br><br>


                    例    ３番目に列挙されたフォント名を持つフォントに変更する<br><br><br>

<pre><div class="NormalFont">    ChangeFont( NumeBuffer + 3 * 64 ) ;<br><br><br>
</div></pre>

                    　もう一つ注意すべきことは、列挙したフォント名が要らなくなったら確保した
                    メモリ領域を開放してやる必要があると言うことです。最後にはしっかり
                     free 関数でメモリ領域を開放するということを忘れないで下さい。<br><br><br>

<pre><div class="NormalFont">    free( NameBuffer ) ;<br><br>
</div></pre>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                    　１０個分のフォント名が入る配列にフォント名を最大１０個列挙し、４番目に
                    列挙されたフォントを描画用フォントにして画面に文字を描画します。
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    char NameBuffer[10][64] ;
    int FontNum ;

    // ＤＸライブラリ初期化処理
    if( DxLib_Init() == -1 ) return -1 ;


    // フォントを最大１０個列挙
    FontNum = EnumFontName( &amp;NameBuffer[0][0] , 10 ) ;

    // ４個以下しかフォント名が列挙されなかったら次の処理は行わない
    if( FontNum &gt;= 4 )
    {
        // ４個目に列挙されたフォント名を持つフォントに変更
        ChangeFont( NameBuffer[3] ) ;

        // 変更したフォントで文字を描画し、その後フォント名も描画
        DrawString( 100, 100, "４個目のフォントはなんだろう" , GetColor( 255, 255, 255 ) ) ;
        DrawString( 100, 130, NameBuffer[3] , GetColor( 255, 255, 255 ) ) ;
    }

    // キー入力を待つ
    WaitKey() ;

    // ＤＸライブラリ使用の終了処理
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
<hr>
<br><br>
                    　インストールされているすべてのフォントの名前を列挙し、列挙に必要なメモリを
                    確保したあと、フォント名を格納します。その後フォントのサイズを大きくし、
                    列挙した一番目から十番目までのフォント名を画面に描画します。
<hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"
#include &lt;malloc.h&gt;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    char *NameBuffer ;
    int FontNum ;
    int i ;

    // ＤＸライブラリ初期化処理
    if( DxLib_Init() == -1 ) return -1 ;

    // フォントの数を取得
    FontNum = EnumFontName( NULL , 0 ) ;

    // メモリの確保
    NameBuffer = ( char * )malloc( FontNum * 64 ) ;

    // フォント名の取得
    EnumFontName( NameBuffer , FontNum ) ;

    // フォントのサイズを変更
    SetFontSize( 32 ) ;

    // 最初から１０番目までのフォント名を画面に描画
    if( FontNum &gt;= 10 ) FontNum = 10 ;
    for( i = 0 ; i &lt; FontNum ; i ++ )
    {
        // フォントの変更
        ChangeFont( NameBuffer + 64 * i ) ;

        // フォント名の描画
        DrawString( 100 , i * 40 , NameBuffer + 64 * i , GetColor( 255, 255, 255 ) ) ;
    }

    // 確保したメモリの解放
    free( NameBuffer ) ;

    // キー入力を待つ
    WaitKey() ;

    // ＤＸライブラリ使用の終了処理
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
<hr>
        <br><br>        
        </td></tr>





        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N8">宣言</a></b></td><td><font color="#000088"><b>int DrawVString( int x, int y, char *String, int Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　文字列を縦に描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>    x , y　 : 文字列を描画する領域の左上の座標<br>
                    String　: 描画する文字列のポインタ<br>
                    Color　 : 描画する文字列の色</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　　<a href="dxfunc_graph2.html#R17N1"><b>DrawString</b></a> 関数の縦書きバージョンです。<br>
                    　具体的には文字列が９０度回転した状態で描画されます。<br>
                    　なので、縦書き用フォントを使用しないと日本語は横向きに描画されてしまいます。<br>
                    (縦書き用フォントはフォント名の前に『@』を付けることによって縦書き
                    用フォントを指定したことになります。(縦書き用フォントが用意されていない
                    フォントもありますのでご注意ください))<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　描画用フォントを縦書き用フォントに変更した後、文字列を描画する<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
         return -1;    // エラーが起きたら直ちに終了

    // 縦書きフォントを指定
    ChangeFont( "@ＭＳ 明朝" ) ;

    // 文字列を縦書き
    DrawVString( 0, 0, "縦書きフォント", GetColor( 255,255,255 ) ) ;

    // キー入力待ち
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N9">宣言</a></b></td><td><font color="#000088"><b>int DrawVStringToHandle( int x, int y, const char *String, int Color, int FontHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>　フォントハンドルを使用して文字列を縦に描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int x , y : 文字列を描画する起点座標<br>
                char *String : 描画したい文字列のポインタ<br>
                int Color : 描画する文字列の色を示すカラーコード<br>
                int FontHandle : 描画に使用するフォントのデータ識別番号(フォントハンドル)</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　　<a href="dxfunc_graph2.html#R17N12"><b>DrawStringToHandle</b></a> 関数の縦書きバージョンです。<br>
                    　具体的には文字列が９０度回転した状態で描画されます。<br>
                    　なので、縦書き用フォントを使用しないと日本語は横向きに描画されてしまいます。<br>
                    (縦書き用フォントはフォント名の前に『@』を付けることによって縦書き
                    用フォントを指定したことになります。(縦書き用フォントが用意されていない
                    フォントもありますのでご注意ください))<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　縦書き用フォントを使用したフォントハンドルを作成した、文字列を描画する<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int FontHandle ;

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
         return -1;    // エラーが起きたら直ちに終了

    // 縦書きフォントを作成
    FontHandle = CreateFontToHandle( "@ＭＳ 明朝", -1, -1, -1 ) ;

    // 文字列を縦書き
    DrawVStringToHandle( 0, 0, "縦書きフォント", GetColor( 255,255,255 ), FontHandle ) ;

    // 作成したフォントハンドルを削除する
    DeleteFontToHandle( FontHandle ) ;

    // キー入力待ち
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>



<!--    <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N3">宣言</a></b></td><td><font color="#000088"><b>
                int    GraphLock( int GrHandle ,<br>
                　　　　　　　 int *PitchBuf , void **DataPointBuf  ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>グラフィックメモリ領域のロック<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>GrHandle 　　:　ロックするグラフィックのハンドル(または画面の識別子)<br>
                    PitchBuf 　　:　ロックするグラフィックの１ライン辺りの<br>
                    　　　　　　　　バイト数を保存する変数へのポインタ<br>
                    DataPointBuf :　グラフィックデータのあるメモリへのアドレスを<br>
                    　　　　　　　　保存するポインタへのポインタ</td>
            </tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　グラフィックデータのあるメモリ領域には『ロック』をしなくては
                    アクセスする事が出来ません。細かい事は抜きにしてとにかくWindows
                    環境ではメモリの管理が厳重なので malloc関数 などで確保したメモリ
                    領域のように簡単にはアクセスは出来ないようになっています。だから
                    『ロック』という作業を行い直接アクセスできるようにします。<br>
                    　グラフィック領域に直接アクセスする利点は<a href="#R2N4"><b>DrawPixel</b></a> や <a href="#R2N5"><b>GetPixel</b></a>
                    関数を使用するよりも処理が速い、等があります。<br><br>

                    　ロックの説明をはじめる前に注意なのですが、ロックを行った場合は
                    直接アクセスが終り次第直ちにロックを解除してください。ロックを
                    している最中にデバッグモードなどのブレークポイントを使ってプロ
                    グラムを止めるとハングアップするので注意してください。ロックを
                    すると <a href="#R12N4"><b>『GraphUnLock』関数</b></a>を使用してロックを解除しない限り
                    <a href="#R2N1"><b>DrawLine</b></a>をはじめすべての描画関数が使用不可能になるので注意して
                    ください。<br><br>

                    　では話を元に戻します。<br>
                    　ロックをするにはまずロックをしたいグラフィックハンドル、または
                    DX_SCREEN_FRONT , DX_SCREEN_BACK 識別子を使って画面をロックする
                    事も出来ます。<br>
                    　ロックが完了すると関数は PitchBuf に指定したポインタにロック
                    したグラフィック領域の１ライン辺りのバイト数と、DataPointBuf で
                    指定したポインタにロックしたグラフィックへのアドレスが代入されます。<br><br>
                    
                    　こうしてロックしたグラフィック領域にはめでたく直接アクセスが
                    出来るようになります。まず希望の座標（点）にアクセスするには
                    以下の式を用います<br><br>

                    　　(グラフィック領域の先頭アドレス) ＋<br>
                    　　(Ｘ座標値 × (グラフィックのカラービット数 ÷ ８)) ＋<br>
                    　　(Ｙ座標値 × １ライン辺りのバイト数) <br><br>
                    
                    　　＝ 希望の座標のポインタ<br><br>

                    　この中の『グラフィック領域の先頭アドレス』と言うのは DataPointBuf
                    から取得できる値、『１ライン辺りのバイト数』は PitchBuf から取得できる値
                    『グラフィックのカラービット数は』<a href="dxfunc_graph3.html#R4N1"><b>SetGraphMode関数</b></a> の 引数
                    ColorBitNum の値（デフォルトでは１６です）となります。<br><br>

                    　次に１ドット辺りのビット数はカラービット数と比例します、以下に
                    カラービット数と一般のデータ型との比例関係を示します。<br><br>

                    　　８bitカラー　　　　　char 型と同サイズ<br>
                    　　１６bitカラー　　　　short 型と同サイズ<br>
                    　　３２bitカラー　　　　int 型と同サイズ<br><br>

                    　もし１６ビットカラーのグラフィックに１ドット分データのアクセスを
                    するつもりで int 型変数で値を代入した場合は２ドット分描画してしまう
                    ので注意してください。（アドレスの算出のときも同じです）<br><br>

                    注 … グラフィックをロックする場合は <a href="#R15N1">SetUse3DFlag</a> 関数で３Ｄ機能を使わない
                    　　設定にしてから<a href="dxfunc_graph1.html#R3N2">LoadGraph</a>,<a href="dxfunc_graph1.html#R3N6">MakeGraph</a>等で作られたグラフィックでないと
                    　　ロックは失敗します。
                    
                    例　　１２８×１２８のグラフィックデータを作成し、座標( 24 , 11 )<br>
                    　　の点に色コード０を代入します。（１６ビットカラー）<br><br>

                    
<pre><div class="NormalFont">    char *GraphData ;
    short *DrawPoint ;
    int Pitch , GHandle ;

    // グラフィックの作成
    GHandle = MakeGraph( 128 , 128 ) ;

    // グラフィックのロック
    GraphLock( GHandle , &Pitch , &GraphData ) ;

    // 座標( 24 , 11 )のデータのアドレスを算出
    DrawPoint = ( short * )( GraphData + 
                24 * ( 16 / 8 ) +
                11 * Pitch ) ;

    // 色コード０を代入します
    *DrawPoint = 0 ;

    // ロックを解除します
    GraphUnLock( GHandle ) ;
</div></pre>
                    <br><br><br>

                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　表画面をロックして直接アクセスで画面にグラデーションを描きます<br>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int i , j , k ;
    int Pitch ;
    short *DrawPoint , Cr ;
    char *GraphData ;

    if( DxLib_Init() == -1 )    // ＤＸライブラリ初期化処理
    {
         return -1;    // エラーが起きたら直ちに終了
    }

    // 表画面をロックします
    GraphLock( DX_SCREEN_FRONT , &Pitch , ( void ** )&GraphData ) ;

    // 画面にグラデーションを描きます
    for( i = 0 ; i &lt; 480 ; i ++ )
    {
        for( j = 0 ; j &lt; 640 ; j ++ )
        {
            // 色の値を取得
            k = 255 * i / 480 ;
            Cr = ( short )GetColor( k , k , k ) ;

            // 描画する座標のポインタを計算
            DrawPoint = ( short * )( GraphData +
                         j * ( 16 / 8 ) + 
                         i * Pitch ) ; 

            // グラフィックデータへの直接アクセスで点を描画
            *DrawPoint = Cr ;
        }
    }

    // 表画面のロックを解除(『GraphUnLock』使用)
    GraphUnLock( DX_SCREEN_FRONT ) ;

    // キーの入力待ち
    WaitKey() ;

    DxLib_End() ;        // ＤＸライブラリ使用の終了処理

    return 0 ;        // ソフトの終了
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>    -->

<!--        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N4">宣言</a></b></td><td><font color="#000088"><b>int    GraphUnLock( int GrHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>グラフィックメモリ領域のロック解除<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>GrHandle : ロックしたグラフィックのハンドル（または画面の識別子）</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　GraphLock関数 でロックしたグラフィック（または画面）の
                    ロックを解除します。ロックしたらなるべく早くこの関数で
                    ロックを解除してください。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<a href="#R12N3"><b>『GraphLock』関数</b></a> のサンプルを参照してください<br>
            <br><br><br>
        </td></tr> -->





        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N26">宣言</a></b></td><td><font color="#000088"><b>int CreateGraphFromMem( void *MemImage, int MemImageSize ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　メモリ上の画像ファイルイメージからグラフィックハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                MemImage : 画像ファイルの内容が丸々存在するメモリ上のアドレス<br>
                MemImageSize : 画像ファイルのサイズ
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０以上：新しいグラフィックハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　グラフィックハンドルの作成は主に <a href="dxfunc_graph1.html#R3N2"><b>LoadGraph</b></a> などで行いますが、
                    これらの関数ではＤＸライブラリが読み込みに対応したグラフィック形式(ＢＭＰ，ＰＮＧ，ＪＰＥＧ，ＡＲＧＢ，ＴＧＡ，ＤＤＳ)で保存されたファイルが誰でもアクセス出来るディスク(
                    又はそれ以外の補助記憶装置 )上に存在していなければなりません。<br>
                    　ＤＸライブラリが対応しているグラフィック形式は決して特別なものではないので、
		    グラフィックが保存されているディスクにアクセスすれば誰でもソフトで使われている画像を閲覧する事が出来てしまいます。
		    ゲーム中では苦労しないと見れない画像も同じように簡単に見れてしまうので、
		    普通に考えてもこの状況はあまり好ましくありません。<br><br>

                    　と、いうところで思いつくのがファイルの暗号化です。<br>
                    　例えば、画像ファイルのデータ全てにＮＯＴ演算( ~ )を掛けておけば、
		    ＮＯＴ演算されたデータを元に戻さない限り誰も画像ファイルの中身を覗く事は出来ません。<br>
                    　しかし、そのままではＤＸライブラリでも読み込むことが出来ませんので、
		    読み込む前にデータを元に戻す必要があります。<br><br>

                    　その手順は、ファイルをまずメモリ上に読み込み、元のデータに戻す処理を施した後・・・・後、
		    どうすればいいのでしょうか？<br>
                    　LoadGraph で読み込むにはファイルとしてディスク上に存在していなければなりませんので、
		    例えば一時的に元に戻したデータをファイルに保存して、
		    LoadGraph でグラフィックハンドルを作成した直後に削除する・・・確かにこの方法であれば実現可能です。<br>
                    　・・・ですが、あんまり良い方法とはとても思えません。さてどうしましょう。<br><br>

                    　という時に役に立つのがこの CreateGraphFromMem という関数です。<br>
                    　この関数は、ＤＸライブラリが読み込むことが出来るグラフィックファイル(
		    ＢＭＰ，ＰＮＧ，ＪＰＥＧ，ＡＲＧＢ，ＴＧＡ，ＤＤＳ )のデータを、
		    ファイルからではなくメモリ上から読み込んでグラフィックハンドルを作成出来ます。<br><br>

                    　第一引数の MemImage にはグラフィックファイルのデータが丸々存在するメモリ領域の先頭アドレスを、
		    第二引数の MemImageSize にはメモリ上に存在するグラフィックファイルデータのサイズをバイト単位で渡します。<br><br>

                    　用途は主に先ほどの例の通り、閲覧可能なファイル形式のままディスクに画像データを保存しておきたくない時等に使用します。<br><br>

                    　尚、CreateGraphFromMem 関数に渡したグラフィックファイルデータはグラフィックハンドルが作成し終わった後は必要ありませんので、
		    データを格納していたメモリ領域を malloc や new で確保していた場合は解放してしまっても大丈夫です。<br><br>
<!--
                    <font color="#660000"><b>
                    &lt;&lt;注意&gt;&gt;<br>
                    　この関数で作成れたグラフィックハンドルはフルスクリーン画面からタスク切り替え等で一時的にデスクトップ画面に戻った場合、
                    再度フルスクリーン画面になった時に画像は自動的に復元されません。<br>
                    　この場合 SetRestoreGraphCallback 関数で登録できる画像復元関数で画像を再度読み込む必要があります。</b></font> -->
                </td>
            </tr>
        </table></td></tr>
        <tr><td>
            <b>サンプル</b><br><br>
                　ＮＯＴ演算で暗号化された画像ファイル Test1.enc をメモリ上に
                読み込んで、元の画像データに戻した後 CreateGraphFromMem 関数を
                使ってグラフィックハンドルを作成する。
            <hr>

	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    FILE *fp ;
    unsigned char *Data ;
    int Size, GrHandle, i ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() == -1 )
        return -1 ;

    // ファイル test1.enc を丸ごとメモリに読み込む
    {
        // バイナリモードで開く
        fp = fopen( "test1.enc", "rb" ) ;

        // ファイルのサイズを得る
        {
            // ファイルポインタをファイルの末端に
            fseek( fp, 0L, SEEK_END ) ;

            // ファイルの末端でファイルポインタのアドレスを
            // 取得すればそれはファイルのサイズ
            Size = ftell( fp ) ;

            // ファイルポインタをファイルの先頭に戻す
            fseek( fp, 0L, SEEK_SET ) ;
        }

        // ファイルを丸々読み込めるメモリ領域を確保する
        Data = ( unsigned char * )malloc( Size ) ;

        // ファイルを丸々読み込む
        fread( Data, Size, 1, fp ) ;

        // ファイルを閉じる
        fclose( fp ) ;
    }

    // ＮＯＴ演算の暗号を解く
    for( i = 0 ; i &lt; Size ; i ++ )
    {
        // ＮＯＴ演算されたデータは、もう一回ＮＯＴ演算をすると元に戻る
        Data[i] = ~Data[i] ;
    }

    // 元に戻ったグラフィックデータでグラフィックハンドルを作成する
    GrHandle = CreateGraphFromMem( Data, Size ) ;

    // グラフィックを作成し終わったらグラフィックデータを
    // 格納していたメモリ領域を開放する
    free( Data ) ;

    // 画像を画面に描画
    DrawGraph( 0, 0, GrHandle, FALSE ) ;

    // グラフィックハンドルの削除
    DeleteGraph( GrHandle ) ;

    // キーが押されるまで待つ
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフト終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N34">宣言</a></b></td><td><font color="#000088"><b>int ReCreateGraphFromMem( void *MemImage, int MemImageSize, int GrHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　メモリ上の画像ファイルイメージから既存のグラフィックハンドルにデータを転送する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                MemImage : 画像ファイルの内容が丸々存在するメモリ上のアドレス<br>
                MemImageSize : 画像ファイルのサイズ<br>
                GrHandle : 画像を転送するグラフィックハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　グラフィックハンドルに、メモリ上の画像ファイルイメージを転送します。<br>
                (画像を転送するグラフィックハンドルを引数として渡す以外は基本的に <a href="#R15N26"><b>CreateGraphFromMem</b></a>と同じです)<br><br>
<!--                　主に <a href="#R15N33"><b>SetRestoreGraphCallback</b></a> で登録する画像復元関数内で使用します。<br> -->
                </td>
            </tr>
        </table></td></tr>
        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N35">宣言</a></b></td><td><font color="#000088"><b>int ReloadFileGraphAll( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　画像ファイルから作成したグラフィックハンドルに再度画像ファイルから画像を読み込む<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　LoadGraph や LoadDivGraph を使用して画像ファイルから画像を読み込み、作成したグラフィックハンドルに、
                再度画像ファイルから画像を読み込み、グラフィックハンドルに転送します。<br>
                　LoadGraph や LoadDivGraph で読み込んだ画像ファイルが既に無い場合は関数は失敗します。<br>
<!--                　主に <a href="#R15N33"><b>SetRestoreGraphCallback</b></a> で登録する画像復元関数内で使用します。 -->
                </td>
            </tr>
        </table></td></tr>
        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N33">宣言</a></b></td><td><font color="#000088"><b>int SetRestoreGraphCallback( void (* Callback )( void ) ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　グラフィックハンドル復元関数を登録する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
                Callback : グラフィックハンドルを復元する処理を行うコールバック関数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　フルスクリーンモードでソフトを実行している時に、
                不意に別のソフト(セキュリティソフト等)がアクティブになり一時的にデスクトップ画面に戻ってしまうことがあります。
                (他にも ALT+TAB キーで自ら別のソフトをアクティブにすることでもデスクトップ画面に戻ります)<br>
                　このとき、グラフィックハンドルが持つ画像の情報は失われてしまいます。<br><br>
                　しかし、一時的にデスクトップ画面になった後、
                再びＤＸライブラリを使用したソフトがアクティブになりフルスクリーン画面に戻ると、
                何事も無かったかのように画像は描画されます。<br><br>

		　また、Android版の場合は作成したアプリを実行中に別のアプリをアクティブにして、その後再度作成したアプリを再度アクティブにした場合も何事も無かったかのように画像は描画されます。<br><br>

		　このタイミングでは <a href="dxfunc_graph1.html#R3N2"><b>LoadGraph</b></a> 関数 や <a href="dxfunc_graph1.html#R3N3"><b>LoadDivGraph</b></a> 関数で読み込んだ画像は OS の動作によって壊れてしまって正常に描画されないはずなのですが、正常に描画され続けます。<br><br>

                　それは何故かといいますと、
                ＤＸライブラリが <a href="dxfunc_graph1.html#R3N2"><b>LoadGraph</b></a> 関数 や <a href="dxfunc_graph1.html#R3N3"><b>LoadDivGraph</b></a>
                関数等の画像ファイルから読み込まれて作成されたグラフィックハンドルの画像を、
                ひそかに再度画像ファイルから読み込んでいるからです。<br><br>

                　というわけで、画像ファイルから読み込まれた画像は何もしなくても問題なく復元されるのですが、
                上記の復元のカラクリでは <a href="dxfunc_graph1.html#R3N6"><b>MakeGraph</b></a>
                で作成したグラフィックハンドルに <a href="dxfunc_graph1.html#R3N12"><b>GetDrawScreenGraph</b></a> で読み取った画像や、
                <a href="dxfunc_graph1.html#R3N25"><b>MakeScreen</b></a> で作成されたグラフィックハンドルに対して描画された画像は復元されません。<br><br>

                　というのも、ＤＸライブラリは MakeGraph や MakeScreen で作成したグラフィックハンドルに対してどのような操作や描画が行われたかは把握していないので、
		その内容を再現することができないからです。<br>
		　なので、その復帰処理はライブラリの使用者に任せるしかない、ということでこの SetRestoreGraphCallback が登場します。<br><br>

                　この関数は失われた画像をグラフィックハンドルに再度読み込んだり描画処理を行って内容を復帰する関数を登録することができ、
                この関数に渡した関数はデスクトップ画面からフルスクリーン画面に戻る際に呼ばれます。<br>
		( Android版の場合は作成したアプリが再度アクティブになったタイミングで呼ばれます )<br><br>

                　失われた画像を再度読み込む関数では、最初に LoadGraph や LoadDivGraph
                で画像ファイルから読み込んだグラフィックハンドルの画像を <a href="#R15N35"><b>ReloadFileGraphAll</b></a>
                を使用して再度画像ファイルから読み込み直した後、MakeGraph で作成したグラフィックハンドルに対して GetDrawScreenGraph で読み取った画像については同じ状況を再現して再度
		GetDrawScreenGraph でグラフィックハンドルに画像を取り込み、MakeScreen で作成したグラフィックハンドルについては内容が失われる前にグラフィックハンドルに対して行った描画処理を再度行う、ということをします。<br><br>
                </td>
            </tr>
        </table></td></tr>
        <tr><td>
            <b>サンプル</b><br><br>
                　MakeScreen 関数で作成したグラフィックハンドル( 中心に四角形を描画したもの )と、LoadGraph 関数で読み込んだ
		グラフィックハンドルを、復元関数内でそれぞれ ReloadFileGraphAll 関数と描画処理で復元するサンプルです。(ESCキーで終了)<br>
            <hr>

	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int GraphHandle1, GraphHandle2;

// ファイルの復元関数
void ReloadFunction( void )
{
    // ファイルから読み込んだ画像を復元する
    ReloadFileGraphAll();

    // MakeScreen で作成したグラフィックハンドルを描画対象にする
    SetDrawScreen( GraphHandle1 );

    // 内容をクリア
    ClearDrawScreen();

    // 中心に四角形を描画する
    DrawBox( 64, 64, 256 - 64, 256 - 64, GetColor( 255,255,255 ), TRUE );

    // 描画先を裏画面に戻す
    SetDrawScreen( DX_SCREEN_BACK );
}

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 画像復元関数を登録
    SetRestoreGraphCallback( ReloadFunction );

    // 256x256 の描画対象にできるグラフィックハンドルを作成する
    GraphHandle1 = MakeScreen( 256, 256 ) ;

    // MakeScreen で作成したグラフィックハンドルを描画対象にする
    SetDrawScreen( GraphHandle1 );

    // 内容をクリア
    ClearDrawScreen();

    // 中心に四角形を描画する
    DrawBox( 64, 64, 256 - 64, 256 - 64, GetColor( 255,255,255 ), TRUE );

    // ファイルから画像を直接読み込む
    GraphHandle2 = LoadGraph( "Test2.bmp" );

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK );

    // メインループ(ＥＳＣキーが押されたらループを抜ける)
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面のクリア
        ClearDrawScreen();

        // 画像の描画
        DrawGraph(   0, 0, GraphHandle1, FALSE );
        DrawGraph( 300, 0, GraphHandle2, FALSE );

        // 裏画面の内容を表画面に反映
        ScreenFlip();
    }

    // グラフィックハンドルを削除
    DeleteGraph( GraphHandle1 ) ;
    DeleteGraph( GraphHandle2 ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>





        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N25">宣言</a></b></td><td><font color="#000088"><b>int SetCreateSoundDataType( int SoundDataType ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　作成する音声データの再生形式を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int SoundDataType : 再生形式の識別値<br>
                　　(　DX_SOUNDDATATYPE_MEMNOPRESS (デフォルト)<br>
                　　　　説明：音声データを直接再生できる状態にしてメモリ上に保存<br>
                　　　　読み込み速度：遅い　再生負荷：速い　必要メモリ領域：大きい<br><br>

                　　　DX_SOUNDDATATYPE_MEMPRESS <br>
                　　　　説明：　圧縮されている音声データをメモリ上に保存、再生時に<br>
                　　　　　　　リアルタイムで圧縮データを展開、音声データが圧縮されて<br>
                　　　　　　　いない場合は DX_SOUNDDATATYPE_MEMNOPRESS よりかえって<br>
                　　　　　　　必要メモリ容量、再生負荷、読み込み速度全ての面で不利になる<br>
                　　　　読み込み速度：普通　再生負荷：少し重い　必要メモリ領域：普通<br><br>

                　　　DX_SOUNDDATATYPE_FILE<br>
                　　　　説明：　音声データを再生時にファイルからリアルタイムに<br>
                　　　　　　　メモリ上に読み込む、音声データが圧縮されている場合は<br>
                　　　　　　　読み込んだ時に展開する<br>
                　　　　読み込み速度：速い　再生負荷：重い　必要メモリ領域：軽い )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="dxfunc_sound.html#R8N4"><b>LoadSoundMem</b></a> で読み込む音声データの扱いを設定します。<br>
                    　デフォルトの状態では LoadSoundMem は読み込んだ音声ファイルを、
                    メモリ上にまるまる保存し、再生に備えます。この方法が一番処理効率が
                    良いのですが、たとえばＢＧＭに使うような巨大な音声ファイルも
                    この方法で再生しようとすると、とたんに大量にメモリ領域を必要とし、
                    ファイルからメモリに読み込む時間もかなりかかってしまい、あまり良いことが
                    ありません。<br>
                    　なので、そんな時にストリーム再生というものをつかいます。<br>
                    　ストリーム再生とは、例えばＢＧＭを再生する場合、音声データを一度に
                    ファイルからメモリに読み込んで再生に備えるのではなく、再生するときに少し
                    づつファイルから音声データを読み込んで、少しづつ再生するという再生
                    方式です。<br>
                    　この方法では、音声ファイル全部をメモリに保存する必要がないので
                    メモリ領域の節約にもなりますし、再生しながらファイルから読み込むので
                    ロードの時間も短くてすみます。いいことがたくさんです。<br><br>

                    　このストリーム再生をするためにあるのがこの SetCreateSoundDataType という
                    わけです。引数は、どんな音声再生方法をとるのか、を識別するint 型の
                    整数値一つで、ファイルからのストリーム再生をしたい場合は、ストリーム再生
                    したい音声ファイルをロードする前に<br><br>

                        SetCreateSoundDataType( DX_SOUNDDATATYPE_FILE ) ;<br><br>

                    　としてやるだけで出来るのです。<br><br><br>


                    　ですが、ストリーム再生には再生時にファイルから逐次音声データを読み
                    込むことになるために、デフォルトの、全て音声データをファイルから読み
                    込んでおく方法に比べて処理負荷が大きくなります。<br>
                    　なので、『パン』や『ドカン』などのちょっとした音が保存された音声
                    ファイルは、ストリーム再生ではなく、デフォルトの全てメモリ上に音声
                    データを読み込んでおく方法をとった方が良いわけで、このあたりは使いわける
                    必要があります。<br><br>

                    　ちなみに DX_SOUNDDATATYPE_MEMPRESS は DX_SOUNDDATATYPE_FILE と
                    DX_SOUNDDATATYPE_MEMNOPRESS の中間的なものです。<br>
                    　音声ファイルにはＷＡＶＥファイルの他にＭＰ３等のＷＡＶＥファイルよりも
                    容量を小さくしたファイル形式があるのはご存知だと思います。このＤＸライブラリ
                    でもそれらのファイルを扱う事が出来ますが、ＤＸライブラリが音声を出力
                    する為に使用している DirectSound はＭＰ３等の所謂『圧縮データ』に対応
                    していない為、再生する際にはＭＰ３等のデータ形式からＰＣＭという何の
                    変哲も無い音声データ形式に変換してやる必要があるのです。<br>
                    　デフォルトの設定ではＤＸライブラリはこの『変換処理』を LoadSoundMem で
                    ファイルをメモリに読み込んだ時に行います。ですが、ＭＰ３からＰＣＭに変換
                    する処理は決して軽い物ではないので、場合によってはＭＰ３より１０倍近い
                    データサイズを持つＷＡＶＥファイルを読み込む場合よりも LoadSoundMem に
                    時間が掛かってしまう場合があるのです。<br>
                    　そういう時は DX_SOUNDDATATYPE_FILE の出番なわけですが、DX_SOUNDDATATYPE_FILE
                    は『ファイルから少し読み込む』→『少しだけ変換』→『少しだけ再生』を繰り返す
                    ので、少々マシンに掛かる負荷が高いのです。<br>
                    　そこで今度は DX_SOUNDDATATYPE_MEMPRESS の出番というわけです。<br>
                    　DX_SOUNDDATATYPE_MEMPRESS も DX_SOUNDDATATYPE_FILE と同じく少しづつ変換、
                    再生を繰り返すのですが、DX_SOUNDDATATYPE_FILE と違いファイルの中身だけは
                    全てメモリ上に読み込んでしまいます。これにより DX_SOUNDDATATYPE_FILE では
                    『ファイルから少し読み込み』→『少しだけ変換』→『少しだけ再生』だった過程が
                    一つ減り『少しだけ変換』→『少しだけ再生』になるわけです。<br>
                    <br>
                    　DX_SOUNDDATATYPE_MEMPRESS と DX_SOUNDDATATYPE_FILE どちらが良いかと訊かれると
                    少し悩みますが、無圧縮のＷＡＶＥファイルに関しては DX_SOUNDDATATYPE_FILE を、
                    圧縮された音声ファイルに関しては DX_SOUNDDATATYPE_MEMPRESS をお使いになる事を
                    お勧めしておきます。<br><br><br>


                    <font color="#660000"><b>
                    注意！…<br>
                    　この関数で DX_SOUNDDATATYPE_NOMEMPRESS 以外の選択をした場合は、
                    以後 ProcessMessage の呼び出し間隔を０．２秒以上空けないようにして下さい。
                    (０．２秒以上空け続けると再生中の音が途切れる現象が発生します)<br>
                    　というのも、解説に記載されている『少し読み込んで(あと変換して)再生する』
                    という処理が ProcessMessage の中で行われているからです。(汗)<br>
                    </b></font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　BGM.wav という音声ファイルをファイルから逐次読み込むストリーム再生方式で
                再生する。(BGNM.wavというファイルはありませんので、自前で用意してください)
    
        <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int SoundHandle ;

    // ＤＸライブラリ初期化処理
    if( DxLib_Init() == -1 ) return -1;

    // 再生形式をファイルからストリーム再生する、に設定
    SetCreateSoundDataType( DX_SOUNDDATATYPE_FILE ) ;

    // BGM.wav を読み込み、ハンドルを取得する
    SoundHandle = LoadSoundMem( "BGM.wav" ) ;

    // 再生
    PlaySoundMem( SoundHandle, DX_PLAYTYPE_LOOP ) ;

    // 何かキーが押されるまで待つ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 ){}

    // サウンドハンドルの削除
    DeleteSoundMem( SoundHandle ) ;

    // ＤＸライブラリ使用の終了処理
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N27">宣言</a></b></td><td><font color="#000088"><b>int LoadSoundMemByMemImage( void *FileImageBuffer, int ImageSize ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　メモリ上の音声ファイルイメージからサウンドハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>FileImageBuffer : 音声ファイルの内容が丸々存在するメモリ上のアドレス<br>
                    ImageSize : 音声ファイルのサイズ</td>
            </tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０以上：新しいサウンドハンドル<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　用途や存在意義は <a href="#R15N26"><b>CreateGraphFromMem</b></a> と同じですので、
                    その辺りの説明は CreateGraphFromMem の解説をご参照ください。<br><br>

                    　メモリ上にＤＸライブラリが読み込める音声ファイル(ＷＡＶ，ＭＰ３，
                    ＯＧＧ)のデータが丸々メモリ上にある場合、この関数を使用すれば
                    メモリ上の音声ファイルイメージからサウンドハンドルを作成出来ます。<br><br>

                    　サウンドハンドルを作成した後は LoadSoundMemByMemImage に渡した
                    音声ファイルイメージは必要ありませんので、メモリ領域を確保して
                    データを格納していた場合は解放してしまっても問題ありません。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　ＮＯＴ演算で暗号化された音声ファイル TestWav.enc をメモリ上に
                読み込んで、元の音声データに戻した後 LoadSoundMemByMemImage 関数を
                使ってサウンドハンドルを作成する。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    FILE *fp ;
    unsigned char *Data ;
    int Size, SoundHandle, i ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() == -1 )
        return -1 ;

    // ファイル testWav.enc を丸ごとメモリに読み込む
    {
        // バイナリモードで開く
        fp = fopen( "testWav.enc", "rb" ) ;

        // ファイルのサイズを得る
        {
            // ファイルポインタをファイルの末端に
            fseek( fp, 0L, SEEK_END ) ;

            // ファイルの末端でファイルポインタのアドレスを
            // 取得すればそれはファイルのサイズ
            Size = ftell( fp ) ;

            // ファイルポインタをファイルの先頭に戻す
            fseek( fp, 0L, SEEK_SET ) ;
        }

        // ファイルを丸々読み込めるメモリ領域を確保する
        Data = ( unsigned char * )malloc( Size ) ;

        // ファイルを丸々読み込む
        fread( Data, Size, 1, fp ) ;

        // ファイルを閉じる
        fclose( fp ) ;
    }

    // ＮＯＴ演算の暗号を解く
    for( i = 0 ; i &lt; Size ; i ++ )
    {
        // ＮＯＴ演算されたデータは、もう一回ＮＯＴ演算をすると元に戻る
        Data[i] = ~Data[i] ;
    }

    // 元に戻ったサウンドデータでサウンドハンドルを作成する
    SoundHandle = LoadSoundMemByMemImage( Data, Size ) ;

    // サウンドハンドルを作成し終わったらサウンドデータを
    // 格納していたメモリ領域を開放する
    free( Data ) ;

    // 音声を再生
    PlaySoundMem( SoundHandle, DX_PLAYTYPE_BACK ) ;

    // キーが押されるまで待つ
    WaitKey() ;

    // サウンドハンドルの削除
    DeleteSoundMem( SoundHandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフト終了
    return 0 ;
}
</div></pre>
            <hr>
	    <FONT COLOR="#008800"><B>Android用</B></FONT>
<pre><div class="NormalFont">Windows用のプログラムの
<B>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )</B>
を
<B>int android_main( void )</B>
に置き換える以外は Windows用のプログラムと同じです。
</div></pre>
            <hr><br><br><br>
        </td></tr>



<!--
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N38">宣言</a></b></td><td><font color="#000088"><b>int SetEnableXAudioFlag( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　サウンドの再生にXAudioを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>Flag ： サウンドの再生に XAudio を使用するかどうかのフラグ<br>
                    　　　　( TRUE：使用する( デフォルト )　FALSE：使用しない )</td>
            </tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ＤＸライブラリは XAudio が使用できる環境の場合デフォルトではサウンドの再生に XAudio を使用しますが、
		XAudio 以前のサウンドシステムである DirectSound より処理負荷が若干高いというデメリットもあります。<br><br>

		　ＤＸライブラリにおける XAudio を使用することのメリットは主に３Ｄサウンドやリバーブエフェクトなので、
		それらが必要ない場合はこの関数の引数 Flag に FALSE を渡して呼んでサウンド処理に DirectSound
		を使用するようにすればサウンドの処理負荷を若干下げることができます。<br><br>

                <font color="#a00000">
		　尚、この関数による設定の変更は DxLib_Init を呼ぶ前でのみ有効ですので注意してください。<br><br>
		</font>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　ありません
            <br><br><br><br><br>
        </td></tr>
-->



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N21">宣言</a></b></td><td><font color="#000088"><b>int SelectMidiMode( int Mode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td>
            <td>　ＭＩＤＩの演奏形態をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>int Mode : ＭＩＤＩの演奏形態<br>
                　　　　　　　　DX_MIDIMODE_DM : DirectMusic による演奏<br>
                　　　　　　　　DX_MIDIMODE_MCI : ＭＣＩによる演奏(デフォルト)</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
            <td>－１：エラー発生<br>
                ０：成功<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<a href="dxfunc_sound.html#R9N1">PlayMusic</a> 関数を使用して演奏できるＭＩＤＩファイルの演奏形態を
                    変更します。<br><br>
                    
                    DX_MIDIMODE_MCI<br><br>

                    　　ＭＣＩ(Media Control Interface)を使用して演奏します。どんな音色で
                    ＭＩＤＩファイルが演奏されるかは各パソコンにインストールされている
                    ＭＩＤＩデバイスに依存します。<br>
                    　ですが、処理速度は DirectMusic を使用した場合に比べてかなり速い
                    です。<br><br><br>


                    DX_MIDIMODE_DM<br><br>

                    　DirectMusic を使用して演奏します。DirectMusic で演奏する場合は
                    DirectMusic が用意する音色で演奏することが出来るため、ＭＣＩを使用
                    する場合と違いどのパソコン環境でも同一の音色で演奏することが出来ます。<br>
                    　ですが、ＭＣＩを使った場合に比べて処理負荷は格段に高くなります。<br><br><br>


                    　というわけで、そもそもＭＩＤＩファイルは使わない。という方は
                    DX_MIDIMODE_MCI を、ＭＩＤＩファイルは使うし、処理が重くなってもどの
                    環境でも同じ音色で演奏したいという方は DX_MIDIMODE_DM をお使いに
                    なられることを推奨します。(^^;<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　ありません
            <br><br><br><br>
        </td></tr>















        
        <tr><td colspan="2">
            <hr>
            <font size="3"><b>
                <a href="../dxfunc.html">戻る</a>
            </b></font>
        </td></tr>
    </table>
    </div>
    </body>
</html>