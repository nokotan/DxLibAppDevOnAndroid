<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja-JP">
    <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <link rel="shortcut icon" href="../DxLib.ico">
    <link rel="stylesheet" href="../style.css" type="text/css">
    <title>ＤＸライブラリ置き場　３Ｄ関係関数リファレンスページ</title>
    </head>
    <body bgcolor="#ffffff" text="#000000" link="#0033CC" vlink="#800040">
    <div class="NormalFont">
    <table align="center" width="600" cellspacing="0" cellpadding="0" >
        <tr><td><font size="3" color="#005500"><b>プログラマブルシェーダー関係関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N38">宣言</a></b></td><td><font color="#000088"><b>int SetUseDirect3DVersion( int Version ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>使用する Direct3D のバージョンを指定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
                <td>
		    Version：Direct3D のバージョン<br>
		　　　　　　　　DX_DIRECT3D_NONE　：Direct3D を使用しない<br>
		　　　　　　　　DX_DIRECT3D_9　　　：Direct3D 9 を使用する<br>
		　　　　　　　　DX_DIRECT3D_9EX　：Direct3D 9Ex を使用する<br>
		　　　　　　　　DX_DIRECT3D_11　　：Direct3D 11 を使用する<br>
                </td>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
		　ＤＸライブラリが使用する Direct3D のバージョンを指定します。<br>
		　Direct3D 9, 9Ex 用のシェーダーと、Direct3D 11 用のシェーダーは別物になるので、
		オリジナルシェーダーを使用する場合はこの関数で使用する Direct3D のバージョンを指定する必要があります。<br><br>

                <font color="#660000"><b>
                ！注意！<br><br>
                　この関数は <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b> 呼び出しの前に使用してください。<br>
                　DxLib_Init 呼び出し後にこの関数を使用しても効果はありませんので注意してください。<br><br>
                </b></font>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="dxfunc_3d_shader.html#R17N37">GetUseDirect3DVersion関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N37">宣言</a></b></td><td><font color="#000088"><b>int GetUseDirect3DVersion( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>使用している Direct3D のバージョンを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Direct3D のバージョン<br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
		　ＤＸライブラリが使用している Direct3D のバージョンを取得します。<br>
		　<b><a href="dxfunc_3d_shader.html#R17N38">SetUseDirect3DVersion</a></b> で使用する Direct3D のバージョンを指定することができますが、
		実行環境が指定のバージョンに対応していない場合は指定したバージョン以外の Direct3D が使用されます( 若しくは Direct3D が使用されない場合もあります )ので、
		特にオリジナルシェーダーを使用する場合は <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b> 呼び出しの後、指定したバージョンの Direct3D が使用されているかをこの関数で確認する必要があります。<br><br>

		戻り値の種類は以下の通りです。<br><br>

		　　<font color="#008800"><b>DX_DIRECT3D_NONE</b></font><br>
		　　　　Direct3Dを使用していない<br><br>

		　　<font color="#008800"><b>DX_DIRECT3D_9</b></font><br>
		　　　　Direct3D 9 を使用している<br><br>

		　　<font color="#008800"><b>DX_DIRECT3D_9EX</b></font><br>
		　　　　Direct3D 9Ex を使用している<br><br>

		　　<font color="#008800"><b>DX_DIRECT3D_11</b></font><br>
		　　　　Direct3D 11 を使用している<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　<b><a href="dxfunc_3d_shader.html#R17N38">SetUseDirect3DVersion</a></b> で Direct3D 9Ex の使用を指定してから DxLib_Init を実行した後、<br>
	    　GetUseDirect3DVersion で Direct3D 9Ex が使用できているかを確認します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int Direct3DVersion ;

    // Direct3D 9Ex の使用を指定
    SetUseDirect3DVersion( DX_DIRECT3D_9EX ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 使用している Direct3D のバージョンを取得
    Direct3DVersion = GetUseDirect3DVersion() ;

    // 使用バージョンが Direct3D 9Ex かどうかをチェック
    if( Direct3DVersion == DX_DIRECT3D_9EX )
    {
        DrawString( 0, 0, "Direct3D 9Ex を使用しています", GetColor( 255,255,255 ) ) ;
    }
    else
    {
        DrawString( 0, 0, "Direct3D 9Ex を使用していません", GetColor( 255,255,255 ) ) ;
    }

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N1">宣言</a></b></td><td><font color="#000088"><b>int GetValidShaderVersion( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>使用できるシェーダーのバージョンを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>シェーダーバージョン×１００</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　使用できるプログラマブルシェーダーのバージョンに１００を掛けた値を取得します。( 戻り値が 200 だったらシェーダーモデル2.0が、300だったらシェーダーモデル3.0が使用可能 )<br>
                    この関数の戻り値が０だった場合はプログラマブルシェーダーを使うことはできません。<br>
                    主にプログラマブルシェーダーが使用できるかどうかを確認するために使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　使用できるシェーダーモデルのバージョンを取得して、シェーダーが使用できるかどうかを画面に表示します。
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ShaderVersion ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 使用できるプログラマブルシェーダーのバージョンを取得
    ShaderVersion = GetValidShaderVersion() ;

    // バージョン番号が０だったら使用不可能
    if( ShaderVersion == 0 )
    {
        DrawString( 0, 0, "プログラマブルシェーダーを使うことはできません", GetColor( 255,255,255 ) ) ;
    }
    else
    {
        // ０以外だったら使用可能
        DrawFormatString( 0, 0, GetColor( 255,255,255 ), "プログラマブルシェーダーバージョン %.1f が使用可能です", ShaderVersion / 100.0f ) ;
    }

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N36">宣言</a></b></td><td><font color="#000088"><b>int GetMultiDrawScreenNum( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>同時に描画を行うことができる画面の数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>同時に描画できる画面の数</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ピクセルシェーダーを使用すると複数の MakeScreen で作成できる描画可能画像に対して同時に描画を行うことができるのですが、
                    それにはグラフィックスデバイスがその機能に対応している必要があります。<br>
                    　この関数はグラフィックスデバイスが持つ同時に描画することができる画面の数を取得します。<br>
                    　複数の画面に対して同時に描画する機能が無い場合は戻り値として１が返ってきます。<br>
                    　主に複数の画面に対して同時に描画処理を実行することが可能かどうかを判定するために使用します。<br>
                    　<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="1000"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N2">宣言</a></b></td><td><font color="#000088"><b>int LoadVertexShader( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーバイナリを読み込みシェーダーハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            FileName ： 頂点シェーダーバイナリファイルのパス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>－１　　　　：　エラー発生<br>
                    －１以外　：　シェーダーハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　頂点シェーダーのプログラムをコンパイルしてできるバイナリファイルをメモリに読み込み、
                    それを使用するためのハンドル( int型の値 )を取得します。<br>
                    　コンパイル前のシェーダープログラムを読み込むことはできませんので注意してください。( シェーダープログラムをコンパイルするためのソフトはＤＸライブラリのパッケージの Tool\ShaderCompiler の中に入っています )<br>
                    　戻り値で得られるシェーダーハンドルは SetUseVertexShader の引数として使用します。<br>
                    　同時に読み込んでおけるシェーダーの数には限りがありますので、必要が無くなったら DeleteShader で削除してください。<br><br><br>

                    <font color="#660000"><b>頂点シェーダーに渡される頂点データについて</b></font><br><br>

                    　今の所頂点シェーダーに渡される頂点データは以下のように固定されています。<br><br><br>

                    <b>DrawPolygon3DToShader, DrawPolygonIndexed3DToShaderの場合<br>
                    ( DrawPolygon2DToShader, DrawPolygonIndexed2DToShader では<br>
                    　頂点シェーダーは使用されません )</b><br><br>

<pre><div class="NormalFont">struct VSInput
{
    // 座標( VERTEX3DSHADER構造体の pos の値 )
    float3 Position        : POSITION0 ;

    // 補助座標( VERTEX3DSHADER構造体の spos の値 )
    float4 SubPosition     : POSITION1 ;

    // 法線( VERTEX3DSHADER構造体の norm の値 )
    float3 Normal          : NORMAL0 ;

    // 接線( VERTEX3DSHADER構造体の tan の値 )
    float3 Tangent         : TANGENT ;

    // 従法線( VERTEX3DSHADER構造体の binorm の値 )
    float3 Binormal        : BINORMAL0 ;

    // ディフューズカラー( VERTEX3DSHADER構造体の dif の値 )
    float4 DiffuseColor    : COLOR0 ;

    // スペキュラカラー( VERTEX3DSHADER構造体の spc の値 )
    float4 SpecularColor   : COLOR1 ;

    // テクスチャ座標０( VERTEX3DSHADER構造体の u, v の値 )
    float2 TextureCoord0   : TEXCOORD0 ;

    // テクスチャ座標１( VERTEX3DSHADER構造体の su, sv の値 )
    float2 TextureCoord1   : TEXCOORD1 ;
} ;
</div></pre>
<br>

                    <b>MV1DrawModel や MV1DrawFrame などの３Ｄモデル描画の場合</b><br><br>

                    剛体メッシュ( １フレームの影響を受ける頂点のみ )の場合<br>
<pre><div class="NormalFont">struct VS_INPUT
{
    float4 Position        : POSITION ;    // 座標( ローカル空間 )
    float3 Normal          : NORMAL0 ;    // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;    // ディフューズカラー
    float4 Specular        : COLOR1 ;    // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;    // テクスチャ座標
} ;
</div></pre>
<br>

                    法線マップ付き剛体メッシュの場合<br>
<pre><div class="NormalFont">struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    float3 Tan             : TANGENT0 ;        // 接線( ローカル空間 )
    float3 Bin             : BINORMAL0 ;    // 従法線( ローカル空間 )
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</div></pre>
<br>

                    １頂点へ影響を与えるフレームの数が１～４個のスキニングメッシュの場合<br>
<pre><div class="NormalFont">struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    int4   BlendIndices0   : BLENDINDICES0 ;    // スキニング処理用 Float型定数配列インデックス
    float4 BlendWeight0    : BLENDWEIGHT0 ;    // スキニング処理用ウエイト値
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</div></pre>
<br>

                    １頂点へ影響を与えるフレームの数が１～４個の法線マップ付きスキニングメッシュの場合<br>
<pre><div class="NormalFont">struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    int4   BlendIndices0   : BLENDINDICES0 ;    // スキニング処理用 Float型定数配列インデックス
    float4 BlendWeight0    : BLENDWEIGHT0 ;    // スキニング処理用ウエイト値
    float3 Tan             : TANGENT0 ;        // 接線( ローカル空間 )
    float3 Bin             : BINORMAL0 ;    // 従法線( ローカル空間 )
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</div></pre>
<br>

                    １頂点へ影響を与えるフレームの数が１～８個のスキニングメッシュの場合<br>
<pre><div class="NormalFont">struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    int4   BlendIndices0   : BLENDINDICES0 ;    // スキニング処理用 Float型定数配列インデックス０
    int4   BlendIndices1   : BLENDINDICES1 ;    // スキニング処理用 Float型定数配列インデックス１
    float4 BlendWeight0    : BLENDWEIGHT0 ;    // スキニング処理用ウエイト値０
    float4 BlendWeight1    : BLENDWEIGHT1 ;    // スキニング処理用ウエイト値１
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</div></pre>
<br>

                    １頂点へ影響を与えるフレームの数が１～８個の法線マップ付きスキニングメッシュの場合<br>
<pre><div class="NormalFont">struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    int4   BlendIndices0   : BLENDINDICES0 ;    // スキニング処理用 Float型定数配列インデックス０
    int4   BlendIndices1   : BLENDINDICES1 ;    // スキニング処理用 Float型定数配列インデックス１
    float4 BlendWeight0    : BLENDWEIGHT0 ;    // スキニング処理用ウエイト値０
    float4 BlendWeight1    : BLENDWEIGHT1 ;    // スキニング処理用ウエイト値１
    float3 Tan             : TANGENT0 ;        // 接線( ローカル空間 )
    float3 Bin             : BINORMAL0 ;    // 従法線( ローカル空間 )
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</div></pre>
<br>


                    <font color="#660000"><b>ＤＸライブラリ内部で設定する頂点シェーダー定数について</b></font><br><br>

                    　ＤＸライブラリでは SetCameraPositionAndTarget_UpVecY などで設定したカメラの設定や SetLightDirection
                    などで設定したライトの設定などはライブラリ内部でシェーダー定数として設定されています。<br>
                    　以下がその一覧です。<br><br><br>

                    　<font color="#008800"><b>Direct3D 11 の場合</b></font><br><br>

                    　　Direct3D 11 版作成直後で今後変更される可能性があるので、今のところリファレンスでは非公開です。<br>
                    　　（ 現在でもＤＸライブラリのソースファイルパッケージの中の Windows\DxShader_VS_D3D11.h と<br>
		    　　　　Shader\Windows\Direct3D11\VertexShader.h で確認することができます ）<br><br><br>

                    　<font color="#008800"><b>Direct3D 9 の場合</b></font><br><br>

                    　　<b>float4型定数</b><br><br>

                    　　0　　　　　x：0.0f　y：1.0f<br>
                    　　1　　　　　マテリアルエミッシブカラー + マテリアルアンビエントカラー * グローバルアンビエントカラー<BR>
                    　　2～5　　　射影行列の転置行列( ビュー座標から射影座標に変換する行列の転置行列 )<br>
                    　　6～9　　　ビュー行列の転置行列( ワールド座標からビュー座標に変換する行列の転置行列 )<br>
                    　　10　　　　フォグ用パラメータ　x：end/(end - start)　 y：-1/(end - start)<br>
                    　　　　　　　　　　　　　　　　　　　 z：density　w：自然対数の低<br>
                    　　11　　　　マテリアルディフューズカラー<BR>
                    　　12　　　　マテリアルスペキュラカラー<BR>
                    　　13　　　　マテリアルスペキュラハイライトのパワー<BR>
                    　　14　　　　有効ライト0番目の位置( ビュー空間 )<br>
                    　　15　　　　有効ライト0番目の方向( ビュー空間 )<br>
                    　　16　　　　有効ライト0番目のディフューズカラー<BR>
                    　　17　　　　有効ライト0番目のスペキュラカラー<BR>
                    　　18　　　　有効ライト0番目のアンビエントカラーとマテリアルのアンビエントカラーを乗算したもの<br>
                    　　19　　　　有効ライト0番目の x：有効距離の二乗　y：Falloff<br>
                    　　　　　　　　　　　　　　　　　　　z：距離減衰パラメータ0　w：距離減衰パラメータ1<br>
                    　　20　　　　有効ライト0番目の x：距離減衰パラメータ1<br>
                    　　　　　　　　　　　　　　　　　y：スポットライト用パラメータ0( cos( Phi / 2.0f ) )<br>
                    　　　　　　　　　　　　　　　　　z：スポットライト用パラメータ1( 1.0f / ( cos( Theta / 2.0f ) - cos( Phi / 2.0f ) ) )<br>
                    　　21～27　　有効ライト1番目のパラメータ( 内訳は 14～20 と同じ )<br>
                    　　28～34　　有効ライト2番目のパラメータ( 内訳は 14～20 と同じ )<br>
                    　　35～41　　有効ライト3番目のパラメータ( 内訳は 14～20 と同じ )<br>
                    　　42　　　　　トゥーンレンダリング用の輪郭線の太さ<br>
		    　　43　　　　　ディフューズカラーとスペキュラカラーのソース<br>
		    　　　　　　　　　　　　　　　　x：ディフューズカラー( 0.0f:マテリアル  1.0f:頂点 )<br>
		    　　　　　　　　　　　　　　　　y：スペキュラカラー( 　0.0f:マテリアル  1.0f:頂点 )<br>
		    　　44～56　　シャドウマップ処理用のパラメータ<br><br>

                    　　57～87　　ライブラリでは未使用<br><br>
                    
                    　　88～89　　テクスチャ座標変換行列の転置行列０( ３Ｄモデル描画時のみ有効 )<br>
                    　　90～91　　テクスチャ座標変換行列の転置行列１( ３Ｄモデル描画時のみ有効 )<br>
                    　　92～93　　テクスチャ座標変換行列の転置行列２( ３Ｄモデル描画時のみ有効 )<br>
                    　　94～96　　ローカル座標からワールド座標に変換する行列を転置して４行目を削ったもの０<br>
                    　　97～255　ローカル座標からワールド座標に変換する行列を転置して４行目を削ったもの１～５３<br>
                    　　　　　　　　　( スキニングメッシュの３Ｄモデル描画時のみ有効 )<br><br><br>

                    　　<b>int4型定数</b><br><br>

                    　　0～15　　　　ライブラリでは未使用<br><br><br>

                    　　<b>BOOL型定数</b><br><br>

                    　　0　　　　　線形フォグかどうか( TRUE：線形フォグ　FLASE：線形フォグ以外 )<br>
                    　　1　　　　　指数関数フォグかどうか( TRUE：指数関数フォグ　FLASE：指数関数フォグ以外 )<br>
                    　　2　　　　　指数関数フォグ２かどうか( TRUE：指数関数２フォグ　FLASE：指数関数２フォグ以外 )<br>
                    　　3　　　　　フォグを使用するかどうか( TRUE：フォグを使用する　FALSE：フォグを使用しない )<br>
                    　　4　　　　　ライト0を使用するかどうか( TRUE：使用する　FALSE：使用しない )<br>
                    　　5　　　　　ライト0はポイントライト若しくはスポットライトかどうか<br>
                    　　　　　　　　　　　( TRUE：ライトポイント又はスポットライト　FALSE：ライトポイント又はスポットライト以外 )<br>
                    　　6　　　　　ライト0はスポットライトかどうか( TRUE：スポットライト　FALSE：スポットライト以外 )<br>
                    　　7～9　　　ライト1のパラメータ( 内訳は 4～6 と同じ )<br>
                    　　10～12　　ライト2のパラメータ( 内訳は 4～6 と同じ )<br>
                    　　12～14　　ライト3のパラメータ( 内訳は 4～6 と同じ )<br><br>

                    　　15　　　　　ライブラリでは未使用<br><br><br>

                    　　　int4型を除く定数がライブラリで殆ど使ってしまっていますが、これらの定数は <b><a href="dxfunc_3d_shader.html#R17N6">SetVSConstF</a></b> などの関数で<br>
		    　　上書き可能で、オリジナルのシェーダープログラムで使用しない定数については上記ライブラリ定数を無視して<br>
		    　　使うことができますのでご安心ください。<br>
                    　　( 例えばライトを使用しない、若しくはオリジナルのライトパラメータを使う、という場合は<br>
		    　　 float4型定数 14～41 を上書きして使用しても問題ありません )<br><br>


                    　<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を貼り付けたポリゴン２枚を頂点シェーダーを使用して左右に動かし、<br>
            　ピクセルシェーダーを使用してフェードアウト、フェードインをさせます。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3DSHADER Vertex[ 6 ] ;
    int vshandle ;
    int pshandle ;
    int texhandle ;
    int x ;
    int xadd ;
    float color ;
    float coloradd ;
    FLOAT4 f4 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセットアップ
    Vertex[ 0 ].pos  = VGet( 220.0f, 340.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet( 420.0f, 340.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 1.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( 220.0f, 140.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 1.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;


    Vertex[ 3 ].pos  = VGet( 220.0f, 140.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 0.0f ;
    Vertex[ 3 ].v    = 1.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    Vertex[ 4 ].pos  = VGet( 420.0f, 340.0f,  0.0f ) ;
    Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 4 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 4 ].u    = 1.0f ;
    Vertex[ 4 ].v    = 0.0f ;
    Vertex[ 4 ].su   = 0.0f ;
    Vertex[ 4 ].sv   = 0.0f ;

    Vertex[ 5 ].pos  = VGet( 420.0f, 140.0f,  0.0f ) ;
    Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 5 ].dif  = GetColorU8( 255,  0,  0,255 ) ;
    Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 5 ].u    = 1.0f ;
    Vertex[ 5 ].v    = 1.0f ;
    Vertex[ 5 ].su   = 0.0f ;
    Vertex[ 5 ].sv   = 0.0f ;

    // 頂点シェーダーを読み込む
    vshandle = LoadVertexShader( "VertexShaderTestVS.vso" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "VertexShaderTestPS.pso" ) ;

    // 描画に使用する画像の読み込み
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 表示座標を移動する処理の初期化
    x = 0 ;
    xadd = 8 ;

    // 色を変化させる処理の初期化
    color = 0.0f ;
    coloradd = 1.0f / 60.0f ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 座標を移動させる
        x += xadd ;
        if( x &gt; 200 || x &lt; -200 )
        {
            xadd = -xadd ;
        }

        // 色の値を変化させる
        color += coloradd ;
        if( color &lt;= 0.0f || color &gt;= 1.0f )
        {
            coloradd = -coloradd ;
        }

        // 座標値を頂点シェーダー float4型定数０番にセット
        f4.x = ( float )x ;
        f4.y = 0.0f ;
        f4.z = 0.0f ;
        f4.w = 0.0f ;
        SetVSConstF( 0, f4 ) ;

        // 色の値をピクセルシェーダー float4型定数０番にセット
        f4.x = color ;
        f4.y = color ;
        f4.z = color ;
        f4.w = 1.0f ;
        SetPSConstF( 0, f4 ) ;

        // 使用する頂点シェーダーのセット
        SetUseVertexShader( vshandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // シェーダーを使用した２ポリゴンの描画
        DrawPolygon3DToShader( Vertex, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 使用した頂点シェーダーの float4型定数の設定を無効化する
    ResetVSConstF( 0, 2 ) ;

    // 使用したピクセルシェーダーの float4型定数の設定を無効化する
    ResetPSConstF( 0, 1 ) ;

    // 読み込んだ頂点シェーダーの削除
    DeleteShader( vshandle ) ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( texhandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>頂点シェーダーのプログラム( コンパイルして VertexShaderTestVS.vso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// 頂点シェーダーの入力
struct VS_INPUT
{
    float4 Position             : POSITION ;    // 座標( VERTEX3DSHADER構造体の pos の値 )
    float3 Normal               : NORMAL0 ;     // 法線( VERTEX3DSHADER構造体の norm の値 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー( VERTEX3DSHADER構造体の dif の値 )
    float4 SpecularColor        : COLOR1 ;      // スペキュラカラー( VERTEX3DSHADER構造体の spc の値 )
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標０( VERTEX3DSHADER構造体の u, v の値 )
    float2 TextureCoord1        : TEXCOORD1 ;   // テクスチャ座標１( VERTEX3DSHADER構造体の su, sv の値 )
} ;

// 頂点シェーダーの出力
struct VS_OUTPUT
{
    float4 ProjectionPosition   : POSITION ;    // 座標( 射影空間 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;


// C++ 側で設定する定数の定義
float4x4 cfViewMatrix       : register( c6 ) ;    // ワールド座標をビュー座標に変換する行列の転置行列
float4x4 cfProjectionMatrix : register( c2 ) ;    // ビュー座標を射影座標に変換する行列の転置行列

// 頂点座標に加算する値
float4 cfAddPosition : register( c0 ) ;


// main関数
VS_OUTPUT main( VS_INPUT VSInput )
{
    VS_OUTPUT VSOutput ;
    float4 lWorldPosition ;
    float4 lViewPosition ;

    // 入力の頂点座標にＣ＋＋プログラム側で設定した頂点座標を加算する
    lWorldPosition = VSInput.Position + cfAddPosition ;

    // 頂点座標をビュー空間の座標に変換する
    lViewPosition = mul( lWorldPosition, cfViewMatrix ) ;

    // ビュー空間の座標を射影空間の座標に変換する
    VSOutput.ProjectionPosition = mul( lViewPosition, cfProjectionMatrix ) ;

    // テクスチャ座標はそのまま代入
    VSOutput.TextureCoord0 = VSInput.TextureCoord0;

    // 頂点カラーはそのまま代入
    VSOutput.DiffuseColor = VSInput.DiffuseColor ;

    // 関数の戻り値がピクセルシェーダーに渡される
    return VSOutput ;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして VertexShaderTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 DrawColor            : COLOR0 ;    // 描画カラー
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler  DiffuseMapTexture      : register( s0 ) ;

// 描画カラーに乗算する値
float4 cfMultiplyColor          : register( c0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ;

    // 出力する色はテクスチャの色と C++ で設定した値とディフューズカラーを乗算したもの
    PSOutput.DrawColor = lTextureColor * cfMultiplyColor * PSInput.DiffuseColor ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</div></pre>
            <hr>

            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="1000"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N3">宣言</a></b></td><td><font color="#000088"><b>int LoadPixelShader( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーバイナリを読み込みシェーダーハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            FileName ： ピクセルシェーダーバイナリファイルのパス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>－１　　　　：　エラー発生<br>
                    －１以外　：　シェーダーハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ピクセルシェーダーのプログラムをコンパイルしてできるバイナリファイルをメモリに読み込み、
                    それを使用するためのハンドル( int型の値 )を取得します。<br>
                    　コンパイル前のシェーダープログラムを読み込むことはできませんので注意してください。( シェーダープログラムをコンパイルするためのソフトはＤＸライブラリのパッケージの Tool\ShaderCompiler の中に入っています )<br>
                    　戻り値で得られるシェーダーハンドルは SetUsePixelShader の引数として使用します。<br>
                    　同時に読み込んでおけるシェーダーの数には限りがありますので、必要が無くなったら DeleteShader で削除してください。<br><br><br>

                    <font color="#660000"><b>ＤＸライブラリ内部で設定するピクセルシェーダー定数について</b></font><br><br>

                    　ＤＸライブラリではフォンシェーディング( ピクセルシェーダーでライティングを行う手法 )の為にマテリアルやライトの設定をライブラリ内部でシェーダー定数として設定しています。<br>
                    　以下がその一覧です。<br><br><br>

                    　<font color="#008800"><b>Direct3D 11 の場合</b></font><br><br>

                    　　Direct3D 11 版作成直後で今後変更される可能性があるので、今のところリファレンスでは非公開です。<br>
                    　　（ 現在でもＤＸライブラリのソースファイルパッケージの中の Windows\DxShader_PS_D3D11.h と<br>
		    　　　　Shader\Windows\Direct3D11\PixelShader.h で確認することができます ）<br><br><br>

                    　<font color="#008800"><b>Direct3D 9 の場合</b></font><br><br>

                      　　<b>float4型定数</b><br><br>

                      　　0　　　　　x：0.0f　 y：0.5f　z：1.0f　w：2.0f<br>
                      　　1　　　　　マテリアルエミッシブカラー + マテリアルアンビエントカラー * グローバルアンビエントカラー<BR>
                      　　2　　　　　マテリアルディフューズカラー<BR>
                      　　3　　　　　マテリアルスペキュラカラー<BR>
                      　　4　　　　　マテリアルスペキュラハイライトのパワー<BR>
                      　　5　　　　　不透明度など<br>
                      　　6　　　　　トゥーンレンダリングの輪郭線の色<br>
                      　　7　　　　　トゥーンレンダリングの輪郭線の太さ<br>
                      　　8　　　　　フォグカラー<BR>
		      　　9　　　　　有効ライト0番目のディフューズカラー<br>
		      　　10　　　 　有効ライト0番目のスペキュラカラー<br>
		      　　11　　　 　有効ライト0番目のアンビエントカラー<br>
		      　　12～14　　有効ライト1番目のパラメータ( 内訳は 9～11 と同じ )<br>
		      　　15～17　　有効ライト2番目のパラメータ( 内訳は 9～11 と同じ )<br>
		      　　18～21　　シャドウマップ処理用のパラメータ<br><br>

                      　　22～31　　未使用( ピクセルシェーダー２．０で使用可能な float4型定数の数は 32個です )<br><br>

                      　　32　　　　 有効ライト0番目の座標( ビュー空間 )<br>
                      　　33　　　　 有効ライト0番目の法線( ビュー空間 )<br>
                      　　34　　　　 有効ライト0番目のディフューズカラー<BR>
                      　　35　　　 　有効ライト0番目のスペキュラカラー<BR>
                      　　36　　 　　有効ライト0番目のアンビエントカラーとマテリアルのアンビエントカラーを乗算したもの<br>
                      　　37　　　　 有効ライト0番目の x：有効距離の二乗　y：Falloff<br>
                      　　　　　　　　　　　　　　　　　　　z：距離減衰パラメータ0　w：距離減衰パラメータ1<br>
                      　　38　　　　 有効ライト0番目の x：距離減衰パラメータ1<br>
                      　　　　　　　　　　　　　　　　　y：スポットライト用パラメータ0( cos( Phi / 2.0f ) )<br>
                      　　　　　　　　　　　　　　　　　z：スポットライト用パラメータ1( 1.0f / ( cos( Theta / 2.0f ) - cos( Phi / 2.0f ) ) )<br>
                      　　39～45　　有効ライト1番目のパラメータ( 内訳は 32～38 と同じ )<br>
                      　　46～52　　有効ライト2番目のパラメータ( 内訳は 32～38 と同じ )<br>
                      　　53～59　　有効ライト3番目のパラメータ( 内訳は 32～38 と同じ )<br>
                      　　48～223　 未使用( ピクセルシェーダー３．０で使用可能な float4型定数の数は 224個です )<br><br><br>

                      　　<b>int4型定数</b><br><br>

                      　　0～15　　　　ライブラリでは未使用( ピクセルシェーダー２．０では int4型定数はありません )<br><br><br>

                      　　<b>BOOL型定数</b><br><br>

                      　　0～15　　　　ライブラリでは未使用( ピクセルシェーダー２．０では int4型定数はありません )<br><br><br>

                      　　　ライブラリが殆ど使ってしまっていますが、これらの定数は SetPSConstF などの関数で上書き可能で、<br>
                      　　オリジナルのシェーダープログラムで使用しない定数については上記ライブラリ定数を無視して使うことが<br>
		      　　できますのでご安心ください。<br>
                      　　( 例えばオリジナルのマテリアル処理を行う場合は float4型定数 1～4 を上書きして使用しても問題ありません )<br><br>

                    　<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ピクセルシェーダーを使って Tex1.bmp の赤成分と青成分を入れ替えて画面に描画します。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int texhandle, pshandle ;
    VERTEX2DSHADER Vert[ 6 ] ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // テクスチャを読み込む
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "PixelShaderTestPS.pso" ) ;

    // ２ポリゴン分の頂点のデータをセットアップ
    Vert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;
    Vert[ 0 ].rhw = 1.0f ;
    Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 0 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 0 ].u   = 0.0f ;
    Vert[ 0 ].v   = 0.0f ;
    Vert[ 0 ].su  = 0.0f ;
    Vert[ 0 ].sv  = 0.0f ;

    Vert[ 1 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 1 ].rhw = 1.0f ;
    Vert[ 1 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 1 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 1 ].u   = 1.0f ;
    Vert[ 1 ].v   = 0.0f ;
    Vert[ 1 ].su  = 1.0f ;
    Vert[ 1 ].sv  = 0.0f ;

    Vert[ 2 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 2 ].rhw = 1.0f ;
    Vert[ 2 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 2 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 2 ].u   = 0.0f ;
    Vert[ 2 ].v   = 1.0f ;
    Vert[ 2 ].su  = 0.0f ;
    Vert[ 2 ].sv  = 1.0f ;

    Vert[ 3 ].pos = VGet( 256.0f, 256.0f, 0.0f ) ;
    Vert[ 3 ].rhw = 1.0f ;
    Vert[ 3 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 3 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 3 ].u   = 1.0f ;
    Vert[ 3 ].v   = 1.0f ;
    Vert[ 3 ].su  = 1.0f ;
    Vert[ 3 ].sv  = 1.0f ;

    Vert[ 4 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 4 ].rhw = 1.0f ;
    Vert[ 4 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 4 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 4 ].u   = 0.0f ;
    Vert[ 4 ].v   = 1.0f ;
    Vert[ 4 ].su  = 0.0f ;
    Vert[ 4 ].sv  = 1.0f ;

    Vert[ 5 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 5 ].rhw = 1.0f ;
    Vert[ 5 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 5 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 5 ].u   = 1.0f ;
    Vert[ 5 ].v   = 0.0f ;
    Vert[ 5 ].su  = 1.0f ;
    Vert[ 5 ].sv  = 0.0f ;

    // 使用するテクスチャを０番にセット
    SetUseTextureToShader( 0, texhandle ) ;

    // 使用するピクセルシェーダーをセット
    SetUsePixelShader( pshandle ) ;

    // シェーダーを使用した２Ｄの２ポリゴンの描画
    DrawPolygon2DToShader( Vert, 2 ) ;

    // キー入力待ち
    WaitKey() ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( texhandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして PixelShaderTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor       : COLOR0 ;
    float4 SpecularColor      : COLOR1 ;
    float2 TextureCoord0      : TEXCOORD0 ;
    float2 TextureCoord1      : TEXCOORD1 ;
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 Output             : COLOR0 ;
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler DiffuseMapTexture : register( s0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor  = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ; 

    // 出力する色は青成分と赤成分を逆転したもの
    PSOutput.Output.r = lTextureColor.b ;
    PSOutput.Output.g = lTextureColor.g ;
    PSOutput.Output.b = lTextureColor.r ;
    PSOutput.Output.a = lTextureColor.a ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</div></pre>
            <hr>

            <br><br><br><br>
            
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N4">宣言</a></b></td><td><font color="#000088"><b>int DeleteShader( int ShaderHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーハンドルを削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ShaderHandle ： 削除する頂点シェーダー又はピクセルシェーダーのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a></b> や <b><a href="dxfunc_3d_shader.html#R17N3">LoadPixelShader</a></b> で読み込んだシェーダーを削除します。<br><br>

                    　一度に読み込んでおけるシェーダーの数には限りがあるので、必要が無くなったシェーダーはこの関数を使って削除する必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a> や <a href="dxfunc_3d_shader.html#R17N3">LoadPixelShader</a>のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N5">宣言</a></b></td><td><font color="#000088"><b>int InitShader( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーハンドルを全て削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a></b> や <b><a href="dxfunc_3d_shader.html#R17N3">LoadPixelShader</a></b> で読み込んだシェーダーを全て削除します。<br><br>

                    　DeleteShader では削除したいシェーダーを一つ一つ指定しなければなりませんが、この関数を使えば一度に全てのシェーダーを削除することができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N6">宣言</a></b></td><td><font color="#000088"><b>int SetVSConstF( int ConstantIndex, FLOAT4 Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーの FLOAT4 型定数を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０～２５５ )<br>
            FLOAT4 Param ： 設定する FLOAT4型の値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td><font color="#008800"><b>（ この関数は Direct3D 9 用の関数です、Direct3D 11 では効果がありませんので注意してください ）</b></font><br>
		　　　頂点シェーダーのプログラムで使用するFLOAT4型定数を設定する関数です。<br>
                    　FLOAT4 は構造体で、以下のように定義されています。<br>
<pre><div class="NormalFont">struct FLOAT4
{
    float x, y, z, w ;
} ;
</div></pre>
                    　FLOAT4 の文字通り float 型の変数が４つあります。<br>
                    　この x, y, z, w に値を代入して SetVSConstF で定数として設定すると、それがそのまま頂点シェーダーで使えるようになります。<br><br><br>


                    ＜例＞<br><br>

                    [ C++側 ]<br><br>

                    // x=10, y=20, z=30, w=0 の FLOAT4 型の値を定数110にセット<br>
                    FLOAT4 Temp ;<br>
                    Temp.x = 10.0f ;<br>
                    Temp.y = 20.0f ;<br>
                    Temp.z = 30.0f ;<br>
                    Temp.w = 0.0f ;<br>
                    SetVSConstF( 110, Temp ) ;<br><br><br>


                    [ 頂点シェーダー側 ]<br><br>

                    // FLOAT4型定数の 110番目を ConstF110 という名前で使うように宣言<br>
                    // これで SetVSConstF( 110, Temp ) ; で設定した値が ConstF110 という名前で使用可能になる<br>
                    float4 ConstF110 : register( c110 ) ;<br><br><br>


                    　因みに ConstantIndex で有効な値が０～２５５なのは頂点シェーダー２．０と３．０での float4型定数の最大数が 256個だからです。<br>
                    一度に沢山の FLOAT4型定数を設定したい場合は <b><a href="dxfunc_3d_shader.html#R17N10">SetVSConstFArray</a></b> を使用します。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="dxfunc_3d_shader.html#R17N14">ResetVSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<b><a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a></b> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N7">宣言</a></b></td><td><font color="#000088"><b>int SetVSConstFMtx( int ConstantIndex, MATRIX Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーの FLOAT4 型定数に行列を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０～２５２ )<br>
            MATRIX Param ： 設定する MATRIX型の値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td><font color="#008800"><b>（ この関数は Direct3D 9 用の関数です、Direct3D 11 では効果がありませんので注意してください ）</b></font><br>
                    <b><a href="dxfunc_3d_shader.html#R17N6">SetVSConstF</a></b> は FLOAT4型の構造体一つ分を頂点シェーダーの FLOAT4型定数として設定する関数でしたが、
                    この関数は FLOAT4型定数４つ分を一度に設定します。<br>
                    　何故４つかといいますと、MATRIX型は 4×4 の行列で、float型変数16個が中にあり、FLOAT4型構造体の一つが float型変数 4個分なので、
                    16 ÷ 4 = 4 というわけです。<br><br>

                    　具体的には<br>
                    定数番号 ConstantIndex に MATRIX構造体の m[0][0] m[0][1] m[0][2] m[0][3] が、<br>
                    定数番号 ConstantIndex + 1 に MATRIX構造体の m[1][0] m[1][1] m[1][2] m[1][3] が、<br>
                    定数番号 ConstantIndex + 2 に MATRIX構造体の m[2][0] m[2][1] m[2][2] m[2][3] が、<br>
                    定数番号 ConstantIndex + 3 に MATRIX構造体の m[3][0] m[3][1] m[3][2] m[3][3] が、<br>
                    それぞれ左から順に x, y, z, w に代入されて設定されます。<br><br>

                    　頂点シェーダーで使用できる FLOAT4型定数の数が２５６個なのに対し ConstantIndex で指定できる値が２５２までなのは、指定した番号から４個分の定数が必要だからです。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="dxfunc_3d_shader.html#R17N14">ResetVSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を貼り付けたポリゴン２枚を SetVSConstFMtx で設定した回転行列と頂点シェーダーを使用して回転させます。<br>
            　回転行列を定数10番に設定しているのは定数２～９番がビュー行列と射影行列の割り当て位置になっているからです。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3DSHADER Vertex[ 6 ] ;
    int vshandle ;
    int pshandle ;
    int texhandle ;
    float angle ;
    FLOAT4 pos ;
    MATRIX mtx ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセットアップ
    Vertex[ 0 ].pos  = VGet( -128.0f,  128.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet(  128.0f,  128.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 1.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( -128.0f, -128.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 1.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;


    Vertex[ 3 ].pos  = VGet( -128.0f, -128.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 0.0f ;
    Vertex[ 3 ].v    = 1.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    Vertex[ 4 ].pos  = VGet(  128.0f,  128.0f,  0.0f ) ;
    Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 4 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 4 ].u    = 1.0f ;
    Vertex[ 4 ].v    = 0.0f ;
    Vertex[ 4 ].su   = 0.0f ;
    Vertex[ 4 ].sv   = 0.0f ;

    Vertex[ 5 ].pos  = VGet(  128.0f, -128.0f,  0.0f ) ;
    Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 5 ].dif  = GetColorU8( 255,  0,  0,255 ) ;
    Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 5 ].u    = 1.0f ;
    Vertex[ 5 ].v    = 1.0f ;
    Vertex[ 5 ].su   = 0.0f ;
    Vertex[ 5 ].sv   = 0.0f ;

    // 頂点シェーダーを読み込む
    vshandle = LoadVertexShader( "SetVSConstFMtxTestVS.vso" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "SetVSConstFMtxTestPS.pso" ) ;

    // 描画に使用する画像の読み込み
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 回転角度の値を初期化
    angle = 0.0f ;

    // 頂点シェーダー FLOAT4型定数０番に表示座標をセット
    pos.x = 320.0f ;
    pos.y = 240.0f ;
    pos.z = 0.0f ;
    pos.w = 0.0f ;
    SetVSConstF( 0, pos ) ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 回転角度を変化させる
        angle += 0.05f ;

        // 回転角度からZ軸回転行列を作成
        mtx = MGetRotZ( angle ) ;

        // 回転行列を頂点シェーダー FLOAT4型定数１０～１３番にセット
        SetVSConstFMtx( 10, mtx ) ;

        // 使用する頂点シェーダーのセット
        SetUseVertexShader( vshandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // シェーダーを使用した２ポリゴンの描画
        DrawPolygon3DToShader( Vertex, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 使用したfloat4型定数０番の設定を無効化する
    ResetVSConstF( 0, 1 ) ;

    // 使用したfloat4型定数１０～１３番の設定を無効化する
    ResetVSConstF( 10, 4 ) ;

    // 読み込んだ頂点シェーダーの削除
    DeleteShader( vshandle ) ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( texhandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>頂点シェーダーのプログラム( コンパイルして SetVSConstFMtxTestVS.vso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// 頂点シェーダーの入力
struct VS_INPUT
{
    float4 Position             : POSITION ;    // 座標( VERTEX3DSHADER構造体の pos の値 )
    float3 Normal               : NORMAL0 ;     // 法線( VERTEX3DSHADER構造体の norm の値 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー( VERTEX3DSHADER構造体の dif の値 )
    float4 SpecularColor        : COLOR1 ;      // スペキュラカラー( VERTEX3DSHADER構造体の spc の値 )
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標０( VERTEX3DSHADER構造体の u, v の値 )
    float2 TextureCoord1        : TEXCOORD1 ;   // テクスチャ座標１( VERTEX3DSHADER構造体の su, sv の値 )
} ;

// 頂点シェーダーの出力
struct VS_OUTPUT
{
    float4 ProjectionPosition   : POSITION ;    // 座標( 射影空間 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;


// C++ 側で設定する定数の定義
float4x4 cfViewMatrix       : register( c6 ) ;    // ワールド座標をビュー座標に変換する行列の転置行列
float4x4 cfProjectionMatrix : register( c2 ) ;    // ビュー座標を射影座標に変換する行列の転置行列

// 回転中心になる座標
float4 cfCenterPosition : register( c0 ) ;

// Ｚ回転行列
float4x4 cfRotateZMatrix : register( c10 ) ;


// main関数
VS_OUTPUT main( VS_INPUT VSInput )
{
    VS_OUTPUT VSOutput ;
    float4 lWorldPosition ;
    float4 lViewPosition ;

    // 入力座標にＺ回転行列を掛けて座標を回転させる
    lWorldPosition = mul( cfRotateZMatrix, VSInput.Position ) ;

    // Ｚ回転しただけだと原点に居るので、表示させたい座標に移動する
    lWorldPosition += cfCenterPosition ;

    // 頂点座標をビュー空間の座標に変換する
    lViewPosition = mul( lWorldPosition, cfViewMatrix ) ;

    // ビュー空間の座標を射影空間の座標に変換する
    VSOutput.ProjectionPosition = mul( lViewPosition, cfProjectionMatrix ) ;

    // テクスチャ座標はそのまま代入
    VSOutput.TextureCoord0 = VSInput.TextureCoord0;

    // 頂点カラーはそのまま代入
    VSOutput.DiffuseColor = VSInput.DiffuseColor ;

    // 関数の戻り値がピクセルシェーダーに渡される
    return VSOutput ;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして SetVSConstFMtxTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 DrawColor            : COLOR0 ;    // 描画カラー
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler  DiffuseMapTexture      : register( s0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ;

    // 出力する色はテクスチャの色とディフューズカラーを乗算したもの
    PSOutput.DrawColor = lTextureColor * PSInput.DiffuseColor ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</div></pre>
            <hr>

            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N10">宣言</a></b></td><td><font color="#000088"><b>int SetVSConstFArray( int ConstantIndex, FLOAT4 *ParamArray, int ParamNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーの FLOAT4 型定数に行列を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０～２５５ )<br>
            FLOAT4 *ParamArray ： FLOAT4型配列の先頭アドレス<br>
            int ParamNum ： 設定する数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td><font color="#008800"><b>（ この関数は Direct3D 9 用の関数です、Direct3D 11 では効果がありませんので注意してください ）</b></font><br>
                    　<b><a href="dxfunc_3d_shader.html#R17N6">SetVSConstF</a></b> は FLOAT4型の構造体一つ分を頂点シェーダーの FLOAT4型定数として設定する関数でしたが、
                    この関数は FLOAT4型定数を指定数分だけ一度に設定することができます。<br><br>

                    　例えば<br><br>

                    FLOAT4 f4array[ 3 ] ;<br>
                    f4array[ 0 ].x = 100.0f ;<br>
                    f4array[ 0 ].y = 65.0f ;<br>
                    f4array[ 0 ].z = 19.0f ;<br>
                    f4array[ 0 ].w = 888.0f ;<br>
                    f4array[ 1 ].x = 296.0f ;<br>
                    f4array[ 1 ].y = 879.0f ;<br>
                    f4array[ 1 ].z = 1111.0f ;<br>
                    f4array[ 1 ].w = 6.0f ;<br>
                    f4array[ 2 ].x = 769910.0f ;<br>
                    f4array[ 2 ].y = 4023.0f ;<br>
                    f4array[ 2 ].z = 61.0f ;<br>
                    f4array[ 2 ].w = 735.0f ;<br>
                    SetVSConstFArray( 10, f4array, 3 ) ;<br><br>

                    　は、<br><br>

                    FLOAT4 f4array[ 3 ] ;<br>
                    f4array[ 0 ].x = 100.0f ;<br>
                    f4array[ 0 ].y = 65.0f ;<br>
                    f4array[ 0 ].z = 19.0f ;<br>
                    f4array[ 0 ].w = 888.0f ;<br>
                    f4array[ 1 ].x = 296.0f ;<br>
                    f4array[ 1 ].y = 879.0f ;<br>
                    f4array[ 1 ].z = 1111.0f ;<br>
                    f4array[ 1 ].w = 6.0f ;<br>
                    f4array[ 2 ].x = 769910.0f ;<br>
                    f4array[ 2 ].y = 4023.0f ;<br>
                    f4array[ 2 ].z = 61.0f ;<br>
                    f4array[ 2 ].w = 735.0f ;<br>
                    SetVSConstF( 10, f4array[ 0 ] ) ;<br>
                    SetVSConstF( 11, f4array[ 1 ] ) ;<br>
                    SetVSConstF( 12, f4array[ 2 ] ) ;<br><br>

                    　と同じ動作をします。<br>
                    　なんでこんな関数があるのかといいますと、単純に何回も SetVSConstF を呼ぶのが面倒だからという理由以外に何回も SetVSConstF を呼ぶのは処理負荷が高いからです。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="dxfunc_3d_shader.html#R17N14">ResetVSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を貼り付けたポリゴン２枚を SetVSConstFArray を使って予め設定した画面４隅の座標に順番に描画します。<br>
            　ＨＬＳＬのソースを見ると分かると思いますが、ＨＬＳＬで int4 として宣言した変数も内部では FLOAT4型として扱われるので<br>
            　ciPositionIndex の値を設定する関数も SetVSConstF となっています。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3DSHADER Vertex[ 6 ] ;
    int vshandle ;
    int pshandle ;
    int texhandle ;
    int posind ;
    int poscounter ;
    FLOAT4 pos[ 4 ] ;
    FLOAT4 f4 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセットアップ
    Vertex[ 0 ].pos  = VGet( -64.0f,  64.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet(  64.0f,  64.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 1.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( -64.0f, -64.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 1.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;


    Vertex[ 3 ].pos  = VGet( -64.0f, -64.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 0.0f ;
    Vertex[ 3 ].v    = 1.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    Vertex[ 4 ].pos  = VGet(  64.0f,  64.0f,  0.0f ) ;
    Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 4 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 4 ].u    = 1.0f ;
    Vertex[ 4 ].v    = 0.0f ;
    Vertex[ 4 ].su   = 0.0f ;
    Vertex[ 4 ].sv   = 0.0f ;

    Vertex[ 5 ].pos  = VGet(  64.0f, -64.0f,  0.0f ) ;
    Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 5 ].dif  = GetColorU8( 255,  0,  0,255 ) ;
    Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 5 ].u    = 1.0f ;
    Vertex[ 5 ].v    = 1.0f ;
    Vertex[ 5 ].su   = 0.0f ;
    Vertex[ 5 ].sv   = 0.0f ;

    // 頂点シェーダーを読み込む
    vshandle = LoadVertexShader( "SetVSConstFArrayTestVS.vso" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "SetVSConstFArrayTestPS.pso" ) ;

    // 描画に使用する画像の読み込み
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 位置番号処理用の値を初期化
    posind = 0 ;
    poscounter = 0 ;

    // 頂点シェーダー FLOAT4型定数１０～１３番に表示座標をセット
    pos[ 0 ].x = 100.0f ;
    pos[ 0 ].y = 100.0f ;
    pos[ 0 ].z = 0.0f ;
    pos[ 0 ].w = 0.0f ;
    pos[ 1 ].x = 540.0f ;
    pos[ 1 ].y = 100.0f ;
    pos[ 1 ].z = 0.0f ;
    pos[ 1 ].w = 0.0f ;
    pos[ 2 ].x = 540.0f ;
    pos[ 2 ].y = 380.0f ;
    pos[ 2 ].z = 0.0f ;
    pos[ 2 ].w = 0.0f ;
    pos[ 3 ].x = 100.0f ;
    pos[ 3 ].y = 380.0f ;
    pos[ 3 ].z = 0.0f ;
    pos[ 3 ].w = 0.0f ;
    SetVSConstFArray( 10, pos, 4 ) ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 一定時間経過したら位置番号を変更する
        poscounter ++ ;
        if( poscounter == 30 )
        {
            poscounter = 0 ;

            posind ++ ;
            if( posind == 4 )
            {
                posind = 0 ;
            }
        }

        // 位置番号を FLOAT4型の x に代入して頂点シェーダー FLOAT4型定数０番にセット
        f4.x = ( float )posind ;
        f4.y = 0 ;
        f4.z = 0 ;
        f4.w = 0 ;
        SetVSConstF( 0, f4 ) ;

        // 使用する頂点シェーダーのセット
        SetUseVertexShader( vshandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // シェーダーを使用した２ポリゴンの描画
        DrawPolygon3DToShader( Vertex, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 使用したfloat4型定数１０～１３番の設定を無効化する
    ResetVSConstF( 10, 4 ) ;

    // 使用したint4型定数０番の設定を無効化する
    ResetVSConstI( 0, 1 ) ;

    // 読み込んだ頂点シェーダーの削除
    DeleteShader( vshandle ) ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( texhandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>頂点シェーダーのプログラム( コンパイルして SetVSConstFArrayTestVS.vso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// 頂点シェーダーの入力
struct VS_INPUT
{
    float4 Position             : POSITION ;    // 座標( VERTEX3DSHADER構造体の pos の値 )
    float3 Normal               : NORMAL0 ;     // 法線( VERTEX3DSHADER構造体の norm の値 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー( VERTEX3DSHADER構造体の dif の値 )
    float4 SpecularColor        : COLOR1 ;      // スペキュラカラー( VERTEX3DSHADER構造体の spc の値 )
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標０( VERTEX3DSHADER構造体の u, v の値 )
    float2 TextureCoord1        : TEXCOORD1 ;   // テクスチャ座標１( VERTEX3DSHADER構造体の su, sv の値 )
} ;

// 頂点シェーダーの出力
struct VS_OUTPUT
{
    float4 ProjectionPosition   : POSITION ;    // 座標( 射影空間 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;


// C++ 側で設定する定数の定義
float4x4 cfViewMatrix       : register( c6 ) ;    // ワールド座標をビュー座標に変換する行列の転置行列
float4x4 cfProjectionMatrix : register( c2 ) ;    // ビュー座標を射影座標に変換する行列の転置行列

// 座標値の配列
float4 cfDrawPosition[ 4 ] : register( c10 ) ;

// 座標値配列のインデックス
int4 ciPositionIndex : register( c0 ) ;


// main関数
VS_OUTPUT main( VS_INPUT VSInput )
{
    VS_OUTPUT VSOutput ;
    float4 lWorldPosition ;
    float4 lViewPosition ;

    // 入力座標に座標インデックスで決定する座標を加算する
    lWorldPosition = VSInput.Position + cfDrawPosition[ ciPositionIndex.x ] ;

    // 頂点座標をビュー空間の座標に変換する
    lViewPosition = mul( lWorldPosition, cfViewMatrix ) ;

    // ビュー空間の座標を射影空間の座標に変換する
    VSOutput.ProjectionPosition = mul( lViewPosition, cfProjectionMatrix ) ;

    // テクスチャ座標はそのまま代入
    VSOutput.TextureCoord0 = VSInput.TextureCoord0;

    // 頂点カラーはそのまま代入
    VSOutput.DiffuseColor = VSInput.DiffuseColor ;

    // 関数の戻り値がピクセルシェーダーに渡される
    return VSOutput ;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして SetVSConstFArrayTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 DrawColor            : COLOR0 ;    // 描画カラー
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler  DiffuseMapTexture      : register( s0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ;

    // 出力する色はテクスチャの色とディフューズカラーを乗算したもの
    PSOutput.DrawColor = lTextureColor * PSInput.DiffuseColor ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</div></pre>
            <hr>

            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N14">宣言</a></b></td><td><font color="#000088"><b>int ResetVSConstF( int ConstantIndex, int ParamNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーの FLOAT4 型定数の設定を無効にする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 設定を無効にする FLOAT4型定数の番号( ０～２５５ )<br>
            int ParamNum ： 無効にする数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td><font color="#008800"><b>（ この関数は Direct3D 9 用の関数です、Direct3D 11 では効果がありませんので注意してください ）</b></font><br>
                    　<b><a href="dxfunc_3d_shader.html#R17N6">SetVSConstF</a></b> などの関数で行った頂点シェーダーの FLOAT4型定数の設定を無効化します。<br>
                    　この関数の用途は主にＤＸライブラリ側で設定する定数の値を使用する場合です。<br>
                    　例えばある頂点シェーダーではＤＸライブラリ側で設定したマテリアルの定数が必要ないということで FLOAT4型定数 11～13に対して SetVSConstF で定数を上書きしたとします。
                    そしてその後別の頂点シェーダーではＤＸライブラリ側で設定したマテリアルの定数が必要、となったときに、
                    予め ResetVSConstF を使用して 11～13 に対して行った定数の設定を無効化することでＤＸライブラリ側が設定した定数を使用することができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　効果的な使い方はしていませんが、<a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a> や <a href="dxfunc_3d_shader.html#R17N7">SetVSConstFMtx</a>のサンプルで使用しています。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N17">宣言</a></b></td><td><font color="#000088"><b>int SetPSConstF( int ConstantIndex, FLOAT4 Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーの FLOAT4 型定数を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０～３１ or ０～２２３ )<br>
            FLOAT4 Param ： 設定する FLOAT4型の値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td><font color="#008800"><b>（ この関数は Direct3D 9 用の関数です、Direct3D 11 では効果がありませんので注意してください ）</b></font><br>
                    　ピクセルシェーダーのプログラムで使用するFLOAT4型定数を設定する関数です。<br>
                    　FLOAT4 は構造体で、以下のように定義されています。<br>
<pre><div class="NormalFont">struct FLOAT4
{
    float x, y, z, w ;
} ;
</div></pre>
                    　FLOAT4 の文字通り float 型の変数が４つあります。<br>
                    　この x, y, z, w に値を代入して SetVSConstF で定数として設定すると、それがそのまま頂点シェーダーで使えるようになります。<br><br><br>


                    ＜例＞<br><br>

                    [ C++側 ]<br><br>

                    // x=10, y=20, z=30, w=0 の FLOAT4 型の値を定数10にセット<br>
                    FLOAT4 Temp ;<br>
                    Temp.x = 10.0f ;<br>
                    Temp.y = 20.0f ;<br>
                    Temp.z = 30.0f ;<br>
                    Temp.w = 0.0f ;<br>
                    SetPSConstF( 10, Temp ) ;<br><br><br>


                    [ ピクセルシェーダー側 ]<br><br>

                    // FLOAT4型定数の 10番目を ConstF10 という名前で使うように宣言<br>
                    // これで SetPSConstF( 10, Temp ) ; で設定した値が ConstF10 という名前で使用可能になる<br>
                    float4 ConstF10 : register( c10 ) ;<br><br><br>


                    　因みに ConstantIndex で有効な値が０～３１ or ０～２２３なのは float4型定数の数がピクセルシェーダー２．０では 32個、３．０では 224個だからです。<br>
                    一度に沢山の FLOAT4型定数を設定したい場合は <b><a href="dxfunc_3d_shader.html#R17N21">SetPSConstFArray</a></b> を使用します。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="dxfunc_3d_shader.html#R17N25">ResetPSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を貼り付けたポリゴン２枚を SetPSConstF で設定した r, g, b の値を乗算して描画します。<br>
            　因みに x, y, z, w は r, g, b, a に対応しています。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int texhandle, pshandle ;
    VERTEX2DSHADER Vert[ 6 ] ;
    int r, g, b ;
    int radd, gadd, badd ;
    FLOAT4 f4 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // テクスチャを読み込む
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "SetPSConstFTestPS.pso" ) ;

    // ２ポリゴン分の頂点のデータをセットアップ
    Vert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;
    Vert[ 0 ].rhw = 1.0f ;
    Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 0 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 0 ].u   = 0.0f ;
    Vert[ 0 ].v   = 0.0f ;
    Vert[ 0 ].su  = 0.0f ;
    Vert[ 0 ].sv  = 0.0f ;

    Vert[ 1 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 1 ].rhw = 1.0f ;
    Vert[ 1 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 1 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 1 ].u   = 1.0f ;
    Vert[ 1 ].v   = 0.0f ;
    Vert[ 1 ].su  = 1.0f ;
    Vert[ 1 ].sv  = 0.0f ;

    Vert[ 2 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 2 ].rhw = 1.0f ;
    Vert[ 2 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 2 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 2 ].u   = 0.0f ;
    Vert[ 2 ].v   = 1.0f ;
    Vert[ 2 ].su  = 0.0f ;
    Vert[ 2 ].sv  = 1.0f ;

    Vert[ 3 ].pos = VGet( 256.0f, 256.0f, 0.0f ) ;
    Vert[ 3 ].rhw = 1.0f ;
    Vert[ 3 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 3 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 3 ].u   = 1.0f ;
    Vert[ 3 ].v   = 1.0f ;
    Vert[ 3 ].su  = 1.0f ;
    Vert[ 3 ].sv  = 1.0f ;

    Vert[ 4 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 4 ].rhw = 1.0f ;
    Vert[ 4 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 4 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 4 ].u   = 0.0f ;
    Vert[ 4 ].v   = 1.0f ;
    Vert[ 4 ].su  = 0.0f ;
    Vert[ 4 ].sv  = 1.0f ;

    Vert[ 5 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 5 ].rhw = 1.0f ;
    Vert[ 5 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 5 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 5 ].u   = 1.0f ;
    Vert[ 5 ].v   = 0.0f ;
    Vert[ 5 ].su  = 1.0f ;
    Vert[ 5 ].sv  = 0.0f ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // r, g, b の値を変化させる準備
    r = 0 ;
    g = 128 ;
    b = 255 ;
    radd = 10 ;
    gadd = 7 ;
    badd = 3 ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // r, g, b の値を変化させる
        r += radd ;
        if( r >= 255 )
        {
            r = 255 ;
            radd = -radd ;
        }
        else
        if( r <= 0 )
        {
            r = 0 ;
            radd = -radd ;
        }

        g += gadd ;
        if( g >= 255 )
        {
            g = 255 ;
            gadd = -gadd ;
        }
        else
        if( g <= 0 )
        {
            g = 0 ;
            gadd = -gadd ;
        }

        b += badd ;
        if( b >= 255 )
        {
            b = 255 ;
            badd = -badd ;
        }
        else
        if( b <= 0 )
        {
            b = 0 ;
            badd = -badd ;
        }

        // r, g, b の値をピクセルシェーダーの FLOAT4型定数０番にセット
        // 定数にするときは値を 0.0f ～ 1.0f にする
        f4.x = r / 255.0f ;
        f4.y = g / 255.0f ;
        f4.z = b / 255.0f ;
        f4.w = 1.0f ;
        SetPSConstF( 0, f4 ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // シェーダーを使用した２Ｄの２ポリゴンの描画
        DrawPolygon2DToShader( Vert, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // 使用した定数を無効化する
    ResetPSConstF( 0, 1 ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( texhandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして SetPSConstFTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor       : COLOR0 ;
    float4 SpecularColor      : COLOR1 ;
    float2 TextureCoord0      : TEXCOORD0 ;
    float2 TextureCoord1      : TEXCOORD1 ;
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 Output             : COLOR0 ;
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler DiffuseMapTexture : register( s0 ) ;

// テクスチャの色に乗算する値
float4 cfMultiplyColor : register( c0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor  = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ; 

    // 出力する色はテクスチャの色と定数を乗算したもの
    PSOutput.Output = lTextureColor * cfMultiplyColor ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</div></pre>
            <hr>

            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N18">宣言</a></b></td><td><font color="#000088"><b>int SetPSConstFMtx( int ConstantIndex, MATRIX Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーの FLOAT4 型定数に行列を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０～２２０ )<br>
            MATRIX Param ： 設定する MATRIX型の値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td><font color="#008800"><b>（ この関数は Direct3D 9 用の関数です、Direct3D 11 では効果がありませんので注意してください ）</b></font><br>
                    　<b><a href="dxfunc_3d_shader.html#R17N17">SetPSConstF</a></b> は FLOAT4型の構造体一つ分をピクセルシェーダーの FLOAT4型定数として設定する関数でしたが、
                    この関数は FLOAT4型定数４つ分を一度に設定します。<br>
                    　何故４つかといいますと、MATRIX型は 4×4 の行列で、float型変数16個が中にあり、FLOAT4型構造体の一つが float型変数 4個分なので、
                    16 ÷ 4 = 4 というわけです。<br><br>

                    　具体的には<br>
                    定数番号 ConstantIndex に MATRIX構造体の m[0][0] m[0][1] m[0][2] m[0][3] が、<br>
                    定数番号 ConstantIndex + 1 に MATRIX構造体の m[1][0] m[1][1] m[1][2] m[1][3] が、<br>
                    定数番号 ConstantIndex + 2 に MATRIX構造体の m[2][0] m[2][1] m[2][2] m[2][3] が、<br>
                    定数番号 ConstantIndex + 3 に MATRIX構造体の m[3][0] m[3][1] m[3][2] m[3][3] が、<br>
                    それぞれ左から順に x, y, z, w に代入されて設定されます。<br><br>

                    　ピクセルシェーダーで使用できる FLOAT4型定数の数が２２４個なのに対し ConstantIndex で指定できる値が２２０までなのは、指定した番号から４個分の定数が必要だからです。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="dxfunc_3d_shader.html#R17N25">ResetPSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N21">宣言</a></b></td><td><font color="#000088"><b>int SetPSConstFArray( int ConstantIndex, FLOAT4 *ParamArray, int ParamNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーの FLOAT4 型定数を配列を使って設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０～３１ or ０～２２３ )<br>
            FLOAT4 *ParamArray ： FLOAT4型配列の先頭アドレス<br>
            int ParamNum ： 設定する数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td><font color="#008800"><b>（ この関数は Direct3D 9 用の関数です、Direct3D 11 では効果がありませんので注意してください ）</b></font><br>
                    　<b><a href="dxfunc_3d_shader.html#R17N17">SetPSConstF</a></b> は FLOAT4型の構造体一つ分をピクセルシェーダーの FLOAT4型定数として設定する関数でしたが、
                    この関数は FLOAT4型定数を指定数分だけ一度に設定することができます。<br><br>

                    　例えば<br><br>

                    FLOAT4 f4array[ 3 ] ;<br>
                    f4array[ 0 ].x = 100.0f ;<br>
                    f4array[ 0 ].y = 65.0f ;<br>
                    f4array[ 0 ].z = 19.0f ;<br>
                    f4array[ 0 ].w = 888.0f ;<br>
                    f4array[ 1 ].x = 296.0f ;<br>
                    f4array[ 1 ].y = 879.0f ;<br>
                    f4array[ 1 ].z = 1111.0f ;<br>
                    f4array[ 1 ].w = 6.0f ;<br>
                    f4array[ 2 ].x = 769910.0f ;<br>
                    f4array[ 2 ].y = 4023.0f ;<br>
                    f4array[ 2 ].z = 61.0f ;<br>
                    f4array[ 2 ].w = 735.0f ;<br>
                    SetPSConstFArray( 10, f4array, 3 ) ;<br><br>

                    　は、<br><br>

                    FLOAT4 f4array[ 3 ] ;<br>
                    f4array[ 0 ].x = 100.0f ;<br>
                    f4array[ 0 ].y = 65.0f ;<br>
                    f4array[ 0 ].z = 19.0f ;<br>
                    f4array[ 0 ].w = 888.0f ;<br>
                    f4array[ 1 ].x = 296.0f ;<br>
                    f4array[ 1 ].y = 879.0f ;<br>
                    f4array[ 1 ].z = 1111.0f ;<br>
                    f4array[ 1 ].w = 6.0f ;<br>
                    f4array[ 2 ].x = 769910.0f ;<br>
                    f4array[ 2 ].y = 4023.0f ;<br>
                    f4array[ 2 ].z = 61.0f ;<br>
                    f4array[ 2 ].w = 735.0f ;<br>
                    SetPSConstF( 10, f4array[ 0 ] ) ;<br>
                    SetPSConstF( 11, f4array[ 1 ] ) ;<br>
                    SetPSConstF( 12, f4array[ 2 ] ) ;<br><br>

                    　と同じ動作をします。<br>
                    　なんでこんな関数があるのかといいますと、単純に何回も SetPSConstF を呼ぶのが面倒だからという理由以外に何回も SetPSConstF を呼ぶのは処理負荷が高いからです。<br><br>

                    　因みに ConstantIndex で有効な値が０～３１ or ０～２２３なのは float4型定数の数がピクセルシェーダー２．０では 32個、３．０では 224個だからです。<br>
                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="dxfunc_3d_shader.html#R17N25">ResetPSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N25">宣言</a></b></td><td><font color="#000088"><b>int ResetPSConstF( int ConstantIndex, int ParamNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーの FLOAT4 型定数の設定を無効にする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 設定を無効にする FLOAT4型定数の番号( ０～３１ or ０～２２３ )<br>
            int ParamNum ： 無効にする数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td><font color="#008800"><b>（ この関数は Direct3D 9 用の関数です、Direct3D 11 では効果がありませんので注意してください ）</b></font><br>
                    　<b><a href="dxfunc_3d_shader.html#R17N17">SetPSConstF</a></b> などの関数で行ったピクセルシェーダーの FLOAT4型定数の設定を無効化します。<br>
                    　この関数の用途は主にＤＸライブラリ側で設定する定数の値を使用する場合です。<br>
                    　例えばあるピクセルシェーダーではＤＸライブラリ側で設定したマテリアルの定数が必要ないということで FLOAT4型定数 2～4に対して SetPSConstF で定数を上書きしたとします。
                    そしてその後別のピクセルシェーダーではＤＸライブラリ側で設定したマテリアルの定数が必要、となったときに、
                    予め ResetPSConstF を使用して 2～4 に対して行った定数の設定を無効化することでＤＸライブラリ側が設定した定数を使用することができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　効果的な使い方はしていませんが、<a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a> や <a href="dxfunc_3d_shader.html#R17N17">SetPSConstF</a>のサンプルで使用しています。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N28">宣言</a></b></td><td><font color="#000088"><b>int SetRenderTargetToShader( int TargetIndex, int DrawScreen ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>描画先を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int TargetIndex ： 描画先を設定する出力番号<br>
            int DrawScreen ： 描画先グラフィックハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　通常描画先は <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b> を使用して変更しますが、
                    グラフィックスデバイスが対応していればピクセルシェーダーは複数の描画先に対して同時に描画を行うことができます。
                    ( ただし出力先を分けるのはピクセルシェーダーなので別画像の同一座標に描画する色を変化させる程度ですが・・・ )<br><br>

                    　ピクセルシェーダーで出力先を複数にするのは簡単で、普段ピクセルシェーダーの出力の定義は<br><br>

<pre><div class="NormalFont">struct PS_OUTPUT
{
    float4 Output             : COLOR0 ;
} ;
</div></pre>

                    　このようになっていますが、この Output が単純に増えます。<br>
                    　例えば出力先が３つの場合は。<br><br>

<pre><div class="NormalFont">struct PS_OUTPUT
{
    float4 Output0            : COLOR0 ;
    float4 Output1            : COLOR1 ;
    float4 Output2            : COLOR2 ;
} ;
</div></pre>
                    　このようになります。<br><br>

                    　グラフィックスデバイスが複数の描画先への描画に対応しているかどうか、
                    また幾つまで対応しているかは <b><a href="dxfunc_3d_shader.html#R17N36">GetMultiDrawScreenNum</a></b> で調べることができます。<br><br>

                    　描画先として設定する出力番号の０番は SetDrawScreen で設定できる描画先と同じですので、
                    TargetIndex を 0 にした場合は内部で SetDrawScreen が呼ばれます。<br><br>

                    　尚、TargetIndex の 1 以上の番号に設定した描画先の設定を無効にしたい場合は、DrawScreen を -1 にして呼び出します。<br><br>

                    　複数の描画先への描画の主な用途はピクセルシェーダーの出力が単純な色だけではない特殊な用途に使用する場合で、
                    例えば出力先０番には色を、出力先１番には法線の方向を、出力先２番にはカメラからの距離を出力したい、という場合に使用します。<br>
                    　入力の二つのテクスチャにそれぞれ座標と速度を描画しておいて、
                    出力先の二つのテクスチャにそれぞれ座標に速度を足したものと減速後の速度を描画する、
                    そのテクスチャを頂点シェーダーで読み取ってその座標に絵を描画するということをすればピクセルシェーダーを使ってオブジェクトの挙動の処理を行うこともできます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を二つの描画先に描画します、片方は画像の赤成分だけを描画して、もう片方には画像の緑成分だけを描画します。<br>
            　そしてその結果を画面に表示します。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int texhandle, pshandle ;
    int screen0, screen1 ;
    VERTEX2DSHADER Vert[ 6 ] ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // テクスチャを読み込む
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "SetRenderTargetTestPS.pso" ) ;

    // ２５６×２５６の描画可能なグラフィックハンドルを二つ作成する
    screen0 = MakeScreen( 256, 256 ) ;
    screen1 = MakeScreen( 256, 256 ) ;

    // ２ポリゴン分の頂点のデータをセットアップ
    Vert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;
    Vert[ 0 ].rhw = 1.0f ;
    Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 0 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 0 ].u   = 0.0f ;
    Vert[ 0 ].v   = 0.0f ;
    Vert[ 0 ].su  = 0.0f ;
    Vert[ 0 ].sv  = 0.0f ;

    Vert[ 1 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 1 ].rhw = 1.0f ;
    Vert[ 1 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 1 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 1 ].u   = 1.0f ;
    Vert[ 1 ].v   = 0.0f ;
    Vert[ 1 ].su  = 0.0f ;
    Vert[ 1 ].sv  = 0.0f ;

    Vert[ 2 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 2 ].rhw = 1.0f ;
    Vert[ 2 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 2 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 2 ].u   = 0.0f ;
    Vert[ 2 ].v   = 1.0f ;
    Vert[ 2 ].su  = 0.0f ;
    Vert[ 2 ].sv  = 0.0f ;

    Vert[ 3 ].pos = VGet( 256.0f, 256.0f, 0.0f ) ;
    Vert[ 3 ].rhw = 1.0f ;
    Vert[ 3 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 3 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 3 ].u   = 1.0f ;
    Vert[ 3 ].v   = 1.0f ;
    Vert[ 3 ].su  = 0.0f ;
    Vert[ 3 ].sv  = 0.0f ;

    Vert[ 4 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 4 ].rhw = 1.0f ;
    Vert[ 4 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 4 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 4 ].u   = 0.0f ;
    Vert[ 4 ].v   = 1.0f ;
    Vert[ 4 ].su  = 0.0f ;
    Vert[ 4 ].sv  = 0.0f ;

    Vert[ 5 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 5 ].rhw = 1.0f ;
    Vert[ 5 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 5 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 5 ].u   = 1.0f ;
    Vert[ 5 ].v   = 0.0f ;
    Vert[ 5 ].su  = 0.0f ;
    Vert[ 5 ].sv  = 0.0f ;

    // 描画先０を描画可能画像の一つ目に設定
    SetRenderTargetToShader( 0, screen0 ) ;

    // 描画先１を描画可能画像の二つ目に設定
    SetRenderTargetToShader( 1, screen1 ) ;

    // 使用するテクスチャを０番にセット
    SetUseTextureToShader( 0, texhandle ) ;

    // 使用するピクセルシェーダーをセット
    SetUsePixelShader( pshandle ) ;

    // シェーダーを使用した２Ｄの２ポリゴンの描画
    DrawPolygon2DToShader( Vert, 2 ) ;

    // 描画先を表画面に変更
    SetDrawScreen( DX_SCREEN_FRONT ) ;

    // 描画先１の設定をリセット
    SetRenderTargetToShader( 1, -1 ) ;

    // 二つの描画可能画像を並べて描画
    DrawGraph(   0, 0, screen0, FALSE ) ;
    DrawGraph( 256, 0, screen1, FALSE ) ;

    // キー入力待ち
    WaitKey() ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // MakeScreen で作成したグラフィックハンドルの削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( screen0 ) ;
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( screen1 ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( texhandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして SetRenderTargetTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre><div class="NormalFont">// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor       : COLOR0 ;
    float4 SpecularColor      : COLOR1 ;
    float2 TextureCoord0      : TEXCOORD0 ;
    float2 TextureCoord1      : TEXCOORD1 ;
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 Output0            : COLOR0 ;
    float4 Output1            : COLOR1 ;
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler DiffuseMapTexture : register( s0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor  = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ; 

    // 出力先０には赤成分だけ出力
    PSOutput.Output0.r = lTextureColor.r ;
    PSOutput.Output0.g = 0.0f ;
    PSOutput.Output0.b = 0.0f ;
    PSOutput.Output0.a = 1.0f ;

    // 出力先１には緑成分だけ出力
    PSOutput.Output1.r = 0.0f ;
    PSOutput.Output1.g = lTextureColor.g ;
    PSOutput.Output1.b = 0.0f ;
    PSOutput.Output1.a = 1.0f ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</div></pre>
            <hr>

            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N29">宣言</a></b></td><td><font color="#000088"><b>int SetUseTextureToShader( int StageIndex, int GraphHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダー描画で使用するテクスチャを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int StageIndex ： 設定するテクスチャステージ番号<br>
            int GraphHandle ： 設定するテクスチャを持つグラフィックハンドル又は -1
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N33">DrawPolygon3DToShader</a></b> などのプログラマブルシェーダーを使用した描画で使用するグラフィックハンドルを設定する関数です。<br>
                    　DrawGraph や DrawExtendGraph などの関数では使用する画像は一つと分かっているので関数の引数にグラフィックハンドルを渡しますが、
                    シェーダーを使用した描画では複数の画像を使用することができるので、DrawPolygon3DToShader などの関数の引数としてグラフィックハンドルを渡すことは無く、
                    代わりにこの関数を使用して事前に描画に使用するグラフィックハンドルを設定しておきます。<br><br>

                    　この関数で指定した番号と、シェーダープログラムでの対応ですが、<br><br>
                    
                    sampler DiffuseMapTexture : register( s0 ) ;<br><br>

                    　例えば↑の場合の s0 の 0 の部分が StageIndex の値になります。<br>
                    　なので StageIndex に 2 を渡して設定した画像は<br><br>

                    sampler OtherTexture : register( s2 ) ;<br><br>

                    　という感じに s2 を指定することで使用することができます。<br>
                    　尚、この関数に渡すグラフィックハンドルが持つ画像は縦横のサイズが 2 の n乗では無い場合に正常な描画結果が得られませんので注意してください。<br>
                    ( 2 の n乗の値は 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192 といった値です。<br>
                    なのでこれに当てはまらない縦幅、横幅の画像を LoadGraph で読み込んでこの関数の引数に渡しても、正常な描画結果を得られません )<br><br>

                    　設定したグラフィックハンドルを外したい場合は GraphHandle の値を -1 にして関数を呼んでください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a> などのシェーダー関係関数のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N30">宣言</a></b></td><td><font color="#000088"><b>int SetUseVertexShader( int ShaderHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダー描画に使用する頂点シェーダーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ShaderHandle ： 使用する頂点シェーダーのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N33">DrawPolygon3DToShader</a></b> などのプログラマブルシェーダーを使用した描画で使用する頂点シェーダーを設定する関数です。<br>
                    　頂点シェーダーハンドルは <b><a href="dxfunc_3d_shader.html#R17N33">LoadVertexShader</a></b> で頂点シェーダーバイナリファイルから読み込み、
                    取得することができます。<br>
                    　この関数で設定した頂点シェーダーは DrawPolygon3DToShader, <b><a href="dxfunc_3d_shader.html#R17N33">DrawPolygonIndexed3DToShader</a></b> の描画時に使用されます。<br>
                    　また、<b><a href="dxfunc_3d_model_0.html#R19N1">MV1SetUseOrigShader</a></b> で３Ｄモデルの描画にオリジナルシェーダーを使用するように設定されていた場合は
                    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b> などの３Ｄモデルの描画関数が呼ばれた際にも使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a> などのシェーダー関係関数のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N31">宣言</a></b></td><td><font color="#000088"><b>int SetUsePixelShader( int ShaderHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダー描画に使用するピクセルシェーダーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ShaderHandle ： 使用するピクセルシェーダーのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N33">DrawPolygon3DToShader</a></b> などのプログラマブルシェーダーを使用した描画で使用するピクセルシェーダーを設定する関数です。<br>
                    　ピクセルシェーダーハンドルは <b><a href="dxfunc_3d_shader.html#R17N3">LoadPixelShader</a></b> でピクセルシェーダーバイナリファイルから読み込み、
                    取得することができます。<br>
                    　この関数で設定したピクセルシェーダーは DrawPolygon～ToShader と付いている描画関数での描画時に使用されます。<br>
                    　また、<b><a href="dxfunc_3d_model_0.html#R19N1">MV1SetUseOrigShader</a></b> で３Ｄモデルの描画にオリジナルシェーダーを使用するように設定されていた場合は
                    <b><a href="dxfunc_3d_model_0.html#R2N1">MV1DrawModel</a></b> などの３Ｄモデルの描画関数が呼ばれた際にも使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a> などのシェーダー関係関数のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N32">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygon2DToShader( VERTEX2DSHADER *Vertex, int PolygonNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーを使って２Ｄポリゴンを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX2DSHADER *Vertex ： ポリゴンを構成する頂点配列の先頭アドレス<br>
            int PolygonNum ： 描画するポリゴンの数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N3">LoadPixelShader</a></b> で読み込んだピクセルシェーダーを使用して三角形ポリゴンの描画を行います。<br>
                    　Vertex の引数として用意する必要がある VERTEX2DSHADER 構造体の数は描画するポリゴンの数×３になります。<br>
                    　また、この関数を呼び出す前に <b><a href="dxfunc_3d_shader.html#R17N31">SetUsePixelShader</a></b> で使用するピクセルシェーダーを設定しておく必要があります。
                    ( テクスチャを使用する場合は <b><a href="dxfunc_3d_shader.html#R17N29">SetUseTextureToShader</a></b> によるテクスチャの設定も・・・ )<br>

                    　描画に使用する VERTEX2DSHADER 構造体は以下のように定義されています。<br>
<pre><div class="NormalFont">struct VERTEX2DSHADER
{
    VECTOR      pos ;      // スクリーン座標
    float       rhw ;      // 同次 W の逆数、通常は 1.0f でＯＫ
    COLOR_U8    dif ;      // ディフューズカラー
    COLOR_U8    spc ;      // スペキュラカラー
    float       u, v ;     // テクスチャ座標０
    float       su, sv ;   // テクスチャ座標１
} ;
</div></pre>
                    　そして、この関数では頂点処理は行われないので頂点シェーダーが使用されません、<br>
                    普段頂点シェーダーでピクセルシェーダーの入力データ形式が決定しますが、<br>
                    この関数を使用した場合のピクセルシェーダーの入力は固定で以下のようになります。<br>

<pre><div class="NormalFont">struct PS_INPUT
{
    float4 DiffuseColor  : COLOR0 ;      // ディフューズカラー
    float4 SpecularColor : COLOR1 ;      // スペキュラカラー
    float2 TextureCoord0 : TEXCOORD0 ;   // テクスチャ座標０
    float2 TextureCoord1 : TEXCOORD1 ;   // テクスチャ座標１
} ;
</div></pre>
                    　２Ｄのフィルター処理などを行う場合は３Ｄの処理が必要ないので、頂点シェーダーを書く必要も無くお手軽です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="dxfunc_3d_shader.html#R17N3">LoadPixelShader</a> や <a href="dxfunc_3d_shader.html#R17N6">SetPSConstF</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N33">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygon3DToShader( VERTEX3DSHADER *Vertex, int PolygonNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーを使って３Ｄポリゴンを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX3DSHADER *Vertex ： ポリゴンを構成する頂点配列の先頭アドレス<br>
            int PolygonNum ： 描画するポリゴンの数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a></b> と <b><a href="dxfunc_3d_shader.html#R17N3">LoadPixelShader</a></b> で読み込んだプログラマブルシェーダーを使用して三角形ポリゴンの描画を行います。<br>
                    　Vertex の引数として用意する必要がある VERTEX3DSHADER 構造体の数は描画するポリゴンの数×３になります。<br><br>
                    　また、この関数を呼び出す前に <b><a href="dxfunc_3d_shader.html#R17N30">SetUseVertexShader</a></b> と <b><a href="dxfunc_3d_shader.html#R17N31">SetUsePixelShader</a></b> で使用するシェーダーを設定しておく必要があります。
                    ( テクスチャを使用する場合は <b><a href="dxfunc_3d_shader.html#R17N29">SetUseTextureToShader</a></b> によるテクスチャの設定も・・・ )<br>

                    　描画に使用する VERTEX3DSHADER 構造体は以下のように定義されています。<br>
<pre><div class="NormalFont">struct VERTEX3DSHADER
{
    VECTOR    pos ;      // 座標
    VECTOR    norm ;     // 法線
    COLOR_U8  dif ;      // ディフューズカラー
    COLOR_U8  spc ;      // スペキュラカラー
    float     u, v ;     // テクスチャ座標０
    float     su, sv ;   // テクスチャ座標１
} ;
</div></pre>
                    　この関数で描画処理を行った場合の頂点シェーダーの入力形式は <b><a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a></b> の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="dxfunc_3d_shader.html#R17N2">LoadVertexShader</a> や <a href="dxfunc_3d_shader.html#R17N7">SetVSConstFMtx</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N34">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygonIndexed2DToShader( VERTEX2DSHADER *Vertex, int VertexNum, unsigned short *Indices, int PolygonNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーを使って２Ｄポリゴンを描画する(インデックスを使用)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX2DSHADER *Vertex ： ポリゴンを構成する頂点配列の先頭アドレス<br>
            int VertexNum ： 頂点の数( Vertex で渡す配列の長さ )<br>
            unsigned short *Indices ： 頂点番号配列の先頭アドレス<br>
            int PolygonNum ： 描画するポリゴンの数<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N32">DrawPolygon2DToShader</a></b> と機能は殆ど同じですが、頂点番号配列を使用するところが違います。<br>
                    　例えば <b><a href="dxfunc_3d_shader.html#R17N3">LoadPixelShader</a></b> のサンプルプログラムでは VERTEX2DSHADER ６個の配列を用意していますが、
                    値を代入しているところを良く見ると配列要素１番と５番、２番と４番が全く同じなのが分かります。<br>
                    　プログラムを実行してみるとわかりますが、これは二つの三角形ポリゴンをぴったりつなぎ合わせて１枚の四角いポリゴンを表現していて、
                    二つのポリゴン中で接している頂点同士は全く同じ情報を持つからです。<br>
                    　全く同じ情報を持つならその分その情報は余計なものとなります。本来なら４頂点分の情報で済むところが６頂点分の情報を持っているわけですから・・・<br>
                    　そんなときに頂点番号配列を使用します。<br><br>

                    　頂点番号配列は三角形ポリゴンが Vertex で渡した頂点配列の何番目と何番目と何番目を使って三角形ポリゴンを表現するか、という頂点番号３つの組み合わせがひたすら代入された配列です。<br>
                    　例えば四角を表現する場合は四角の(0)左上の頂点、(1)右上の頂点、(2)左下の頂点、(3)右下の頂点の４頂点を使って、<br>
                    (0)左上の頂点、(1)右上の頂点、(2)左下の頂点で三角形ポリゴン一つ、<br>
                    (2)左下の頂点、(1)右上の頂点、(3)右下の頂点で三角形ポリゴンをもう一つ表現すれば<br>
                    四角を表現することができます。<br>
                    　このように、頂点の配列＋３角形を表現するための頂点番号の配列で三角形ポリゴンを描画するのが DrawPolygonIndexed 系の関数です。<br><br>

                    　例えば上記の場合を具体的にすると、引数 Vertex に渡す頂点の配列は<br>
                    配列の０番目に四角の左上の頂点の情報<br>
                    １番目に四角の右上の頂点の情報<br>
                    ２番目に四角の左下の頂点の情報<br>
                    ３番目に四角の右下の頂点の情報を代入しておきます。<br>
                    そして VertexNum の数は 4 です。<br><br>

                    　引数 Indices に渡す頂点番号配列は<br>
                    配列の０番目に０( 左上の頂点が代入されている配列番号 )、<br>
                    配列の１番目に１( 右上の頂点が代入されている配列番号 )、<br>
                    配列の２番目に２( 左下の頂点が代入されている配列番号 )、<br>
                    配列の３番目に２( 左下の頂点が代入されている配列番号 )、<br>
                    配列の４番目に１( 右上の頂点が代入されている配列番号 )、<br>
                    配列の５番目に３( 右下の頂点が代入されている配列番号 )を代入しておきます。<br>
                    そして PolygonNum の数は 2 です。<br><br>

                    　DrwaPolygon2DToShader の場合は Vertex 配列の要素の数が PolygonNum × 3 である必要がありましたが、<br>
                    DrawPolygonIndexed2DToShader では Vertex 配列の代わりに Indices 配列の要素の数が PolygonNum × 3 である必要があります。<br><br>

                    　四角ポリゴン１枚くらいなら Indexed の関数を使う必要は無いかもしれませんが、重複する頂点の多いポリゴン集合を描画しようとした場合は結構有用です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　LoadPixelShader のサンプルプログラムのＣ＋＋の部分のみを DrawPolygonIndexed2DToShader を使用するようにしたプログラムです。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int texhandle, pshandle ;
    VERTEX2DSHADER Vert[ 4 ] ;
    unsigned short Index[ 6 ] ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // テクスチャを読み込む
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "PixelShaderTestPS.pso" ) ;

    // ２ポリゴン分の頂点のデータをセットアップ
    Vert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;
    Vert[ 0 ].rhw = 1.0f ;
    Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 0 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 0 ].u   = 0.0f ;
    Vert[ 0 ].v   = 0.0f ;
    Vert[ 0 ].su  = 0.0f ;
    Vert[ 0 ].sv  = 0.0f ;

    Vert[ 1 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 1 ].rhw = 1.0f ;
    Vert[ 1 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 1 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 1 ].u   = 1.0f ;
    Vert[ 1 ].v   = 0.0f ;
    Vert[ 1 ].su  = 1.0f ;
    Vert[ 1 ].sv  = 0.0f ;

    Vert[ 2 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 2 ].rhw = 1.0f ;
    Vert[ 2 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 2 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 2 ].u   = 0.0f ;
    Vert[ 2 ].v   = 1.0f ;
    Vert[ 2 ].su  = 0.0f ;
    Vert[ 2 ].sv  = 1.0f ;

    Vert[ 3 ].pos = VGet( 256.0f, 256.0f, 0.0f ) ;
    Vert[ 3 ].rhw = 1.0f ;
    Vert[ 3 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 3 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 3 ].u   = 1.0f ;
    Vert[ 3 ].v   = 1.0f ;
    Vert[ 3 ].su  = 1.0f ;
    Vert[ 3 ].sv  = 1.0f ;

    // ２ポリゴン分の頂点番号配列のセットアップ
    Index[ 0 ] = 0 ;
    Index[ 1 ] = 1 ;
    Index[ 2 ] = 2 ;
    Index[ 3 ] = 2 ;
    Index[ 4 ] = 1 ;
    Index[ 5 ] = 3 ;

    // 使用するテクスチャを０番にセット
    SetUseTextureToShader( 0, texhandle ) ;

    // 使用するピクセルシェーダーをセット
    SetUsePixelShader( pshandle ) ;

    // シェーダーを使用した２Ｄの２ポリゴンの描画
    DrawPolygonIndexed2DToShader( Vert, 4, Index, 2 ) ;

    // キー入力待ち
    WaitKey() ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( texhandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</div></pre>
            <hr>

            <br><br><br><br>
            
        </td></tr>



        <tr><td><table align="center" width="950"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N35">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygonIndexed3DToShader( VERTEX3DSHADER *Vertex, int VertexNum, unsigned short *Indices, int PolygonNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーを使って２Ｄポリゴンを描画する(インデックスを使用)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX3DSHADER *Vertex ： ポリゴンを構成する頂点配列の先頭アドレス<br>
            int VertexNum ： 頂点の数( Vertex で渡す配列の長さ )<br>
            unsigned short *Indices ： 頂点番号配列の先頭アドレス<br>
            int PolygonNum ： 描画するポリゴンの数<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>－１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="dxfunc_3d_shader.html#R17N34">DrawPolygonIndexed2DToShader</a></b> の３Ｄ版です、
                    Indexed な描画関数と Indexed が付かない描画関数との違いについては DrawPolygonIndexed2DToShader の解説を参照してください。<br>
                    　シェーダーを使用した３Ｄポリゴン描画の基本的な解説については <b><a href="dxfunc_3d_shader.html#R17N33">DrawPolygon3DToShader</a></b> の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　LoadVertexShader のサンプルプログラムのＣ＋＋の部分のみを DrawPolygonIndexed3DToShader を使用するようにしたプログラムです。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
	    <FONT COLOR="#0000ff"><B>Windows用</B></FONT>
<pre><div class="NormalFont">#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3DSHADER Vertex[ 4 ] ;
    unsigned short Index[ 6 ] ;
    int vshandle ;
    int pshandle ;
    int texhandle ;
    int x ;
    int xadd ;
    float color ;
    float coloradd ;
    FLOAT4 f4 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセットアップ
    Vertex[ 0 ].pos  = VGet( 220.0f, 340.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet( 420.0f, 340.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 1.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( 220.0f, 140.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 1.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;

    Vertex[ 3 ].pos  = VGet( 420.0f, 140.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 1.0f ;
    Vertex[ 3 ].v    = 1.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    // ２ポリゴン分の頂点番号配列をセットアップ
    Index[ 0 ] = 0 ;
    Index[ 1 ] = 1 ;
    Index[ 2 ] = 2 ;
    Index[ 3 ] = 2 ;
    Index[ 4 ] = 1 ;
    Index[ 5 ] = 3 ;

    // 頂点シェーダーを読み込む
    vshandle = LoadVertexShader( "VertexShaderTestVS.vso" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "VertexShaderTestPS.pso" ) ;

    // 描画に使用する画像の読み込み
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 表示座標を移動する処理の初期化
    x = 0 ;
    xadd = 8 ;

    // 色を変化させる処理の初期化
    color = 0.0f ;
    coloradd = 1.0f / 60.0f ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 座標を移動させる
        x += xadd ;
        if( x &gt; 200 || x &lt; -200 )
        {
            xadd = -xadd ;
        }

        // 色の値を変化させる
        color += coloradd ;
        if( color &lt;= 0.0f || color &gt;= 1.0f )
        {
            coloradd = -coloradd ;
        }

        // 座標値を頂点シェーダー float4型定数０番にセット
        f4.x = ( float )x ;
        f4.y = 0.0f ;
        f4.z = 0.0f ;
        f4.w = 0.0f ;
        SetVSConstF( 0, f4 ) ;

        // 色の値をピクセルシェーダー float4型定数０番にセット
        f4.x = color ;
        f4.y = color ;
        f4.z = color ;
        f4.w = 1.0f ;
        SetPSConstF( 0, f4 ) ;

        // 使用する頂点シェーダーのセット
        SetUseVertexShader( vshandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // シェーダーを使用した２ポリゴンの描画
        DrawPolygonIndexed3DToShader( Vertex, 4, Index, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 使用した頂点シェーダーの float4型定数の設定を無効化する
    ResetVSConstF( 0, 2 ) ;

    // 使用したピクセルシェーダーの float4型定数の設定を無効化する
    ResetPSConstF( 0, 1 ) ;

    // 読み込んだ頂点シェーダーの削除
    DeleteShader( vshandle ) ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // 読み込んだ画像のグラフィックハンドルを削除
    <b><a href="dxfunc_graph1.html#R3N15">DeleteGraph</a></b>( texhandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</div></pre>
            <hr>

            <br><br><br><br>
            
        </td></tr>
        
        <tr><td colspan="4">
            <hr>
            <font size="3"><b>
                <a href="../dxfunc.html">戻る</a>
            </b></font>
        </td></tr>
    </table>
    </div>
    </body>
</html>
